<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON GRAVITY: ORBITAL</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        #score-display {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        .sub-text {
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }

        #gauge-box {
            width: 160px;
            text-align: right;
            pointer-events: auto;
        }

        .bar-label {
            font-size: 10px;
            color: #0ff;
            display: block;
            margin-bottom: 2px;
        }

        .bar-frame {
            width: 100%;
            height: 8px;
            border: 1px solid #0ff;
            background: rgba(0,20,40,0.8);
            margin-bottom: 5px;
        }

        #shield-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: width 0.1s;
        }

        .shield-critical {
            animation: blink 0.2s infinite;
            background: #f00 !important;
        }

        .bar-label.enemy {
            color: #f00;
        }

        .bar-frame.enemy {
            border-color: #f00;
            background: rgba(40,0,0,0.8);
        }

        #enemy-bar {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.5s;
        }

        #warning-msg {
            display: none;
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #f00;
            font-size: 24px;
            animation: blink 0.2s infinite;
        }

        #stage-msg {
            display: none;
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 40px;
            text-shadow: 0 0 20px #0ff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 105;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .menu-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 20px 50px;
            margin: 10px;
            font-size: 22px;
            font-family: 'Orbitron';
            cursor: pointer;
            min-width: 240px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

            .menu-btn:active {
                background: #0ff;
                color: #000;
                transform: scale(0.95);
            }

        #ost-ui {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 110;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .track-item {
            padding: 20px;
            width: 80%;
            border-bottom: 1px solid #333;
            color: #888;
            text-align: center;
            font-size: 18px;
        }

            .track-item.playing {
                color: #0ff;
                border-color: #0ff;
            }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            touch-action: none;
            pointer-events: auto;
        }

        .joystick-area {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255,255,255,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            position: absolute;
            transform: translate(0, 0);
            transition: transform 0.05s;
        }

        #launch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.15);
            border: 2px solid #ff0;
            color: #ff0;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            box-shadow: 0 0 10px #ff0;
            pointer-events: auto;
        }

            #launch-btn.active {
                background: #ff0;
                color: #000;
                transform: scale(0.9);
            }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>

    <div id="ui">
        <div class="hud-row">
            <div id="info-box">
                <div id="score-display">000000</div>
                <div class="sub-text">STAGE: <span id="stage-num">1</span></div>
                <div class="sub-text">WEAPON: <span id="w-lv">1</span></div>
            </div>
            <div id="gauge-box">
                <span class="bar-label">SHIELD</span>
                <div class="bar-frame"><div id="shield-bar"></div></div>
                <span class="bar-label enemy">ENEMY SWARM</span>
                <div class="bar-frame enemy"><div id="enemy-bar"></div></div>
            </div>
        </div>
        <div id="warning-msg">GRAVITY CRITICAL</div>
        <div id="stage-msg">STAGE CLEAR</div>
    </div>

    <div id="overlay">
        <h1 style="color:#0ff; font-size:40px; margin-bottom:40px; text-shadow:0 0 20px #0ff; text-align:center;">NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span></h1>
        <div class="menu-btn" id="btn-start">START GAME</div>
        <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
        <div class="menu-btn" id="btn-title" style="display:none;">TITLE</div>
        <div style="font-size:12px;color:#888;margin-top:20px;">PC: [X] Bomb<br>MOBILE: Small Button to Bomb</div>
    </div>

    <div id="pause-overlay">
        <h1 style="color:#fff; font-size:40px; text-shadow:0 0 10px #fff;">PAUSED</h1>
        <p style="color:#aaa; margin-top:20px;">TAP TO RESUME</p>
    </div>

    <div id="ost-ui">
        <h2 style="color:#0ff;">SOUNDTRACK</h2>
        <div id="track-list" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
        <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
    </div>

    <div id="controls">
        <div id="stick-left" class="joystick-area"><div class="knob" id="knob-left"></div></div>
        <div id="stick-right" class="joystick-area"><div class="knob" id="knob-right"></div></div>
        <div id="launch-btn">BOMB</div>
    </div>

    <canvas id="game"></canvas>

    <script>
        // --- 設定と定数 (編集して難易度や見た目を調整できます) ---

        // グラフィック・基本挙動
        const G_SCALE = 0.7;             // 全体の描画サイズ倍率 (0.5で半分、1.0で最大)
        const SPEED_SCALE = 0.25;        // ゲーム全体の移動速度の基準値
        const WALL_MARGIN = 5;           // ステージ端の見えない壁の厚み
        const MAX_WEAPON_LEVEL = 5;      // ショットの最大レベル (レベルが高いほど弾数が増える)
        const GRID_SPACING = 30;         // 背景グリッド線の密度 (小さいほど網目が細かくなる)

        // 敵機の速度
        const ENEMY_SPEEDS = {
            TRIANGLE: 4.8,               // 紫：主力機の最高速度
            CUBE: 2.5,                   // 緑：アイテム持ちの最高速度
            TADPOLE: 6,                  // 白：精子型の最高速度
            DRAGON: 8                    // 赤：ボスの最高移動速度
        };
        const DRAGON_ACCELERATION = 0.2; // ボスがプレイヤーを追いかける時の加速の強さ

        // --- 敵キャラクター別の当たり判定半径 (Hitbox) ---
        const ENEMY_HITBOX = {
            TRIANGLE: 12,  // 紫
            CUBE: 15,      // 緑
            TADPOLE: 18,   // 白
            DRAGON: 25,    // 赤
            BULLET: 8      // ★追加: 敵の「弾」自体の当たり判定半径
        };

        // エフェクト演出
        const EXPLOSION_SPEED_MAG = 2.0; // 敵撃破時の火花の飛散速度 (大きいほど勢いが増す)
        const EXPLOSION_COUNT_MAG = 1.5; // 敵撃破時の火花の量 (大きくすると豪華になりますが重くなる可能性あり)

        // 弾の設定
        const BULLET_SETTINGS = {
            PLAYER_SPEED: 32.0,          // 自機の通常弾のスピード
            PLAYER_LIFE: 120,            // 自機の弾が消えるまでの時間 (実質的な射程距離)
            ENEMY_SPEED: 10.0,           // 敵が撃ってくる弾のスピード
            ENEMY_LIFE: 200              // 敵の弾の射程
        };

        // 敵の出現バランス (難易度に直結)
        const SPAWN_SETTINGS = {
            BASE_ENEMIES: 60,            // ステージ1の敵の総数
            ENEMIES_PER_STAGE: 15,       // ステージが進むごとに追加される敵の数
            MAX_WORMHOLES_BASE: 5,       // 画面内に同時に存在する敵の湧き穴の数
            SPAWN_INTERVAL: 180,         // 湧き穴から敵が出る間隔 (フレーム数。60=1秒)
            WORMHOLE_CHANCE: 0.03        // 新しい湧き穴が画面内に発生する確率 (毎フレーム判定)
        };


        // アイテム・特殊武器
        const LASER_DURATION = 600;      // レーザーを取得した時の持続時間 (600=10秒間)
        const ITEM_LIFE = 240;           // 出現したアイテムが消えるまでの時間 (約4秒)

        // --- Global Variables ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const ui = {
            overlay: document.getElementById('overlay'),
            pauseOverlay: document.getElementById('pause-overlay'),
            ost: document.getElementById('ost-ui'),
            controls: document.getElementById('controls'),
            score: document.getElementById('score-display'),
            stage: document.getElementById('stage-num'),
            wLv: document.getElementById('w-lv'),
            shieldBar: document.getElementById('shield-bar'),
            enemyBar: document.getElementById('enemy-bar'),
            msg: document.getElementById('stage-msg'),
            warn: document.getElementById('warning-msg'),
            launchBtn: document.getElementById('launch-btn'),
            knobL: document.getElementById('knob-left'),
            knobR: document.getElementById('knob-right'),
            stickL: document.getElementById('stick-left'),
            stickR: document.getElementById('stick-right'),
            btnStart: document.getElementById('btn-start'),
            btnOst: document.getElementById('btn-ost'),
            btnTitle: document.getElementById('btn-title'),
            titleText: document.querySelector('#overlay h1')
        };

        let width, height, worldSize = 0, camera = { x: 0, y: 0 };
        let gameState = 'TITLE';
        let previousGameState = '';
        let score = 0, frame = 0, stage = 1;
        let spawnedCount = 0, enemiesToSpawn = 0, isStageClear = false, killCount = 0;
        let dyingTimer = 0;

        const player = { x: 0, y: 0, vx: 0, vy: 0, angle: 0, satellites: [], shield: 100, weaponLevel: 1, invuln: 0, laserTimer: 0 };
        const input = { move: { x: 0, y: 0, active: false }, aim: { x: 0, y: 0, active: false }, keys: {} };
        let bullets = [], lasers = [], enemies = [], enemyBullets = [], particles = [], crystals = [], missiles = [], powerups = [], wormholes = [], scorePopups = [], gridPoints = [], rings = [], stars = [];

        // --- Audio System ---
        const BGM_FILES = {
            title: 'audio/Neo_Gravity_Title.mp3',
            clear: 'audio/Neo_Gravity_Clear.mp3',
            stages: ['audio/Neo_Gravity_00.mp3', 'audio/Neo_Gravity_01.mp3', 'audio/Neo_Gravity_02.mp3', 'audio/Neo_Gravity_03.mp3']
        };

        const AudioSys = {
            ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null,
            init() {
                if (!this.ctx) {
                    try { const AC = window.AudioContext || window.webkitAudioContext; if (AC) { this.ctx = new AC(); this.createNoise(); } } catch (e) { }
                }
                if (!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
            },
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => { }); },
            createNoise() {
                if (!this.ctx) return;
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                this.noiseBuffer = buf;
            },
            playSE(type) {
                if (!this.ctx) return;
                this.resume();
                const t = this.ctx.currentTime;
                const g = this.ctx.createGain(); g.connect(this.ctx.destination);

                if (type === 'shoot') {
                    const o = this.ctx.createOscillator(); o.type = 'triangle';
                    o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g); o.start(t); o.stop(t + 0.1);
                } else if (type === 'laser') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(120, t); o.frequency.linearRampToValueAtTime(80, t + 0.15);
                    const mod = this.ctx.createOscillator(); mod.type = 'square'; mod.frequency.value = 500;
                    const modGain = this.ctx.createGain(); modGain.gain.value = 500;
                    mod.connect(modGain); modGain.connect(o.frequency); mod.start(t); mod.stop(t + 0.15);
                    g.gain.setValueAtTime(0.15, t); g.gain.linearRampToValueAtTime(0, t + 0.15);
                    o.connect(g); o.start(t); o.stop(t + 0.15);
                } else if (type === 'explode' || type === 'dragon_explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        const startFreq = type === 'dragon_explode' ? 200 : 600;
                        const dur = type === 'dragon_explode' ? 1.5 : 0.5;
                        f.frequency.setValueAtTime(startFreq, t); f.frequency.exponentialRampToValueAtTime(20, t + dur);
                        g.gain.setValueAtTime(type === 'dragon_explode' ? 0.8 : 0.6, t); g.gain.exponentialRampToValueAtTime(0.01, t + dur);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + dur);
                    }
                } else if (type === 'launch') {
                    const o = this.ctx.createOscillator(); o.type = 'square';
                    o.frequency.setValueAtTime(200, t); o.frequency.linearRampToValueAtTime(600, t + 0.4);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.4);
                    o.connect(g); o.start(t); o.stop(t + 0.4);
                } else if (type === 'powerup') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1800, t + 0.2);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'damage') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(50, t + 0.2);
                    g.gain.setValueAtTime(0.4, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'invincible') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(800, t + 0.5);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.connect(g); o.start(t); o.stop(t + 0.5);
                }
            },
            playBGM(key, idx = 0) {
                if (!this.bgmEl) return;
                let src = key === 'title' ? BGM_FILES.title : key === 'clear' ? BGM_FILES.clear : BGM_FILES.stages[idx % BGM_FILES.stages.length];
                if (this.currentSrc === src && !this.bgmEl.paused) return;
                this.bgmEl.src = src; this.bgmEl.currentTime = 0; this.bgmEl.play().catch(e => { });
                this.currentSrc = src;
            },
            stopBGM() { if (this.bgmEl) this.bgmEl.pause(); },
            pauseBGM() { if (this.bgmEl && !this.bgmEl.paused) this.bgmEl.pause(); },
            resumeBGM() { if (this.bgmEl && this.bgmEl.paused && this.currentSrc) this.bgmEl.play().catch(() => { }); }
        };
        // --- Menu Logic ---
        function openOST() {
            AudioSys.resume();
            gameState = 'OST';
            ui.overlay.style.display = 'none';
            ui.ost.style.display = 'flex';
            const list = document.getElementById('track-list');
            list.innerHTML = '';
            const tracks = [
                { n: 'Title Theme', k: 'title' },
                { n: 'Stage 1', k: 'stage', i: 0 },
                { n: 'Stage 2', k: 'stage', i: 1 },
                { n: 'Stage 3', k: 'stage', i: 2 },
                { n: 'Stage 4', k: 'stage', i: 3 },
                { n: 'Clear Theme', k: 'clear' }
            ];
            tracks.forEach(t => {
                const d = document.createElement('div'); d.className = 'track-item'; d.innerText = t.n;
                d.onclick = () => {
                    AudioSys.playBGM(t.k, t.i);
                    document.querySelectorAll('.track-item').forEach(e => e.classList.remove('playing'));
                    d.classList.add('playing');
                };
                list.appendChild(d);
            });
        }

        function closeOST() { returnToTitle(); }

        function launchSatellites() {
            if (player.satellites.length === 0) return;
            AudioSys.playSE('launch');
            player.satellites.forEach(s => {
                missiles.push({
                    x: s.x, y: s.y,
                    vx: Math.cos(s.angle) * 10 * SPEED_SCALE,
                    vy: Math.sin(s.angle) * 10 * SPEED_SCALE,
                    target: null, life: 200, speed: 12 * SPEED_SCALE
                });
            });
            player.satellites = [];
            distortGrid(player.x, player.y, 300, 400);
        }

        // --- Layout & Init ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const size = Math.max(width, height) * 1.5;
            worldSize = size;

            // Controls Layout
            const isPortrait = height > width;
            if (isPortrait) {
                ui.stickL.style.left = '40px'; ui.stickL.style.bottom = '50px'; ui.stickL.style.right = 'auto';
                ui.stickR.style.right = '40px'; ui.stickR.style.bottom = '50px'; ui.stickR.style.left = 'auto';
                ui.launchBtn.style.right = '40px'; ui.launchBtn.style.bottom = '180px';
            } else {
                ui.stickL.style.left = '20px'; ui.stickL.style.bottom = '40px';
                ui.stickR.style.right = '20px'; ui.stickR.style.bottom = '40px';
                ui.launchBtn.style.right = '20px'; ui.launchBtn.style.bottom = '170px';
            }
            initGrid();
            initStars();
        }

        function initGrid() {
            const cols = Math.ceil(worldSize / GRID_SPACING) + 2;
            const rows = Math.ceil(worldSize / GRID_SPACING) + 2;
            gridPoints = [];
            for (let x = 0; x <= cols; x++) {
                gridPoints[x] = [];
                for (let y = 0; y <= rows; y++) gridPoints[x][y] = { x: x * GRID_SPACING, y: y * GRID_SPACING, ox: x * GRID_SPACING, oy: y * GRID_SPACING, vx: 0, vy: 0 };
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({ x: Math.random() * worldSize, y: Math.random() * worldSize, size: Math.random() * 2, brightness: Math.random(), parallax: 0.2 + Math.random() * 0.3 });
            }
        }

        // --- Game Logic ---
        function startGame() {
            AudioSys.init(); AudioSys.resume(); AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            ui.overlay.style.display = 'none'; ui.ost.style.display = 'none';
            ui.controls.style.display = 'block';

            score = 0;
            stage = 1;
            frame = 0;

            player.x = worldSize / 2;
            player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 2;
            player.satellites = []; player.invuln = 0; player.laserTimer = 0;

            ui.score.innerText = "000000"; ui.stage.innerText = "3"; ui.wLv.innerText = "2";
            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none';

            startStage();
        }

        function resetGame() {
            // Variable Reset
            score = 0; stage = 3; frame = 0;
            spawnedCount = 0; enemiesToSpawn = 0; isStageClear = false; killCount = 0;
            bullets = []; lasers = []; enemies = []; enemyBullets = []; particles = []; crystals = []; missiles = []; powerups = []; wormholes = []; scorePopups = []; rings = [];

            player.x = worldSize / 2; player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 2; player.invuln = 0; player.laserTimer = 0; player.satellites = [];

            // UI Reset
            ui.score.innerText = "000000"; ui.stage.innerText = "3"; ui.wLv.innerText = "2";
            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none'; ui.msg.style.display = 'none';
            ui.overlay.style.display = 'none'; ui.controls.style.display = 'block';

            // Restart Logic
            AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            startStage();
        }

        function returnToTitle() {
            gameState = 'TITLE';
            ui.ost.style.display = 'none';
            ui.overlay.style.display = 'flex';
            ui.controls.style.display = 'none';
            ui.msg.style.display = 'none';

            ui.titleText.innerHTML = `NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>`;
            ui.titleText.style.color = '#0ff'; ui.titleText.style.textShadow = '0 0 20px #0ff';

            ui.btnStart.innerText = 'START GAME';
            ui.btnStart.style.borderColor = '#0ff'; ui.btnStart.style.color = '#0ff';
            ui.btnStart.onclick = startGame;

            ui.btnOst.style.display = 'block';
            ui.btnTitle.style.display = 'none';
            AudioSys.playBGM('title');
        }

        function startStage() {
            enemiesToSpawn = SPAWN_SETTINGS.BASE_ENEMIES + (stage * SPAWN_SETTINGS.ENEMIES_PER_STAGE);
            spawnedCount = 0; isStageClear = false; killCount = 0;
            ui.msg.style.display = 'none';
            bullets = []; lasers = []; enemies = []; enemyBullets = []; crystals = []; missiles = []; powerups = []; wormholes = []; scorePopups = []; rings = [];

            if (gameState === 'PLAYING' && stage > 1) AudioSys.playBGM('stage', stage - 1);

            const whCount = Math.max(1, Math.floor((stage + 1) / 2));
            for (let i = 0; i < whCount; i++) spawnWormhole();
        }

        function spawnWormhole() {
            wormholes.push({
                x: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                y: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                life: 400, maxLife: 400, active: true
            });
            distortGrid(wormholes[wormholes.length - 1].x, wormholes[wormholes.length - 1].y, 50, 150);
        }

        function spawnEnemy(x, y, type) {
            const spd = SPEED_SCALE;
            const angle = Math.random() * Math.PI * 2;
            const bSpd = 5.0 * spd;
            const vx = Math.cos(angle) * bSpd; const vy = Math.sin(angle) * bSpd;
            const rnd = Math.random();
            let dropType = rnd < 0.1 ? 'laser' : rnd < 0.3 ? 'level' : 'crystal';

            if (type === 'dragon') {
                let e = { x: x, y: y, vx: vx, vy: vy, hp: 8, speed: ENEMY_SPEEDS.DRAGON * spd, color: '#f00', type: 'dragon', angle: 0, segments: [], drop: 'invincible', scale: 0.9, fireTimer: 0 };
                for (let i = 0; i < 16; i++) e.segments.push({ x: x, y: y, angle: 0 });
                enemies.push(e); spawnedCount++;
            } else if (type === 'cube') {
                enemies.push({ x, y, vx, vy, hp: 2, speed: ENEMY_SPEEDS.CUBE * spd, color: '#0f0', type: 'cube', angle: 0, drop: dropType, scale: 0.8, rotX: 0, rotY: 0 });
                spawnedCount++;
            } else if (type === 'tadpole') {
                enemies.push({ x, y, vx, vy, hp: 1, speed: ENEMY_SPEEDS.TADPOLE * spd, color: '#fff', type: 'tadpole', angle: 0, drop: 'none', scale: 0.6, history: [] });
                spawnedCount++;
            } else if (type === 'triangle') {
                const forms = ['V', 'line', 'circle'];
                const form = forms[Math.floor(Math.random() * forms.length)];
                const initialAngle = Math.atan2(vy, vx);
                const leader = { x: x, y: y, vx: vx, vy: vy, hp: 1, speed: ENEMY_SPEEDS.TRIANGLE * spd, color: '#d0f', type: 'triangle', angle: initialAngle, drop: dropType, scale: 0.7, isLeader: true, followers: [], rotX: Math.random() * Math.PI, rotY: Math.random() * Math.PI, rotZ: Math.random() * Math.PI };
                enemies.push(leader); spawnedCount++;
                for (let i = 1; i <= 4; i++) {
                    if (spawnedCount >= enemiesToSpawn) break;
                    let offX = 0, offY = 0;
                    if (form === 'V') { offX = Math.ceil(i / 2) * -30; offY = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 20; }
                    else if (form === 'line') { offX = -Math.ceil(i / 2) * 45; }
                    else { const a = (Math.PI * 2 / 5) * i; offX = Math.cos(a) * 40; offY = Math.sin(a) * 40; }
                    const rx = offX * Math.cos(initialAngle) - offY * Math.sin(initialAngle);
                    const ry = offX * Math.sin(initialAngle) + offY * Math.cos(initialAngle);
                    let e = { x: x + rx, y: y + ry, vx, vy, hp: 1, speed: ENEMY_SPEEDS.TRIANGLE * spd, color: '#d0f', type: 'triangle', angle: initialAngle, drop: 'none', scale: 0.7, leader: leader, formOffset: { x: offX, y: offY }, rotX: Math.random() * Math.PI, rotY: Math.random() * Math.PI, rotZ: Math.random() * Math.PI };
                    enemies.push(e); leader.followers.push(e); spawnedCount++;
                }
            }
        }

        // --- Main Loop ---
        function loop() {
            requestAnimationFrame(loop);
            if (gameState === 'PAUSED') return;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);

            if (gameState === 'PLAYING') update();
            else if (gameState === 'DYING') updateDying();

            draw();
        }

        function updateDying() {
            dyingTimer--;
            camera.x += (Math.random() - 0.5) * 5; camera.y += (Math.random() - 0.5) * 5;
            updateGrid(); updateParticlesAndRings(); updateEnemyBullets(); updateEnemiesForDying();
            if (dyingTimer <= 0) showGameOver();
        }

        function updateEnemiesForDying() {
            enemies.forEach(e => {
                e.x += e.vx; e.y += e.vy;
                if (e.type === 'dragon') {
                    let lx = e.x, ly = e.y;
                    e.segments.forEach(s => { const dd = Math.hypot(lx - s.x, ly - s.y); if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; } lx = s.x; ly = s.y; });
                }
            });
        }

        function showGameOver() {
            gameState = 'GAMEOVER';
            AudioSys.stopBGM();
            ui.controls.style.display = 'none';
            ui.overlay.style.display = 'flex';

            ui.titleText.innerHTML = `GAME OVER<br><span style="font-size:20px;color:#f00;">SCORE: ${score}</span>`;
            ui.titleText.style.color = '#f00'; ui.titleText.style.textShadow = '0 0 20px #f00';

            ui.btnStart.innerText = 'RETRY';
            ui.btnStart.style.borderColor = '#f00'; ui.btnStart.style.color = '#f00';
            ui.btnStart.onclick = (e) => { e.stopPropagation(); e.preventDefault(); resetGame(); };

            ui.btnOst.style.display = 'none';
            ui.btnTitle.style.display = 'block';
            ui.btnTitle.style.borderColor = '#f00'; ui.btnTitle.style.color = '#f00';
            ui.btnTitle.onclick = (e) => { e.stopPropagation(); e.preventDefault(); returnToTitle(); };
        }

        function update() {
            frame++;
            if (!Number.isFinite(player.x)) { player.x = worldSize / 2; player.y = worldSize / 2; player.vx = 0; player.vy = 0; }

            // Controls
            let mx = input.keys['ArrowLeft'] ? -1 : input.keys['ArrowRight'] ? 1 : input.move.x;
            let my = input.keys['ArrowUp'] ? -1 : input.keys['ArrowDown'] ? 1 : input.move.y;
            const mag = Math.hypot(mx, my); if (mag > 1) { mx /= mag; my /= mag; }
            player.vx = mx * 7.8 * SPEED_SCALE; player.vy = my * 7.8 * SPEED_SCALE;
            player.x += player.vx; player.y += player.vy;
            if (player.x < WALL_MARGIN) player.x = WALL_MARGIN; if (player.x > worldSize - WALL_MARGIN) player.x = worldSize - WALL_MARGIN;
            if (player.y < WALL_MARGIN) player.y = WALL_MARGIN; if (player.y > worldSize - WALL_MARGIN) player.y = worldSize - WALL_MARGIN;
            camera.x = player.x - width / 2; camera.y = player.y - height / 2;

            if (input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
            else if (Math.hypot(mx, my) > 0.1) player.angle = Math.atan2(my, mx);

            const fireInterval = player.laserTimer > 0 ? 4 : 6;
            if ((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % fireInterval === 0) fire();

            const maxWormholes = SPAWN_SETTINGS.MAX_WORMHOLES_BASE + stage;
            if (spawnedCount < enemiesToSpawn && wormholes.filter(w => w.active).length < maxWormholes && Math.random() < SPAWN_SETTINGS.WORMHOLE_CHANCE) spawnWormhole();

            wormholes.forEach((w) => {
                w.life--;
                if (w.active) {
                    if (w.life > 60 && w.life % SPAWN_SETTINGS.SPAWN_INTERVAL === 0 && spawnedCount < enemiesToSpawn) {
                        const r = Math.random();
                        if (r < 0.20) spawnEnemy(w.x, w.y, 'dragon');
                        else if (r < 0.35) spawnEnemy(w.x, w.y, 'cube');
                        else if (r < 0.65) spawnEnemy(w.x, w.y, 'tadpole');
                        else spawnEnemy(w.x, w.y, 'triangle');
                    }
                    if (w.life <= 0) w.active = false;
                    const dx = player.x - w.x; const dy = player.y - w.y;
                    const d = Math.hypot(dx, dy) || 0.01;
                    if (d < 180) { const f = 500 / (d + 1); player.x += (dx / d) * f * 0.01; player.y += (dy / d) * f * 0.01; }
                }
            });
            wormholes = wormholes.filter(w => w.life > -60);

            player.satellites.forEach((s, i) => {
                s.angle = (s.angle || 0) + 0.15;
                const rad = 45 * G_SCALE;
                const off = (Math.PI * 2 / player.satellites.length) * i;
                s.x = player.x + Math.cos(s.angle + off) * rad; s.y = player.y + Math.sin(s.angle + off) * rad;
            });

            updateEntities(); updateGrid(); updateScorePopups();

            const enemyRemains = (enemiesToSpawn - killCount);
            ui.enemyBar.style.width = `${Math.max(0, (enemyRemains / enemiesToSpawn) * 100)}%`;

            if (spawnedCount >= enemiesToSpawn && enemies.length === 0 && !isStageClear) {
                isStageClear = true; ui.msg.style.display = 'block'; AudioSys.playBGM('clear');
                setTimeout(() => { stage++; ui.stage.innerText = stage; startStage(); }, 4000);
            }

            if (player.shield < 30) ui.shieldBar.classList.add('shield-critical'); else ui.shieldBar.classList.remove('shield-critical');

            if (player.laserTimer > 0) { player.laserTimer--; ui.wLv.innerText = "LASER (" + Math.ceil(player.laserTimer / 60) + "s)"; ui.wLv.style.color = "#0ff"; }
            else { ui.wLv.innerText = player.weaponLevel; ui.wLv.style.color = "#fff"; }
        }

        function fire() {
            if (player.laserTimer > 0) {
                lasers.push({ x: player.x, y: player.y, angle: player.angle, life: 5, width: 40 });
                AudioSys.playSE('laser'); distortGrid(player.x, player.y, 20, 60); return;
            }
            const s = BULLET_SETTINGS.PLAYER_SPEED * SPEED_SCALE;
            for (let i = 0; i < player.weaponLevel; i++) {
                const a = player.angle + (i - (player.weaponLevel - 1) / 2) * 0.15;
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: BULLET_SETTINGS.PLAYER_LIFE });
            }
            AudioSys.playSE('shoot'); distortGrid(player.x, player.y, 10, 40);
        }

        function updateEntities() {
            updatePlayerBullets(); updateLasers(); updateEnemies(); updateEnemyBullets(); updateCrystals(); updatePowerups(); updateMissiles(); updateParticlesAndRings(); updatePlayerStatus();
        }

        function updateLasers() {
            lasers.forEach(l => {
                l.life--;
                const len = 2000; const p1x = l.x; const p1y = l.y; const p2x = l.x + Math.cos(l.angle) * len; const p2y = l.y + Math.sin(l.angle) * len;
                enemies.forEach(e => {
                    const A = p1x - p2x; const B = p1y - p2y; const C = p2x * p1y - p1x * p2y;
                    const dist = Math.abs(A * e.y - B * e.x + C) / Math.hypot(A, B);
                    const dot = (e.x - p1x) * (p2x - p1x) + (e.y - p1y) * (p2y - p1y);
                    if (dist < (l.width / 2 + 15 * e.scale) && dot > 0) {
                        e.hp -= 0.5;
                        if (frame % 4 === 0) particles.push({ x: e.x, y: e.y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, color: '#0ff', life: 0.5 });
                    }
                });
            });
            lasers = lasers.filter(l => l.life > 0);
        }

        function updatePlayerBullets() {
            bullets.forEach(b => {
                b.x += b.vx; b.y += b.vy; b.life--;
                enemies.forEach(e => { if (Math.hypot(b.x - e.x, b.y - e.y) < 30 * e.scale) { b.life = 0; e.hp--; } });
            });
            bullets = bullets.filter(b => b.life > 0);
        }

        function updateEnemies() {
            enemies.forEach(e => {
                if (e.leader && e.leader.hp > 0) { updateFormationMovement(e); if (e.type === 'triangle') { e.rotX += 0.08; e.rotY += 0.12; e.rotZ += 0.05; } }
                else {
                    switch (e.type) {
                        case 'dragon': updateDragonAI(e); break;
                        case 'tadpole': updateTadpoleAI(e); break;
                        case 'triangle': updateTriangleAI(e); break;
                        case 'cube': updateCubeAI(e); break;
                    }
                }
                applySeparation(e); applyWorldBoundary(e); checkPlayerCollision(e); checkSatelliteCollision(e);
                if (e.hp <= 0) destroyEnemy(e);
            });
            enemies = enemies.filter(e => e.hp > 0);
        }

        function updateDragonAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * DRAGON_ACCELERATION * SPEED_SCALE; e.vy += (dy / d) * DRAGON_ACCELERATION * SPEED_SCALE; e.vx *= 0.98; e.vy *= 0.98;
            const cv = Math.hypot(e.vx, e.vy); const lim = ENEMY_SPEEDS.DRAGON * SPEED_SCALE;
            if (cv > lim) { e.vx = (e.vx / cv) * lim; e.vy = (e.vy / cv) * lim; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(dy, dx);
            let lx = e.x, ly = e.y; e.segments.forEach(s => { const dd = Math.hypot(lx - s.x, ly - s.y); if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; } lx = s.x; ly = s.y; });
            e.fireTimer++;
            if (e.fireTimer > 100) { e.fireTimer = 0; const bSpd = BULLET_SETTINGS.ENEMY_SPEED * SPEED_SCALE; enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(e.angle) * bSpd, vy: Math.sin(e.angle) * bSpd, life: BULLET_SETTINGS.ENEMY_LIFE }); AudioSys.playSE('shoot'); }
        }

        function updateTadpoleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(dy, dx);
            e.history.unshift({ x: e.x, y: e.y }); if (e.history.length > 60) e.history.pop();
        }

        function updateTriangleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(e.vy, e.vx); e.rotX += 0.08; e.rotY += 0.12; e.rotZ += 0.05;
        }

        function updateCubeAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.rotX += 0.03; e.rotY += 0.04;
        }

        function updateFormationMovement(e) {
            if (!e.leader || e.leader.hp <= 0) return;
            const la = e.leader.angle;
            const rotatedOffX = e.formOffset.x * Math.cos(la) - e.formOffset.y * Math.sin(la);
            const rotatedOffY = e.formOffset.x * Math.sin(la) + e.formOffset.y * Math.cos(la);
            const targetX = e.leader.x + rotatedOffX; const targetY = e.leader.y + rotatedOffY;
            e.x += (targetX - e.x) * 0.3; e.y += (targetY - e.y) * 0.3;
            e.vx = e.leader.vx; e.vy = e.leader.vy; e.angle = la;
        }

        function applySeparation(e) {
            enemies.forEach(other => {
                if (e === other) return;
                const odx = e.x - other.x, ody = e.y - other.y; const od = Math.hypot(odx, ody);
                if (od < 30) { const push = (30 - od) * 0.05; e.x += (odx / od) * push; e.y += (ody / od) * push; }
            });
        }

        function applyWorldBoundary(e) {
            if (e.x < WALL_MARGIN || e.x > worldSize - WALL_MARGIN) e.vx *= -1.2;
            if (e.y < WALL_MARGIN || e.y > worldSize - WALL_MARGIN) e.vy *= -1.2;
            e.x = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.x));
            e.y = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.y));
        }

        function checkPlayerCollision(e) {
            if (gameState === 'DYING') return;

            // 距離を計算
            const dist = Math.hypot(player.x - e.x, player.y - e.y);

            // 敵の種類に応じた判定半径を取得（種類が見つからない場合は15をデフォルトにする）
            let radius = 15;
            if (e.type === 'triangle') radius = ENEMY_HITBOX.TRIANGLE;
            else if (e.type === 'cube') radius = ENEMY_HITBOX.CUBE;
            else if (e.type === 'tadpole') radius = ENEMY_HITBOX.TADPOLE;
            else if (e.type === 'dragon') radius = ENEMY_HITBOX.DRAGON;

            // スケール補正（敵が個別に拡大縮小している場合に対応）
            const collisionDist = radius * (e.scale / 0.7);

            if (dist < collisionDist) {
                player.shield -= 0.5;
                if (player.invuln <= 0) {
                    player.shield -= 10;
                    player.invuln = 10;
                    createExplosion(player.x, player.y, '#f00', 5);
                    AudioSys.playSE('damage');
                }
                ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                if (player.shield <= 0) damage(0);
            }
        }

        function checkSatelliteCollision(e) {
            for (let i = player.satellites.length - 1; i >= 0; i--) {
                const s = player.satellites[i];
                if (Math.hypot(s.x - e.x, s.y - e.y) < 25) { e.hp = 0; player.satellites.splice(i, 1); e.noDrop = true; break; }
            }
        }

        function updateEnemyBullets() {
            enemyBullets.forEach(eb => {
                const oldX = eb.x;
                const oldY = eb.y;

                eb.x += eb.vx;
                eb.y += eb.vy;
                eb.life--;

                if (gameState !== 'DYING' && player.invuln <= 0) {
                    const dx = eb.x - oldX;
                    const dy = eb.y - oldY;
                    const t = ((player.x - oldX) * dx + (player.y - oldY) * dy) / (dx * dx + dy * dy);
                    const closestT = Math.max(0, Math.min(1, t));
                    const closestX = oldX + closestT * dx;
                    const closestY = oldY + closestT * dy;

                    const dist = Math.hypot(player.x - closestX, player.y - closestY);

                    if (dist < ENEMY_HITBOX.BULLET) {
                        eb.life = 0;
                        createExplosion(player.x, player.y, '#f00', 10);
                        damage(15);
                    }
                }
            });
            enemyBullets = enemyBullets.filter(eb => eb.life > 0);
        }

        function updateCrystals() {
            crystals.forEach(c => {
                c.life--;
                const dx = player.x - c.x, dy = player.y - c.y;
                const d = Math.hypot(dx, dy) || 0.0001;

                // 数値を引き上げ（0.03 → 0.08 / 0.0005 → 0.001）
                // これにより、遠くからでも加速しながら一気に自機へ飛び込んできます
                const factor = 0.03 + (d * 0.0005);

                c.x += dx * factor;
                c.y += dy * factor;

                // 取得判定（d < 20）はそのまま
                if (d < 20) {
                    c.life = 0;
                    if (player.satellites.length < 12) player.satellites.push({});
                }
            });
            crystals = crystals.filter(c => c.life > 0);
        }

        function updatePowerups() {
            powerups.forEach(p => {
                p.life--;
                const d = Math.hypot(player.x - p.x, player.y - p.y);
                if (d < 30) {
                    p.life = 0; AudioSys.playSE('powerup');
                    if (p.type === 'laser') { player.laserTimer = LASER_DURATION; rings.push({ x: player.x, y: player.y, r: 10, color: '#0ff', life: 1 }); rings.push({ x: player.x, y: player.y, r: 50, color: '#0ff', life: 1 }); }
                    else if (p.type === 'invincible') { player.invuln = 600; AudioSys.playSE('invincible'); }
                    else if (p.type === 'level') { player.weaponLevel = Math.min(5, player.weaponLevel + 1); ui.wLv.innerText = player.weaponLevel; }
                }
            });
            powerups = powerups.filter(p => p.life > 0);
        }

        function updateMissiles() {
            missiles.forEach(m => {
                if (!m.target || !enemies.includes(m.target)) { let min = 9999; enemies.forEach(e => { const d = Math.hypot(e.x - m.x, e.y - m.y); if (d < min) { min = d; m.target = e; } }); }
                if (m.target) { const ta = Math.atan2(m.target.y - m.y, m.target.x - m.x); m.vx += Math.cos(ta) * 0.5; m.vy += Math.sin(ta) * 0.5; }
                const s = Math.hypot(m.vx, m.vy); if (s > 0.001) { m.vx = (m.vx / s) * m.speed; m.vy = (m.vy / s) * m.speed; }
                m.x += m.vx; m.y += m.vy; m.life--;
                enemies.forEach(e => { if (Math.hypot(e.x - m.x, e.y - m.y) < 30) { e.hp -= 10; m.life = 0; } });
                particles.push({ x: m.x, y: m.y, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), color: '#fd0', life: 0.3 });
            });
            missiles = missiles.filter(m => m.life > 0);
        }

        function updateParticlesAndRings() {
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.vy += 0.005; p.life -= 0.02; });
            particles = particles.filter(p => p.life > 0);
            rings.forEach(r => { r.r += 2; r.life -= 0.02; });
            rings = rings.filter(r => r.life > 0);
        }

        function updatePlayerStatus() { if (player.invuln > 0) player.invuln--; }
        function updateScorePopups() { scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; }); scorePopups = scorePopups.filter(s => s.life > 0); }

        function destroyEnemy(e) {
            createExplosion(e.x, e.y, e.color, 40);
            if (e.type === 'dragon') { rings.push({ x: e.x, y: e.y, r: 10, color: '#f00', life: 1 }); rings.push({ x: e.x, y: e.y, r: 5, color: '#fff', life: 1 }); AudioSys.playSE('dragon_explode'); }
            else { AudioSys.playSE('explode'); }
            killCount++; const pts = e.type === 'dragon' ? 1000 : 100;
            score += pts; ui.score.innerText = score.toString().padStart(6, '0');
            scorePopups.push({ x: e.x, y: e.y, text: pts, life: 40, alpha: 1, vy: -1 });
            distortGrid(e.x, e.y, 40, 80);
            if (e.noDrop || e.drop === 'none') return;
            if (e.drop === 'laser') powerups.push({ x: e.x, y: e.y, type: 'laser', life: ITEM_LIFE });
            else if (e.drop === 'invincible') powerups.push({ x: e.x, y: e.y, type: 'invincible', life: ITEM_LIFE });
            else if (e.drop === 'level' || Math.random() < 0.05) powerups.push({ x: e.x, y: e.y, type: 'level', life: ITEM_LIFE });
            else crystals.push({ x: e.x, y: e.y, life: ITEM_LIFE });
        }

        function damage(v) {
            player.shield -= v; player.invuln = 5;
            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            AudioSys.playSE('damage'); distortGrid(player.x, player.y, 50, 100);

            if (player.shield <= 0) {
                gameState = 'DYING';
                dyingTimer = 120;
                createExplosion(player.x, player.y, '#0f8', 100);
                AudioSys.playSE('dragon_explode');
                distortGrid(player.x, player.y, 100, 200);
            }
        }

        // --- Draw ---
        function draw() {
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const sx = (s.x - camera.x * s.parallax) % worldSize; const sy = (s.y - camera.y * s.parallax) % worldSize;
                const dx = (sx + worldSize) % worldSize; const dy = (sy + worldSize) % worldSize;
                ctx.globalAlpha = s.brightness; ctx.beginPath(); ctx.arc(dx, dy, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            ctx.save(); ctx.beginPath(); ctx.rect(0, 0, worldSize, worldSize); ctx.clip();
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)'; ctx.lineWidth = 1; ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.beginPath();
            const viewX = camera.x; const viewY = camera.y; const viewW = width; const viewH = height;
            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j]; if (!p) continue;
                if (p.x < viewX - 50 || p.x > viewX + viewW + 50 || p.y < viewY - 50 || p.y > viewY + viewH + 50) continue;
                if (i > 0 && gridPoints[i - 1] && gridPoints[i - 1][j]) { ctx.moveTo(gridPoints[i - 1][j].x, gridPoints[i - 1][j].y); ctx.lineTo(p.x, p.y); }
                if (j > 0 && gridPoints[i][j - 1]) { ctx.moveTo(gridPoints[i][j - 1].x, gridPoints[i][j - 1].y); ctx.lineTo(p.x, p.y); }
            }
            ctx.stroke(); ctx.shadowBlur = 0; ctx.restore();

            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, worldSize - WALL_MARGIN * 2, worldSize - WALL_MARGIN * 2);

            wormholes.forEach(w => {
                if (w.active || w.life > -60) {
                    let scale = 1; if (w.life > 300) scale = (400 - w.life) / 100; else if (w.life <= 0) scale = Math.max(0, (60 + w.life) / 60);
                    ctx.save(); ctx.translate(w.x, w.y); ctx.scale(scale, scale);
                    ctx.shadowBlur = 30; ctx.shadowColor = '#20f';
                    const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.2, '#000'); grad.addColorStop(0.8, '#000'); grad.addColorStop(1, '#0ff');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 20 + Math.sin(frame * 0.1) * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, 35 + Math.cos(frame * 0.05) * 5, 0, Math.PI * 2); ctx.stroke();
                    ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(5, 5); ctx.stroke();
                    ctx.restore();
                }
            });

            enemies.forEach(e => {
                if (e.type === 'dragon') drawDragonEnemy(ctx, e); else if (e.type === 'triangle') drawTriangleEnemy(ctx, e); else if (e.type === 'cube') drawCubeEnemy(ctx, e); else if (e.type === 'tadpole') drawTadpoleEnemy(ctx, e);
            });

            enemyBullets.forEach(eb => {
                ctx.save(); ctx.translate(eb.x, eb.y); ctx.rotate(frame * 0.15);
                const bulletColor = (Math.floor(frame / 5) % 2 === 0) ? '#ff0000' : '#ff8800';
                ctx.fillStyle = bulletColor; ctx.shadowBlur = 8; ctx.shadowColor = bulletColor;
                const size = 6 * G_SCALE;
                ctx.beginPath(); ctx.moveTo(0, -size); ctx.lineTo(size * 0.7, 0); ctx.lineTo(0, size); ctx.lineTo(-size * 0.7, 0); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#fdd'; ctx.beginPath(); ctx.moveTo(0, -size * 0.4); ctx.lineTo(size * 0.3, 0); ctx.lineTo(0, size * 0.4); ctx.lineTo(-size * 0.3, 0); ctx.closePath(); ctx.fill();
                ctx.restore();
            });
            ctx.shadowBlur = 0;

            // Player Draw (Only if playing)
            if (gameState === 'PLAYING') {
                ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.scale(G_SCALE, G_SCALE);
                let shipColor = '#0f8'; if (player.invuln > 0) shipColor = '#ff0'; else if (player.laserTimer > 0) shipColor = '#0ff';
                ctx.strokeStyle = shipColor; ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
                ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath(); ctx.moveTo(-5, 0); ctx.lineTo(-15, 15); ctx.moveTo(-5, 0); ctx.lineTo(-15, -15); ctx.stroke();
                ctx.restore(); ctx.shadowBlur = 0;
                player.satellites.forEach(s => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill(); });
            }

            drawLasers();
            ctx.fillStyle = '#0f8'; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); ctx.fill(); });

            ctx.fillStyle = '#0f0';
            crystals.forEach(c => {
                ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(frame * 0.1);
                const scale = c.life > 60 ? 1 : c.life / 60; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill(); ctx.restore();
            });

            powerups.forEach(p => {
                if (p.type === 'laser') ctx.strokeStyle = '#0ff'; else if (p.type === 'level') ctx.strokeStyle = '#0f0'; else ctx.strokeStyle = '#fd0';
                ctx.save(); ctx.translate(p.x, p.y);
                const scale = p.life > 60 ? 1 : p.life / 60; ctx.scale(scale, scale);
                ctx.lineWidth = 2; ctx.strokeRect(-8, -8, 16, 16);
                ctx.fillStyle = ctx.strokeStyle; ctx.font = 'bold 12px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                let char = 'S'; if (p.type === 'level') char = 'L'; else if (p.type === 'laser') char = 'B';
                ctx.fillText(char, 0, 0); ctx.restore();
            });

            ctx.fillStyle = '#fd0'; missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });

            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = Math.min(1, p.life);
                ctx.beginPath(); const length = 4.0; ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * length, p.y - p.vy * length);
                ctx.lineWidth = p.size || 2; ctx.strokeStyle = p.color; ctx.lineCap = 'round'; ctx.stroke();
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;

            rings.forEach(r => { ctx.strokeStyle = r.color; ctx.lineWidth = 3; ctx.globalAlpha = r.life; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1.0; });
            drawScorePopups(); ctx.restore();
        }

        function drawLasers() {
            lasers.forEach(l => {
                ctx.save(); ctx.translate(l.x, l.y); ctx.rotate(l.angle);
                ctx.globalCompositeOperation = 'lighter'; ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1.5;
                const len = 2000; const segments = 20; const segLen = len / segments; const jitter = 15 * (l.life / 5);
                ctx.beginPath(); ctx.moveTo(0, 0); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = (Math.random() - 0.5) * jitter * 2; ctx.lineTo(px, py); } ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -l.width / 4); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = -l.width / 4 + (Math.random() - 0.5) * (jitter / 2); ctx.lineTo(px, py); } ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, l.width / 4); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = l.width / 4 + (Math.random() - 0.5) * (jitter / 2); ctx.lineTo(px, py); } ctx.stroke();
                if (Math.random() > 0.2) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, (Math.random() - 0.5) * 5); ctx.stroke(); }
                ctx.restore();
            });
            ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur = 0;
        }

        function drawTriangleEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = e.color; ctx.lineWidth = 2.5; ctx.shadowBlur = 25; ctx.shadowColor = e.color;
            const size = 15; const pts = [{ x: 1, y: 1, z: 1 }, { x: -1, y: -1, z: 1 }, { x: -1, y: 1, z: -1 }, { x: 1, y: -1, z: -1 }];
            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX); const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY); const cosZ = Math.cos(e.rotZ), sinZ = Math.sin(e.rotZ);
            const proj = pts.map(p => { let y1 = p.y * cosX - p.z * sinX; let z1 = p.y * sinX + p.z * cosX; let x2 = p.x * cosY + z1 * sinY; let z2 = -p.x * sinY + z1 * cosY; let x3 = x2 * cosZ - y1 * sinZ; let y3 = x2 * sinZ + y1 * cosZ; return { x: x3 * size, y: y3 * size }; });
            const lines = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]];
            ctx.beginPath(); lines.forEach(l => { ctx.moveTo(proj[l[0]].x, proj[l[0]].y); ctx.lineTo(proj[l[1]].x, proj[l[1]].y); }); ctx.stroke();
            ctx.shadowBlur = 35; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function drawCubeEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE); ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            const size = 15; const pts = [{ x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 }, { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 }, { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 }, { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }];
            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX); const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY);
            const proj = pts.map(p => { let y = p.y * cosX - p.z * sinX; let z = p.y * sinX + p.z * cosX; let x = p.x * cosY + z * sinY; return { x: x * size, y: y * size }; });
            const lines = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]];
            ctx.beginPath(); lines.forEach(l => { ctx.moveTo(proj[l[0]].x, proj[l[0]].y); ctx.lineTo(proj[l[1]].x, proj[l[1]].y); }); ctx.stroke(); ctx.restore();
        }

        function drawTadpoleEnemy(ctx, e) {
            ctx.save();
            if (e.history.length > 1) {
                ctx.beginPath(); ctx.moveTo(e.history[0].x, e.history[0].y);
                for (let i = 1; i < e.history.length; i++) ctx.lineTo(e.history[i].x, e.history[i].y);
                ctx.strokeStyle = 'rgba(200, 255, 255, 0.5)'; ctx.lineWidth = 3 * G_SCALE; ctx.lineCap = 'round'; ctx.stroke();
            }
            ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.ellipse(5, 0, 12, 9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 5; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(8, 0, 4, 0, Math.PI * 2); ctx.fill();
            ctx.restore(); ctx.shadowBlur = 0;
        }

        function drawDragonEnemy(ctx, e) {
            ctx.save(); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE); ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            e.segments.forEach((s, i) => {
                ctx.save(); ctx.translate(s.x / (e.scale * G_SCALE), s.y / (e.scale * G_SCALE)); ctx.rotate(s.angle);
                ctx.beginPath(); ctx.arc(0, 0, (12 - i * 0.5) * 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); const wingSize = (15 - i * 0.5); ctx.moveTo(0, 0); ctx.lineTo(-5, wingSize); ctx.moveTo(0, 0); ctx.lineTo(-5, -wingSize); ctx.stroke();
                ctx.restore();
            });
            ctx.save(); ctx.translate(e.x / (e.scale * G_SCALE), e.y / (e.scale * G_SCALE)); ctx.rotate(e.angle);
            ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(5, 12); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.lineTo(5, -12); ctx.closePath(); ctx.stroke();
            ctx.restore(); ctx.restore();
        }

        function drawScorePopups() {
            ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
            scorePopups.forEach(s => { ctx.globalAlpha = s.alpha; ctx.fillText(s.text, s.x, s.y); });
            ctx.globalAlpha = 1.0;
        }

        function updateGrid() {
            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j]; const dx = p.x - p.ox, dy = p.y - p.oy;
                const f = -0.05 * Math.hypot(dx, dy); const ang = Math.atan2(dy, dx);
                p.vx += Math.cos(ang) * f; p.vy += Math.sin(ang) * f; p.vx *= 0.9; p.vy *= 0.9; p.x += p.vx; p.y += p.vy;
            }
        }

        function distortGrid(x, y, force, radius) {
            const cx = Math.floor(x / GRID_SPACING), cy = Math.floor(y / GRID_SPACING), r = Math.ceil(radius / GRID_SPACING);
            for (let i = Math.max(0, cx - r); i < Math.min(gridPoints.length, cx + r); i++) for (let j = Math.max(0, cy - r); j < Math.min(gridPoints[0].length, cy + r); j++) {
                const p = gridPoints[i][j], d = Math.hypot(p.x - x, p.y - y);
                if (d < radius) { const f = force * (1 - d / radius), a = Math.atan2(p.y - y, p.x - x); p.vx += Math.cos(a) * f; p.vy += Math.sin(a) * f; }
            }
        }

        function createExplosion(x, y, baseColor, n) {
            const count = Math.floor(n * EXPLOSION_COUNT_MAG);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 8 + 2) * EXPLOSION_SPEED_MAG;
                let color; const rnd = Math.random();
                if (rnd < 0.7) color = baseColor; else if (rnd < 0.8) color = '#fff'; else if (rnd < 0.90) color = rnd < 0.77 ? '#ff8800' : '#ffff00';
                else { const colors = ['#0ff', '#f0f', '#0f0', '#ff0']; color = colors[Math.floor(Math.random() * colors.length)]; }
                particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color: color, size: (Math.random() * 2 + 1) * G_SCALE, life: 1.0 + Math.random() * 0.5 });
            }
            distortGrid(x, y, 60, 120);
        }

        // --- PAUSE Control ---
        function setPaused(paused) {
            if (paused) {
                if (gameState === 'PLAYING' || gameState === 'OST') {
                    previousGameState = gameState;
                    gameState = 'PAUSED';
                    ui.pauseOverlay.style.display = 'flex';
                    AudioSys.pauseBGM();
                }
            } else {
                if (gameState === 'PAUSED') {
                    gameState = previousGameState || 'PLAYING';
                    ui.pauseOverlay.style.display = 'none';
                    AudioSys.resumeBGM();
                }
            }
        }

        // --- Event Listeners ---
        document.addEventListener('visibilitychange', () => { if (document.hidden) setPaused(true); });
        window.addEventListener('blur', () => setPaused(true));
        ui.pauseOverlay.addEventListener('click', () => setPaused(false));
        ui.pauseOverlay.addEventListener('touchstart', (e) => { e.preventDefault(); setPaused(false); });

        function handleTouch(e) {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.move.active = false; input.aim.active = false;

            const lR = ui.stickL.getBoundingClientRect(); const rR = ui.stickR.getBoundingClientRect();
            const lC = { x: lR.left + lR.width / 2, y: lR.top + lR.height / 2 };
            const rC = { x: rR.left + rR.width / 2, y: rR.top + rR.height / 2 };

            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                const dL = Math.hypot(t.clientX - lC.x, t.clientY - lC.y);
                const dR = Math.hypot(t.clientX - rC.x, t.clientY - rC.y);

                if (dL < 100) {
                    input.move.active = true; const a = Math.atan2(t.clientY - lC.y, t.clientX - lC.x); const d = Math.min(dL, 40);
                    input.move.x = Math.cos(a) * (d / 40); input.move.y = Math.sin(a) * (d / 40);
                    ui.knobL.style.transform = `translate(${input.move.x * 40}px,${input.move.y * 40}px)`;
                } else if (dR < 100) {
                    input.aim.active = true; const a = Math.atan2(t.clientY - rC.y, t.clientX - rC.x); const d = Math.min(dR, 40);
                    input.aim.x = Math.cos(a) * (d / 40); input.aim.y = Math.sin(a) * (d / 40);
                    ui.knobR.style.transform = `translate(${input.aim.x * 40}px,${input.aim.y * 40}px)`;
                }
            }
            if (!input.move.active) { input.move.x = 0; input.move.y = 0; ui.knobL.style.transform = 'translate(0,0)'; }
            if (!input.aim.active) { input.aim.x = 0; input.aim.y = 0; ui.knobR.style.transform = 'translate(0,0)'; }
        }

        ui.launchBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            launchSatellites();
            ui.launchBtn.classList.add('active');
            setTimeout(() => ui.launchBtn.classList.remove('active'), 100);
        });
        ui.controls.addEventListener('touchstart', handleTouch, { passive: false });
        ui.controls.addEventListener('touchmove', handleTouch, { passive: false });
        ui.controls.addEventListener('touchend', handleTouch, { passive: false });

        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-ost').onclick = openOST;
        document.getElementById('btn-back').onclick = closeOST;

        window.addEventListener('keydown', e => {
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyZ', 'KeyX'].includes(e.code)) e.preventDefault();
            input.keys[e.code] = true;
            if (gameState === 'TITLE' && e.code === 'Space') startGame();
            if (gameState === 'PLAYING' && e.code === 'KeyX') launchSatellites();
        });
        window.addEventListener('keyup', e => input.keys[e.code] = false);
        window.addEventListener('resize', resize);

        let isInit = false;
        const handleInteraction = () => {
            if (isInit) return;
            isInit = true;
            AudioSys.resume();
            if (gameState === 'TITLE' && !AudioSys.currentSrc) AudioSys.playBGM('title');
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('touchstart', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };
        document.addEventListener('click', handleInteraction);
        document.addEventListener('touchstart', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        function init() { resize(); AudioSys.init(); }
        init(); loop();
    </script>
</body>
</html>
