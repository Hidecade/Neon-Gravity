<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON GRAVITY: DEBUGGED</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Layer */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        #score-display {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        .sub-text {
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }

        #gauge-box {
            width: 160px;
            text-align: right;
            pointer-events: auto;
        }

        .bar-label {
            font-size: 10px;
            color: #0ff;
            display: block;
            margin-bottom: 2px;
        }

        .bar-frame {
            width: 100%;
            height: 8px;
            border: 1px solid #0ff;
            background: rgba(0,20,40,0.8);
            margin-bottom: 5px;
        }

        #shield-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: width 0.1s;
        }

        .shield-critical {
            animation: blink 0.2s infinite;
            background: #f00 !important;
        }

        .bar-label.enemy {
            color: #f00;
        }

        .bar-frame.enemy {
            border-color: #f00;
            background: rgba(40,0,0,0.8);
        }

        #enemy-bar {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.5s;
        }

        #warning-msg {
            display: none;
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #f00;
            font-size: 24px;
            animation: blink 0.2s infinite;
        }

        #stage-msg {
            display: none;
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 40px;
            text-shadow: 0 0 20px #0ff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .menu-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 20px 50px;
            margin: 15px;
            font-size: 22px;
            font-family: 'Orbitron';
            cursor: pointer;
            min-width: 240px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

            .menu-btn:active {
                background: #0ff;
                color: #000;
                transform: scale(0.95);
            }

        #ost-ui {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 110;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .track-item {
            padding: 20px;
            width: 80%;
            border-bottom: 1px solid #333;
            color: #888;
            text-align: center;
            font-size: 18px;
        }

            .track-item.playing {
                color: #0ff;
                border-color: #0ff;
            }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            touch-action: none;
            pointer-events: auto;
        }

        .joystick-area {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255,255,255,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            position: absolute;
            transform: translate(0, 0);
            transition: transform 0.05s;
        }

        #launch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.15);
            border: 2px solid #ff0;
            color: #ff0;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            box-shadow: 0 0 10px #ff0;
            pointer-events: auto;
        }

            #launch-btn:active {
                background: #ff0;
                color: #000;
                transform: scale(0.9);
            }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>

    <div id="ui">
        <div class="hud-row">
            <div id="info-box">
                <div id="score-display">000000</div>
                <div class="sub-text">STAGE: <span id="stage-num">1</span></div>
                <div class="sub-text">WEAPON: <span id="w-lv">1</span></div>
            </div>
            <div id="gauge-box">
                <span class="bar-label">SHIELD</span>
                <div class="bar-frame"><div id="shield-bar"></div></div>
                <span class="bar-label enemy">ENEMY SWARM</span>
                <div class="bar-frame enemy"><div id="enemy-bar"></div></div>
            </div>
        </div>
        <div id="warning-msg">GRAVITY CRITICAL</div>
        <div id="stage-msg">STAGE CLEAR</div>
    </div>

    <div id="overlay">
        <h1 style="color:#0ff; font-size:40px; margin-bottom:40px; text-shadow:0 0 20px #0ff; text-align:center;">NEON GRAVITY<br><span style="font-size:20px;color:#fff;">DEBUGGED</span></h1>
        <div class="menu-btn" id="btn-start">START GAME</div>
        <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
        <div style="font-size:12px;color:#888;margin-top:20px;">PC: [Z] Bomb<br>MOBILE: Small Button to Bomb</div>
    </div>

    <div id="ost-ui">
        <h2 style="color:#0ff;">SOUNDTRACK</h2>
        <div id="track-list" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
        <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
    </div>

    <div id="controls">
        <div id="stick-left" class="joystick-area"><div class="knob" id="knob-left"></div></div>
        <div id="stick-right" class="joystick-area"><div class="knob" id="knob-right"></div></div>
        <div id="launch-btn">BOMB</div>
    </div>

    <canvas id="game"></canvas>

    <script>
        // --- Settings ---
        const G_SCALE = 0.7;
        const SPEED_SCALE = 0.25;
        const WALL_MARGIN = 5;
        const MAX_WEAPON_LEVEL = 5;
        const GRID_SPACING = 30;

        // --- 敵機の最高速度設定 (この数値をいじるだけでOK) ---
        const ENEMY_SPEEDS = {
            TRIANGLE: 2.8, // 紫：フォーメーションを組む主力
            CUBE: 1.5, // 緑：アイテム持ち。少し遅め
            TADPOLE: 2.2, // 白：精子型。頭が大きい
            DRAGON: 3.5  // 赤：ボス。加速度移動の上限値
        };

        // 武器・弾の設定 (定数化)
        const BULLET_SETTINGS = {
            PLAYER_SPEED: 24.0,  // 自機の弾速
            PLAYER_LIFE: 120,   // 自機の弾の射程(フレーム数)
            ENEMY_SPEED: 4.0,   // 敵の弾速
            ENEMY_LIFE: 200    // 敵の弾の射程(フレーム数)
        };

        // --- DOM References ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const ui = {
            overlay: document.getElementById('overlay'), ost: document.getElementById('ost-ui'),
            controls: document.getElementById('controls'), score: document.getElementById('score-display'),
            stage: document.getElementById('stage-num'), wLv: document.getElementById('w-lv'),
            shieldBar: document.getElementById('shield-bar'), enemyBar: document.getElementById('enemy-bar'),
            msg: document.getElementById('stage-msg'), warn: document.getElementById('warning-msg'),
            launchBtn: document.getElementById('launch-btn'),
            knobL: document.getElementById('knob-left'), knobR: document.getElementById('knob-right'),
            stickL: document.getElementById('stick-left'), stickR: document.getElementById('stick-right')
           
        };

        // --- Game State ---
        let width, height;
        let worldSize = 0;
        let camera = { x: 0, y: 0 };

        let gameState = 'TITLE';
        let score = 0, frame = 0, stage = 1;
        let spawnedCount = 0, enemiesToSpawn = 0, isStageClear = false;
        let killCount = 0;

        const player = { x: 0, y: 0, vx: 0, vy: 0, angle: 0, satellites: [], shield: 100, weaponLevel: 1, invuln: 0 };
        const input = { move: { x: 0, y: 0, active: false }, aim: { x: 0, y: 0, active: false }, keys: {} };

        let bullets = [], enemies = [], enemyBullets = [], particles = [], crystals = [], missiles = [], powerups = [], wormholes = [], scorePopups = [], gridPoints = [], rings = [], stars = [];

        // --- Audio ---
        const BGM_FILES = {
            title: 'audio/Neo_Gravity_Title.mp3', clear: 'audio/Neo_Gravity_Clear.mp3',
            stages: ['audio/Neo_Gravity_00.mp3', 'audio/Neo_Gravity_01.mp3', 'audio/Neo_Gravity_02.mp3', 'audio/Neo_Gravity_03.mp3']
        };

        const AudioSys = {
            ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null,
            init() {
                if (!this.ctx) {
                    try { const AC = window.AudioContext || window.webkitAudioContext; if (AC) { this.ctx = new AC(); this.createNoise(); } } catch (e) { }
                }
                if (!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
            },
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => { }); },
            createNoise() {
                if (!this.ctx) return;
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                this.noiseBuffer = buf;
            },
            playSE(type) {
                if (!this.ctx) return;
                this.resume();
                const t = this.ctx.currentTime;
                const g = this.ctx.createGain(); g.connect(this.ctx.destination);
                if (type === 'shoot') {
                    const o = this.ctx.createOscillator(); o.type = 'triangle';
                    o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g); o.start(t); o.stop(t + 0.1);
                } else if (type === 'explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        f.frequency.setValueAtTime(600, t); f.frequency.exponentialRampToValueAtTime(20, t + 0.5);
                        g.gain.setValueAtTime(0.6, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + 0.5);
                    }
                } else if (type === 'dragon_explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        f.frequency.setValueAtTime(200, t); f.frequency.linearRampToValueAtTime(10, t + 1.5);
                        g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + 1.5);
                    }
                } else if (type === 'launch') {
                    const o = this.ctx.createOscillator(); o.type = 'square';
                    o.frequency.setValueAtTime(200, t); o.frequency.linearRampToValueAtTime(600, t + 0.4);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.4);
                    o.connect(g); o.start(t); o.stop(t + 0.4);
                } else if (type === 'powerup') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1800, t + 0.2);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'damage') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(50, t + 0.2);
                    g.gain.setValueAtTime(0.4, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'invincible') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(800, t + 0.5);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.connect(g); o.start(t); o.stop(t + 0.5);
                }
            },
            playBGM(key, idx = 0) {
                if (!this.bgmEl) return;
                let src = "";
                if (key === 'title') src = BGM_FILES.title;
                else if (key === 'clear') src = BGM_FILES.clear;
                else if (key === 'stage') src = BGM_FILES.stages[idx % BGM_FILES.stages.length];
                if (this.currentSrc === src && !this.bgmEl.paused) return;
                this.bgmEl.src = src; this.bgmEl.currentTime = 0; this.bgmEl.play().catch(e => { console.warn("BGM Error:", e); });
                this.currentSrc = src;
            },
            stopBGM() { if (this.bgmEl) this.bgmEl.pause(); }
        };

        // --- Layout & Init ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            const size = Math.max(width, height) * 1.5;
            worldSize = size;

            // Controls Layout
            const isPortrait = height > width;
            if (isPortrait) {
                ui.stickL.style.left = '40px'; ui.stickL.style.bottom = '50px'; ui.stickL.style.right = 'auto';
                ui.stickR.style.right = '40px'; ui.stickR.style.bottom = '50px'; ui.stickR.style.left = 'auto';
                ui.launchBtn.style.right = '40px'; ui.launchBtn.style.bottom = '180px';
            } else {
                ui.stickL.style.left = '20px'; ui.stickL.style.bottom = '40px';
                ui.stickR.style.right = '20px'; ui.stickR.style.bottom = '40px';
                ui.launchBtn.style.right = '20px'; ui.launchBtn.style.bottom = '170px';
            }
            initGrid();
            initStars();
        }

        function initGrid() {
            const cols = Math.ceil(worldSize / GRID_SPACING) + 2;
            const rows = Math.ceil(worldSize / GRID_SPACING) + 2;
            gridPoints = [];
            for (let x = 0; x <= cols; x++) {
                gridPoints[x] = [];
                for (let y = 0; y <= rows; y++) gridPoints[x][y] = { x: x * GRID_SPACING, y: y * GRID_SPACING, ox: x * GRID_SPACING, oy: y * GRID_SPACING, vx: 0, vy: 0 };
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * worldSize, y: Math.random() * worldSize,
                    size: Math.random() * 2, brightness: Math.random(), parallax: 0.2 + Math.random() * 0.3
                });
            }
        }

        function init() {
            resize();
            AudioSys.init();
            AudioSys.playBGM('title');
            player.x = worldSize / 2; player.y = worldSize / 2;
        }

        window.addEventListener('resize', resize);

        // --- Game Logic ---
        function startGame() {
            AudioSys.init(); AudioSys.resume(); AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            ui.overlay.style.display = 'none'; ui.ost.style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('stick-left').style.display = 'flex';
            document.getElementById('stick-right').style.display = 'flex';
            document.getElementById('launch-btn').style.display = 'flex';

            score = 0; stage = 1; frame = 0;

            player.x = worldSize / 2;
            player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 2; // Start LV2
            player.satellites = []; player.invuln = 0;

            ui.score.innerText = "000000"; ui.stage.innerText = "1"; ui.wLv.innerText = "2";
            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none';

            startStage();
        }

        function startStage() {
            enemiesToSpawn = 40 + (stage * 15);
            spawnedCount = 0; isStageClear = false; killCount = 0;
            ui.msg.style.display = 'none';
            bullets = []; enemies = []; enemyBullets = []; crystals = []; missiles = []; powerups = []; wormholes = []; scorePopups = []; rings = [];
            if (stage > 1) AudioSys.playBGM('stage', stage - 1);

            const whCount = Math.max(1, Math.floor((stage + 1) / 2));
            for (let i = 0; i < whCount; i++) spawnWormhole();
        }

        function spawnWormhole() {
            wormholes.push({
                x: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                y: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                life: 400, maxLife: 400, active: true
            });
            distortGrid(wormholes[wormholes.length - 1].x, wormholes[wormholes.length - 1].y, 50, 150);
        }

        function loop() {
            requestAnimationFrame(loop);
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);
            if (gameState === 'PLAYING') update();
            draw();
        }

        function update() {
            frame++;
            if (!Number.isFinite(player.x) || !Number.isFinite(player.y)) {
                player.x = worldSize / 2; player.y = worldSize / 2; player.vx = 0; player.vy = 0;
            }

            // Controls
            let mx = input.keys['ArrowLeft'] ? -1 : input.keys['ArrowRight'] ? 1 : input.move.x;
            let my = input.keys['ArrowUp'] ? -1 : input.keys['ArrowDown'] ? 1 : input.move.y;

            const mag = Math.hypot(mx, my);
            if (mag > 1) { mx /= mag; my /= mag; }

            const moveSpeed = 7.8 * SPEED_SCALE;
            player.vx = mx * moveSpeed;
            player.vy = my * moveSpeed;
            player.x += player.vx; player.y += player.vy;

            // World Boundary Collision
            if (player.x < WALL_MARGIN) { player.x = WALL_MARGIN; player.vx = 0; }
            if (player.x > worldSize - WALL_MARGIN) { player.x = worldSize - WALL_MARGIN; player.vx = 0; }
            if (player.y < WALL_MARGIN) { player.y = WALL_MARGIN; player.vy = 0; }
            if (player.y > worldSize - WALL_MARGIN) { player.y = worldSize - WALL_MARGIN; player.vy = 0; }

            // Camera Follow
            camera.x = player.x - width / 2;
            camera.y = player.y - height / 2;

            // Aim
            if (input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
            else if (Math.hypot(mx, my) > 0.1) player.angle = Math.atan2(my, mx);

            if ((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % 10 === 0) fire();

            // Wormholes Logic
            if (spawnedCount < enemiesToSpawn && wormholes.filter(w => w.active).length < (1 + Math.floor(stage / 2)) && Math.random() < 0.02) {
                spawnWormhole();
            }

            wormholes.forEach((w) => {
                w.life--;
                if (w.active) {
                    if (w.life > 60 && w.life % 60 === 0 && spawnedCount < enemiesToSpawn) {
                        const r = Math.random();
                        if (r < 0.20) spawnEnemy(w.x, w.y, 'dragon');
                        else if (r < 0.40) spawnEnemy(w.x, w.y, 'cube');
                        else if (r < 0.60) spawnEnemy(w.x, w.y, 'tadpole');
                        else spawnEnemy(w.x, w.y, 'triangle');
                    }
                    if (w.life <= 0) w.active = false;
                    const dx = player.x - w.x; const dy = player.y - w.y;
                    const d = Math.hypot(dx, dy) || 0.01;
                    if (d < 180) {
                        const f = 500 / (d + 1);
                        player.x += (dx / d) * f * 0.01; player.y += (dy / d) * f * 0.01;
                    }
                }
            });
            wormholes = wormholes.filter(w => w.life > -60);

            // Satellites
            player.satellites.forEach((s, i) => {
                s.angle = (s.angle || 0) + 0.15;
                const rad = 45 * G_SCALE;
                const off = (Math.PI * 2 / player.satellites.length) * i;
                s.x = player.x + Math.cos(s.angle + off) * rad; s.y = player.y + Math.sin(s.angle + off) * rad;
            });

            updateEntities();
            updateGrid();
            updateScorePopups();

            const enemyRemains = (enemiesToSpawn - killCount);
            const forcePct = Math.max(0, (enemyRemains / enemiesToSpawn) * 100);
            ui.enemyBar.style.width = `${forcePct}%`;

            if (spawnedCount >= enemiesToSpawn && enemies.length === 0 && !isStageClear) {
                isStageClear = true; ui.msg.style.display = 'block';
                AudioSys.playBGM('clear');
                setTimeout(() => { stage++; ui.stage.innerText = stage; startStage(); }, 4000);
            }

            if (player.shield < 30) ui.shieldBar.classList.add('shield-critical');
            else ui.shieldBar.classList.remove('shield-critical');
        }

        function fire() {
            // 定数 PLAYER_SPEED (24.0) を使用
            const s = BULLET_SETTINGS.PLAYER_SPEED * SPEED_SCALE;

            for (let i = 0; i < player.weaponLevel; i++) {
                // ショットの広がり角の計算
                const a = player.angle + (i - (player.weaponLevel - 1) / 2) * 0.15;

                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(a) * s,
                    vy: Math.sin(a) * s,
                    // 定数 PLAYER_LIFE (120) を使用
                    life: BULLET_SETTINGS.PLAYER_LIFE
                });
            }

            AudioSys.playSE('shoot');
            distortGrid(player.x, player.y, 10, 40);
        }


        function spawnEnemy(x, y, type) {
            const spd = SPEED_SCALE;

            const burstAngle = Math.random() * Math.PI * 2;
            const burstSpeed = 5.0 * spd;
            const vx = Math.cos(burstAngle) * burstSpeed;
            const vy = Math.sin(burstAngle) * burstSpeed;

            // 30% drop level
            const dropType = Math.random() < 0.3 ? 'level' : 'crystal';

            if (type === 'dragon') {
                let e = {
                    x: x, y: y, vx: vx, vy: vy, hp: 8,
                    speed: ENEMY_SPEEDS.DRAGON * spd,
                    color: '#f00', type: 'dragon', angle: 0, segments: [], drop: 'invincible', scale: 0.9, fireTimer: 0
                };
                for (let i = 0; i < 16; i++) e.segments.push({ x: x, y: y, angle: 0 });
                enemies.push(e);
                spawnedCount++;
            } else if (type === 'cube') {
                let e = {
                    x: x, y: y, vx: vx, vy: vy, hp: 2,
                    speed: ENEMY_SPEEDS.CUBE * spd,
                    color: '#0f0', type: 'cube', angle: 0, drop: dropType, scale: 0.8, rot: 0, rotX: 0, rotY: 0
                };
                enemies.push(e);
                spawnedCount++;
            } else if (type === 'tadpole') {
                let e = {
                    x: x, y: y, vx: vx, vy: vy, hp: 1,
                    speed: ENEMY_SPEEDS.TADPOLE * spd,
                    color: '#f0f', type: 'tadpole', angle: 0, drop: 'none', scale: 0.6, history: []
                };
                enemies.push(e);
                spawnedCount++;
            } else { // Triangle
                const forms = ['V', 'line', 'circle'];
                const form = forms[Math.floor(Math.random() * forms.length)];
                const leader = {
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    hp: 1,

                    speed: ENEMY_SPEEDS.TRIANGLE * spd,

                    color: '#d0f',
                    type: 'triangle',
                    angle: 0,
                    drop: dropType,
                    scale: 0.7,
                    isLeader: true,
                    followers: []
                };
                enemies.push(leader);
                spawnedCount++;

                for (let i = 1; i <= 4; i++) {
                    if (spawnedCount >= enemiesToSpawn) break;
                    let offX = 0, offY = 0;
                    if (form === 'V') {
                        offX = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 25;
                        offY = -Math.ceil(i / 2) * 25;
                    } else if (form === 'line') {
                        offX = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 35;
                        offY = 0;
                    } else {
                        const angle = (Math.PI * 2 / 5) * i;
                        offX = Math.cos(angle) * 35; offY = Math.sin(angle) * 35;
                    }
                    let e = {
                        x: x, y: y, vx: vx, vy: vy, hp: 1, speed: ENEMY_SPEEDS.TRIANGLE * spd, color: '#d0f', type: 'triangle',
                        angle: 0, drop: 'none', scale: 0.7,
                        leader: leader, formOffset: { x: offX, y: offY }
                    };
                    enemies.push(e);
                    leader.followers.push(e);
                    spawnedCount++;
                }
            }
        }

        /**
         * 全エンティティ（弾、敵、アイテム、エフェクト）の状態更新
         */
        function updateEntities() {
            updatePlayerBullets();
            updateEnemies();
            updateEnemyBullets();
            updateCrystals();
            updatePowerups();
            updateMissiles();
            updateParticlesAndRings();
            updatePlayerStatus();
        }

        /**
         * 自機の弾の移動と敵との当たり判定
         */
        function updatePlayerBullets() {
            bullets.forEach(b => {
                b.x += b.vx; b.y += b.vy; b.life--;
                enemies.forEach(e => {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < 30 * e.scale) {
                        b.life = 0;
                        e.hp--;
                    }
                });
            });
            bullets = bullets.filter(b => b.life > 0);
        }

        /**
         * 敵全体の更新処理（種類ごとに分岐）
         */
        function updateEnemies() {
            enemies.forEach(e => {
                // 1. 移動・AIロジックの適用
                if (e.leader && e.leader.hp > 0) {
                    updateFormationMovement(e); // 編隊移動
                } else {
                    // 種類ごとの固有ロジック
                    switch (e.type) {
                        case 'dragon': updateDragonAI(e); break;
                        case 'tadpole': updateTadpoleAI(e); break;
                        case 'triangle': updateTriangleAI(e); break;
                        case 'cube': updateCubeAI(e); break;
                    }
                }

                // 2. 共通処理（衝突回避・画面端バウンス）
                applySeparation(e);
                applyWorldBoundary(e);

                // 3. プレイヤーとの接触判定
                checkPlayerCollision(e);

                // 4. サテライト（緑の破片）との接触判定
                checkSatelliteCollision(e);

                // 5. 死亡判定
                if (e.hp <= 0) destroyEnemy(e);
            });
            enemies = enemies.filter(e => e.hp > 0);
        }

        /* --- 敵の種類別 AI 関数 --- */

        function updateDragonAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            // 加速移動
            e.vx += (dx / d) * 0.08 * SPEED_SCALE;
            e.vy += (dy / d) * 0.08 * SPEED_SCALE;
            e.vx *= 0.98; e.vy *= 0.98; // 摩擦
            // 最高速制限
            const cv = Math.hypot(e.vx, e.vy);
            const lim = ENEMY_SPEEDS.DRAGON * SPEED_SCALE;
            if (cv > lim) { e.vx = (e.vx / cv) * lim; e.vy = (e.vy / cv) * lim; }

            e.x += e.vx; e.y += e.vy;
            e.angle = Math.atan2(dy, dx);

            // 節（セグメント）の追従
            let lx = e.x, ly = e.y;
            e.segments.forEach(s => {
                const dd = Math.hypot(lx - s.x, ly - s.y);
                if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; }
                lx = s.x; ly = s.y;
            });

            // 攻撃（射撃）
            e.fireTimer++;
            if (e.fireTimer > 100) {
                e.fireTimer = 0;
                // --- 定数 BULLET_SETTINGS  ---
                const bSpd = BULLET_SETTINGS.ENEMY_SPEED * SPEED_SCALE;
                enemyBullets.push({
                    x: e.x,
                    y: e.y,
                    vx: Math.cos(e.angle) * bSpd,
                    vy: Math.sin(e.angle) * bSpd,
                    life: BULLET_SETTINGS.ENEMY_LIFE
                });
                AudioSys.playSE('shoot');
            }
        }

        function updateTadpoleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            // 定速移動
            e.vx += (dx / d) * 0.2 * SPEED_SCALE;
            e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }

            e.x += e.vx; e.y += e.vy;
            e.angle = Math.atan2(dy, dx);

            // 軌跡の記録
            e.history.unshift({ x: e.x, y: e.y });
            if (e.history.length > 60) e.history.pop();
        }

        function updateTriangleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE;
            e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }

            e.x += e.vx; e.y += e.vy;
            e.angle = Math.atan2(e.vy, e.vx);
        }

        function updateCubeAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE;
            e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }

            e.x += e.vx; e.y += e.vy;
            e.rotX += 0.03; e.rotY += 0.04;
        }

        /* --- ヘルパー・共通関数 --- */

        function updateFormationMovement(e) {
            const la = e.leader.angle;
            const ox = e.formOffset.x * Math.cos(la) - e.formOffset.y * Math.sin(la);
            const oy = e.formOffset.x * Math.sin(la) + e.formOffset.y * Math.cos(la);
            e.x += (e.leader.x + ox - e.x) * 0.1;
            e.y += (e.leader.y + oy - e.y) * 0.1;
            e.angle = la;
        }

        function applySeparation(e) {
            enemies.forEach(other => {
                if (e === other) return;
                const odx = e.x - other.x, ody = e.y - other.y;
                const od = Math.hypot(odx, ody);
                if (od < 30) {
                    const push = (30 - od) * 0.05;
                    e.x += (odx / od) * push; e.y += (ody / od) * push;
                }
            });
        }

        function applyWorldBoundary(e) {
            if (e.x < WALL_MARGIN || e.x > worldSize - WALL_MARGIN) e.vx *= -1.2;
            if (e.y < WALL_MARGIN || e.y > worldSize - WALL_MARGIN) e.vy *= -1.2;
            e.x = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.x));
            e.y = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.y));
        }

        function checkPlayerCollision(e) {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < 25 && player.invuln <= 0) {
                player.shield -= 15;
                player.invuln = 60;
                if (e.type !== 'dragon') e.hp = 0; // ドラゴン以外は体当たりで消滅
            }
        }

        function checkSatelliteCollision(e) {
            for (let i = player.satellites.length - 1; i >= 0; i--) {
                const s = player.satellites[i];
                if (Math.hypot(s.x - e.x, s.y - e.y) < 25) {
                    e.hp = 0;
                    player.satellites.splice(i, 1); // サテライトを消費
                    e.noDrop = true;
                    break;
                }
            }
        }

        /* --- エフェクト・UI更新関数（元からあったもの） --- */

        /**
         * 敵の弾の移動とプレイヤーへの当たり判定
         */
        function updateEnemyBullets() {
            enemyBullets.forEach(eb => {
                // 1. 移動：速度(vx, vy)を座標に加算
                eb.x += eb.vx;
                eb.y += eb.vy;

                // 2. 寿命を減らす
                eb.life--;

                // 3. プレイヤーとの当たり判定
                // player.invuln(無敵時間)が0以下の時のみ判定
                if (Math.hypot(player.x - eb.x, player.y - eb.y) < 15 && player.invuln <= 0) {
                    damage(15);      // ダメージ関数を呼ぶ（シールドを減らす）
                    eb.life = 0;     // 弾を消滅させる
                    // プレイヤーの位置に赤い火花を出す
                    createExplosion(player.x, player.y, '#f00', 10);
                }
            });

            // 4. 寿命が尽きた弾を配列から削除
            enemyBullets = enemyBullets.filter(eb => eb.life > 0);
        }

        function updateCrystals() {
            crystals.forEach(c => {
                const dx = player.x - c.x, dy = player.y - c.y, d = Math.hypot(dx, dy) || 0.0001;
                const factor = 0.03 + (d * 0.0005);
                c.x += dx * factor; c.y += dy * factor;
                if (d < 20) { c.life = 0; if (player.satellites.length < 12) player.satellites.push({}); }
            });
            crystals = crystals.filter(c => c.life > 0);
        }

        function updatePowerups() {
            powerups.forEach(p => {
                if (Math.hypot(player.x - p.x, player.y - p.y) < 30) {
                    p.life = 0;
                    player.weaponLevel = Math.min(5, player.weaponLevel + 1);
                    ui.wLv.innerText = player.weaponLevel;
                }
            });
            powerups = powerups.filter(p => p.life > 0);
        }

        function updateMissiles() {
            missiles.forEach(m => {
                if (!m.target || !enemies.includes(m.target)) {
                    let min = 9999;
                    enemies.forEach(e => { const d = Math.hypot(e.x - m.x, e.y - m.y); if (d < min) { min = d; m.target = e; } });
                }
                if (m.target) {
                    const ta = Math.atan2(m.target.y - m.y, m.target.x - m.x);
                    m.vx += Math.cos(ta) * 0.5; m.vy += Math.sin(ta) * 0.5;
                }
                const s = Math.hypot(m.vx, m.vy);
                if (s > 0.001) { m.vx = (m.vx / s) * m.speed; m.vy = (m.vy / s) * m.speed; }
                m.x += m.vx; m.y += m.vy; m.life--;
                enemies.forEach(e => { if (Math.hypot(e.x - m.x, e.y - m.y) < 30) { e.hp -= 10; m.life = 0; } });
                particles.push({ x: m.x, y: m.y, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), color: '#fd0', life: 0.3 });
            });
            missiles = missiles.filter(m => m.life > 0);
        }

        function updateParticlesAndRings() {
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.92; p.vy *= 0.92; p.vy += 0.005;
                p.life -= 0.02;
            });
            particles = particles.filter(p => p.life > 0);

            rings.forEach(r => { r.r += 2; r.life -= 0.02; });
            rings = rings.filter(r => r.life > 0);
        }

        function updatePlayerStatus() {
            if (player.invuln > 0) player.invuln--;
        }


        /** 
         * 
         */

        function updateScorePopups() {
            scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; });
            scorePopups = scorePopups.filter(s => s.life > 0);
        }

        function destroyEnemy(e) {
            createExplosion(e.x, e.y, e.color, 40);
            if (e.type === 'dragon') {
                rings.push({ x: e.x, y: e.y, r: 10, color: '#f00', life: 1 });
                rings.push({ x: e.x, y: e.y, r: 5, color: '#fff', life: 1 });
                AudioSys.playSE('dragon_explode');
            } else {
                AudioSys.playSE('explode');
            }

            killCount++;
            const pts = e.type === 'dragon' ? 1000 : 100;
            score += pts; ui.score.innerText = score.toString().padStart(6, '0');
            scorePopups.push({ x: e.x, y: e.y, text: pts, life: 40, alpha: 1, vy: -1 });
            distortGrid(e.x, e.y, 40, 80);
            if (e.noDrop || e.drop === 'none') return;
            if (e.drop === 'invincible') powerups.push({ x: e.x, y: e.y, type: 'invincible', life: 1000 });
            else if (e.drop === 'level' || Math.random() < 0.05) powerups.push({ x: e.x, y: e.y, type: 'level', life: 1000 });
            else crystals.push({ x: e.x, y: e.y, life: 1000 });
        }

        function damage(v) {
            player.shield -= v; player.invuln = 60;
            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            AudioSys.playSE('damage'); distortGrid(player.x, player.y, 50, 100);
            if (player.shield <= 0) {
                gameState = 'GAMEOVER'; ui.overlay.style.display = 'flex';
                ui.overlay.innerHTML = `<h1>GAME OVER</h1><p>SCORE: ${score}</p><div class="menu-btn" onclick="location.reload()">RETRY</div>`;
                ui.controls.style.display = 'none';
                AudioSys.stopBGM();
            }
        }

        function draw() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Stars
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const sx = (s.x - camera.x * s.parallax) % worldSize;
                const sy = (s.y - camera.y * s.parallax) % worldSize;
                const dx = (sx + worldSize) % worldSize;
                const dy = (sy + worldSize) % worldSize;
                ctx.globalAlpha = s.brightness;
                ctx.beginPath(); ctx.arc(dx, dy, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Grid inside Boundary
            ctx.save();
            ctx.beginPath(); ctx.rect(0, 0, worldSize, worldSize); ctx.clip();

            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)'; ctx.lineWidth = 1.5; ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.beginPath();
            const viewX = camera.x; const viewY = camera.y;
            const viewW = width; const viewH = height;

            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j];
                if (!p) continue;
                if (p.x < viewX - 50 || p.x > viewX + viewW + 50 || p.y < viewY - 50 || p.y > viewY + viewH + 50) continue;
                if (i > 0 && gridPoints[i - 1] && gridPoints[i - 1][j]) { ctx.moveTo(gridPoints[i - 1][j].x, gridPoints[i - 1][j].y); ctx.lineTo(p.x, p.y); }
                if (j > 0 && gridPoints[i][j - 1]) { ctx.moveTo(gridPoints[i][j - 1].x, gridPoints[i][j - 1].y); ctx.lineTo(p.x, p.y); }
            }
            ctx.stroke(); ctx.shadowBlur = 0;
            ctx.restore();

            // Boundary Frame
            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, worldSize - WALL_MARGIN * 2, worldSize - WALL_MARGIN * 2);

            wormholes.forEach(w => {
                if (w.active || w.life > -60) {
                    let scale = 1;
                    if (w.life > 300) scale = (400 - w.life) / 100;
                    else if (w.life <= 0) scale = Math.max(0, (60 + w.life) / 60);

                    ctx.save(); ctx.translate(w.x, w.y); ctx.scale(scale, scale);
                    ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 15 + Math.sin(frame * 0.2) * 5, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.beginPath(); ctx.arc(0, 0, 30 + Math.sin(frame * 0.1) * 10, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }
            });

            enemies.forEach(e => {
                if (e.type === 'dragon') drawDragonEnemy(ctx, e);
                else if (e.type === 'triangle') drawTriangleEnemy(ctx, e);
                else if (e.type === 'cube') drawCubeEnemy(ctx, e);
                else if (e.type === 'tadpole') drawTadpoleEnemy(ctx, e);
            });

            ctx.fillStyle = '#aaf'; enemyBullets.forEach(eb => { ctx.beginPath(); ctx.arc(eb.x, eb.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });

            if (gameState === 'PLAYING') {
                ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.scale(G_SCALE, G_SCALE);
                ctx.strokeStyle = player.invuln > 0 ? '#ff0' : '#0f8'; ctx.lineWidth = 2;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
                ctx.beginPath();
                ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath();
                ctx.moveTo(-5, 0); ctx.lineTo(-15, 15); ctx.moveTo(-5, 0); ctx.lineTo(-15, -15);
                ctx.stroke();
                ctx.restore(); ctx.shadowBlur = 0;

                player.satellites.forEach(s => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill(); });
            }

            ctx.fillStyle = '#0f8'; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); ctx.fill(); });
            ctx.fillStyle = '#0f0'; crystals.forEach(c => {
                ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(frame * 0.1);
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill(); ctx.restore();
            });
            powerups.forEach(p => {
                ctx.strokeStyle = p.type === 'level' ? '#0f0' : '#fd0'; ctx.lineWidth = 2;
                ctx.strokeRect(p.x - 8, p.y - 8, 16, 16);
                ctx.fillStyle = ctx.strokeStyle; ctx.font = 'bold 12px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(p.type === 'level' ? 'L' : 'S', p.x, p.y);
            });
            ctx.fillStyle = '#fd0'; missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, 2 * G_SCALE, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; });

            rings.forEach(r => {
                ctx.strokeStyle = r.color; ctx.lineWidth = 3; ctx.globalAlpha = r.life;
                ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2); ctx.stroke();
                ctx.globalAlpha = 1.0;
            });

            drawScorePopups();
            ctx.restore();
        }

        function drawTriangleEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            ctx.shadowBlur = 10; ctx.shadowColor = e.color;
            ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.closePath();
            ctx.stroke(); ctx.shadowBlur = 0; ctx.restore();
        }

        function drawCubeEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            // 3D Cube Projection
            const size = 15;
            const pts = [
                { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 }, { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
                { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 }, { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
            ];
            // Rotate
            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX);
            const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY);

            const proj = pts.map(p => {
                let y = p.y * cosX - p.z * sinX; let z = p.y * sinX + p.z * cosX;
                let x = p.x * cosY + z * sinY;
                return { x: x * size, y: y * size };
            });

            // Draw Edges
            const lines = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]];
            ctx.beginPath();
            lines.forEach(l => { ctx.moveTo(proj[l[0]].x, proj[l[0]].y); ctx.lineTo(proj[l[1]].x, proj[l[1]].y); });
            ctx.stroke();
            ctx.restore();
        }

        function drawTadpoleEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.strokeStyle = e.color; ctx.lineWidth = 2;

            // Draw Larger Head
            ctx.beginPath();
            ctx.ellipse(8, 0, 15, 10, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();

            // Draw Trail (World Coords)
            if (e.history.length > 1) {
                ctx.save(); ctx.strokeStyle = e.color; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                for (let i = 0; i < e.history.length; i++) {
                    ctx.lineTo(e.history[i].x, e.history[i].y);
                }
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawDragonEnemy(ctx, e) {
            ctx.save(); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE); ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            e.segments.forEach((s, i) => {
                ctx.save(); ctx.translate(s.x / (e.scale * G_SCALE), s.y / (e.scale * G_SCALE)); ctx.rotate(s.angle);
                ctx.beginPath(); ctx.arc(0, 0, (12 - i * 0.5) * 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); const wingSize = (15 - i * 0.5); ctx.moveTo(0, 0); ctx.lineTo(-5, wingSize); ctx.moveTo(0, 0); ctx.lineTo(-5, -wingSize); ctx.stroke();
                ctx.restore();
            });
            // Head (No Eyes)
            ctx.save(); ctx.translate(e.x / (e.scale * G_SCALE), e.y / (e.scale * G_SCALE)); ctx.rotate(e.angle);
            ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(5, 12); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.lineTo(5, -12); ctx.closePath(); ctx.stroke();
            ctx.restore(); ctx.restore();
        }

        function drawScorePopups() {
            ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
            scorePopups.forEach(s => {
                ctx.globalAlpha = s.alpha;
                ctx.fillText(s.text, s.x, s.y);
            });
            ctx.globalAlpha = 1.0;
        }

        function updateGrid() {
            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j];
                const dx = p.x - p.ox, dy = p.y - p.oy;
                const f = -0.05 * Math.hypot(dx, dy); const ang = Math.atan2(dy, dx);
                p.vx += Math.cos(ang) * f; p.vy += Math.sin(ang) * f; p.vx *= 0.9; p.vy *= 0.9;
                p.x += p.vx; p.y += p.vy;
            }
        }

        function distortGrid(x, y, force, radius) {
            const cx = Math.floor(x / GRID_SPACING), cy = Math.floor(y / GRID_SPACING), r = Math.ceil(radius / GRID_SPACING);
            for (let i = Math.max(0, cx - r); i < Math.min(gridPoints.length, cx + r); i++) for (let j = Math.max(0, cy - r); j < Math.min(gridPoints[0].length, cy + r); j++) {
                const p = gridPoints[i][j], d = Math.hypot(p.x - x, p.y - y);
                if (d < radius) { const f = force * (1 - d / radius), a = Math.atan2(p.y - y, p.x - x); p.vx += Math.cos(a) * f; p.vy += Math.sin(a) * f; }
            }
        }
        
        function createExplosion(x, y, c, n) {
            for (let i = 0; i < n; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: c, life: 1.0
                });
            }
        }

        function launchSatellites() {
            if (player.satellites.length === 0) return;
            AudioSys.playSE('launch');
            player.satellites.forEach(s => {
                missiles.push({ x: s.x, y: s.y, vx: Math.cos(s.angle) * 10 * SPEED_SCALE, vy: Math.sin(s.angle) * 10 * SPEED_SCALE, target: null, life: 200, speed: 12 * SPEED_SCALE });
            });
            player.satellites = [];
            distortGrid(player.x, player.y, 300, 400);
        }

        // OST & Menu
        function openOST() {
            AudioSys.resume(); gameState = 'OST';
            ui.overlay.style.display = 'none'; ui.ost.style.display = 'flex';
            const list = document.getElementById('track-list'); list.innerHTML = '';
            [{ n: 'Title Theme', k: 'title' }, { n: 'Stage 1', k: 'stage', i: 0 }, { n: 'Stage 2', k: 'stage', i: 1 }, { n: 'Stage 3', k: 'stage', i: 2 }, { n: 'Stage 4', k: 'stage', i: 3 }, { n: 'Clear Theme', k: 'clear' }].forEach(t => {
                const d = document.createElement('div'); d.className = 'track-item'; d.innerText = t.n;
                d.onclick = () => { AudioSys.playBGM(t.k, t.i); document.querySelectorAll('.track-item').forEach(e => e.classList.remove('playing')); d.classList.add('playing'); };
                list.appendChild(d);
            });
        }

        function closeOST() { gameState = 'TITLE'; ui.ost.style.display = 'none'; ui.overlay.style.display = 'flex'; AudioSys.playBGM('title'); }

        // Inputs
        function handleTouch(e) {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.move.active = false; input.aim.active = false;

            // Bomb Button Check (Coordinate)
            const bRect = ui.launchBtn.getBoundingClientRect();

            const lR = ui.stickL.getBoundingClientRect(), rR = ui.stickR.getBoundingClientRect();
            const lC = { x: lR.left + lR.width / 2, y: lR.top + lR.height / 2 }, rC = { x: rR.left + rR.width / 2, y: rR.top + rR.height / 2 };

            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];

                if (t.clientX >= bRect.left && t.clientX <= bRect.right && t.clientY >= bRect.top && t.clientY <= bRect.bottom) {
                    launchSatellites();
                    continue;
                }

                const dL = Math.hypot(t.clientX - lC.x, t.clientY - lC.y), dR = Math.hypot(t.clientX - rC.x, t.clientY - rC.y);

                if (dL < 100) {
                    input.move.active = true; const a = Math.atan2(t.clientY - lC.y, t.clientX - lC.x), d = Math.min(dL, 40);
                    input.move.x = Math.cos(a) * (d / 40); input.move.y = Math.sin(a) * (d / 40);
                    ui.knobL.style.transform = `translate(${input.move.x * 40}px,${input.move.y * 40}px)`;
                } else if (dR < 100) {
                    input.aim.active = true; const a = Math.atan2(t.clientY - rC.y, t.clientX - rC.x), d = Math.min(dR, 40);
                    input.aim.x = Math.cos(a) * (d / 40); input.aim.y = Math.sin(a) * (d / 40);
                    ui.knobR.style.transform = `translate(${input.aim.x * 40}px,${input.aim.y * 40}px)`;
                }
            }
            if (!input.move.active) { input.move.x = 0; input.move.y = 0; ui.knobL.style.transform = 'translate(0,0)'; }
            if (!input.aim.active) { input.aim.x = 0; input.aim.y = 0; ui.knobR.style.transform = 'translate(0,0)'; }
        }

        ui.launchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); launchSatellites(); ui.launchBtn.classList.add('active'); setTimeout(() => ui.launchBtn.classList.remove('active'), 100); });
        ui.controls.addEventListener('touchstart', handleTouch, { passive: false });
        ui.controls.addEventListener('touchmove', handleTouch, { passive: false });
        ui.controls.addEventListener('touchend', handleTouch, { passive: false });

        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-ost').onclick = openOST;
        document.getElementById('btn-back').onclick = closeOST;

        window.addEventListener('keydown', e => {
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
            input.keys[e.code] = true;
            if (gameState === 'TITLE' && e.code === 'Space') startGame();
            if (gameState === 'PLAYING' && e.code === 'KeyZ') launchSatellites();
        });
        window.addEventListener('keyup', e => input.keys[e.code] = false);

        document.body.addEventListener('click', () => { AudioSys.resume(); if (gameState === 'TITLE' && !AudioSys.currentSrc) AudioSys.playBGM('title'); }, { once: true });

        function init() {
            resize();
            AudioSys.init();
            AudioSys.playBGM('title');
        }

        init();
        loop();
    </script>
</body>
</html>
