
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>NEON GRAVITY</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        /* =========================================================
            1. グローバル基本設定
            ========================================================= */
        body {
            margin: 0; /* 余白を完全に除去 */
            background: #050505; /* ネオン表現に最適な暗い背景 */
            overflow: hidden; /* スクロールバーを非表示 */
            font-family: 'Orbitron', monospace; /* 近未来風フォント */
            color: #fff; /* 文字色の基本は白 */

            user-select: none; /* テキスト選択を禁止 */
            -webkit-user-select: none; /* iOS Safari向け */
            touch-action: none; /* スマホの標準ジェスチャ無効化 */
            -webkit-tap-highlight-color: transparent; /* タップ時の青枠を消す */
        }

        /* =========================================================
                2. キャンバスとメインUIコンテナ
                ========================================================= */
        canvas {
            display: block; /* 余計な隙間を防ぐ */
            position: absolute; /* 画面全体に固定 */
            top: 0;
            left: 0;
            z-index: 1; /* UIより背面に配置 */
        }

        #ui {
            position: absolute; /* ゲーム画面に重ねる */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 操作を下の要素へ通す */
            z-index: 20; /* キャンバスより前面 */

            display: flex;
            flex-direction: column; /* 縦方向に要素配置 */
            padding: 10px; /* 画面端からの余白 */
            box-sizing: border-box; /* パディング込みサイズ */
        }


        /* =========================================================
                3. HUDレイアウト（スコア・ステージ・武器）
                ========================================================= */
        .hud-row {
            display: flex; /* 左右に要素を配置 */
            justify-content: space-between; /* 両端に寄せる */
            width: 100%;
            max-width: 800px; /* 大画面での最大幅 */
            margin: 0 auto; /* 中央寄せ */
        }

        #score-display {
            font-size: 24px; /* 大きめに表示 */
            color: #0ff; /* ネオン水色 */
            text-shadow: 0 0 10px #0ff; /* 発光エフェクト */
            letter-spacing: 0px; /* 数字の間隔 */
            margin-bottom: 5px;
        }

        .sub-text {
            font-size: 12px; /* 補助ラベル用の小文字 */
            color: #aaa; /* 控えめな灰色 */
            font-weight: bold;
        }

        .hud-label {
            font-size: 10px; /* ゲージ等の見出し */
            color: #aaa;
            display: block;
            margin-bottom: -2px;
        }

        #stage-num {
            font-size: 28px; /* ステージ番号を強調 */
            color: #fff;
            font-weight: bold;
            line-height: 1.0;
            text-shadow: 0 0 10px rgba(255,255,255,0.5); /* 白の発光 */
        }

        /* =========================================================
        4. ゲージ・バーコンポーネント (整理済み)
        ========================================================= */

        /* 左右のゲージコンテナ共通設定 */
        #gauge-box, #info-box > div {
            pointer-events: auto;
        }

        #gauge-box {
            width: 120px; /* スリムな幅に統一 */
            text-align: right;
        }

        /* 共通ラベル設定 */
        .bar-label {
            font-size: 10px;
            letter-spacing: 1px;
            margin-bottom: 2px;
            display: block;
            color: #0ff; /* 基本は水色 */
        }

            /* 敵・ボス用のラベル色 */
            .bar-label.enemy, #boss-name-label {
                color: #f44;
            }

        /* 共通ゲージ枠：すべての枠（左WEAPON/右SHIELD等）に適用 */
        .bar-frame, .laser-bar-frame {
            width: 100%;
            height: 8px;
            border: 1.5px solid rgba(0, 255, 255, 0.5); /* 1.5pxに統一 */
            background: rgba(0, 20, 40, 0.8);
            margin-bottom: 6px;
            overflow: hidden;
            box-sizing: border-box; /* 枠線の太さを内側に含める */
        }

        /* 左側WEAPON用の特殊幅調整（もし必要なら） */
        .laser-bar-frame {
            width: 80px;
        }

        /* 敵・ボス用の枠色上書き */
        .bar-frame.enemy, .bar-frame.boss {
            border-color: rgba(255, 68, 68, 0.5);
        }

        /* ボス用の特殊枠色（さらに強調する場合） */
        .bar-frame.boss {
            border-color: #f00;
        }

        /* --- バー本体（中身）の共通・個別設定 --- */

        /* シールドバー */
        #shield-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: width 0.1s;
            box-shadow: 0 0 10px #0ff;
        }

        /* 危険時のシールド点滅 */
        .shield-critical {
            animation: blink 0.2s infinite;
            background: #f00 !important;
        }

        /* 敵カウントバー */
        #enemy-bar {
            width: 100%;
            height: 100%;
            background: #f44;
            transition: width 0.5s;
        }

        /* ボスHPバー */
        #boss-hp-bar-inline {
            width: 100%;
            height: 100%;
            background: #f00;
            box-shadow: 0 0 10px #f00;
            transition: width 0.2s, background-color 0.3s;
        }

        /* レーザー持続時間バー */
        .laser-bar-fill {
            height: 100%;
            background: #0ff;
            box-shadow: 0 0 8px #0ff;
        }

        /* 武器レベル表示用ブロック（ショットモード時） */
        .w-block {
            width: 12px;
            height: 8px;
            margin-right: 3px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            display: inline-block;
        }

            .w-block.active {
                background: #0f0;
                border-color: #0f0;
                box-shadow: 0 0 5px #0f0;
            }

        /* ボスUIコンテナ表示制御 */
        #boss-ui-container {
            display: none;
            margin-top: 10px;
        }

        /* =========================================================
                5. ゲーム中メッセージ
                ========================================================= */
        #warning-msg {
            display: none; /* 初期は非表示 */
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #f00;
            font-size: 24px;
            animation: blink 0.2s infinite; /* 点滅警告 */
        }

        #stage-msg {
            display: none;
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 40px;
            text-shadow: 0 0 20px #0ff;
        }

        /* =========================================================
                6. オーバーレイ（タイトル・ポーズ）
                ========================================================= */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85); /* 半透明の暗幕 */

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto; /* 操作を受け付ける */
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none; /* ポーズ時のみ表示 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 105;
            pointer-events: auto;
            backdrop-filter: blur(5px); /* 背景ぼかし */
        }


        /* =========================================================
                7. 共通メニューボタン
                ========================================================= */
        .menu-btn {
            background: rgba(0,255,255,0.1); /* 半透明ネオン背景 */
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 30px;
            margin: 8px;
            font-size: 22px;
            font-family: 'Orbitron';
            cursor: pointer;
            min-width: 240px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

            .menu-btn:active {
                background: #0ff; /* 押下時に反転 */
                color: #000;
                transform: scale(0.95);
            }


        /* =========================================================
                8. OST（サウンドトラック画面）
                ========================================================= */
        #ost-ui {
            display: none; /* 初期は非表示 */

            position: fixed; /* 全画面固定 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 110;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
            pointer-events: auto;
        }

        #ost-scroll-container {
            width: 90%;
            max-width: 500px;
            max-height: 60vh; /* 画面高さの60% */

            overflow-y: auto; /* スクロール可能 */
            margin: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        .track-item {
            padding: 15px 20px;
            width: 100%;
            border-bottom: 1px solid #333;
            color: #888;
            text-align: center;
            font-size: 16px;
            box-sizing: border-box;
            cursor: pointer;
        }

            .track-item.playing {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 10px #0ff;
                background: rgba(0,255,255,0.05);
            }

        /* =========================================================
                9. 操作コントローラー（ジョイスティック）
                見た目のデザインと配置設定
                ========================================================= */

        /* 全体コンテナ */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            touch-action: none;
            pointer-events: auto;
        }

        /* --- ジョイスティック：外枠（ベース） --- */
        .joystick-area {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: radial-gradient(circle, rgba(0, 255, 255, 0.05) 0%, rgba(0, 0, 0, 0.2) 70%);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1), inset 0 0 10px rgba(0, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

            /* 外枠内の十字目盛り（装飾） */
            .joystick-area::before, .joystick-area::after {
                content: '';
                position: absolute;
                background: rgba(0, 255, 255, 0.2);
            }

            .joystick-area::before {
                width: 100%;
                height: 1px;
                background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            }

            .joystick-area::after {
                width: 1px;
                height: 100%;
                background: linear-gradient(180deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            }

        /* --- ジョイスティック：つまみ（Knob） --- */
        .knob {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.15);
            border: 2px solid #0ff;
            position: absolute;
            transform: translate(0,0);
            transition: transform 0.05s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            z-index: 2;
        }

            /* つまみ中心のドット */
            .knob::after {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 12px;
                height: 12px;
                background: #fff;
                border-radius: 50%;
                transform: translate(-50%, -50%);
                box-shadow: 0 0 10px #fff;
            }

        /* --- 特殊攻撃（BOMB/LAUNCH）ボタン --- */
        #launch-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.1);
            border: 2px solid #ff0;
            color: #ff0;
            font-family: 'Orbitron';
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.2);
            pointer-events: auto;
            text-shadow: 0 0 5px #ff0;
        }

            /* ボタン周りの回転リング */
            #launch-btn::before {
                content: '';
                position: absolute;
                width: 90px;
                height: 90px;
                border: 1px dashed rgba(255, 255, 0, 0.4);
                border-radius: 50%;
                animation: rotate 4s linear infinite;
            }

            /* 押下時のフィードバック */
            #launch-btn.active {
                background: #ff0;
                color: #000;
                transform: scale(0.85);
                box-shadow: 0 0 30px #ff0;
                text-shadow: none;
            }

        /* =========================================================
                9.2. デバイス別レイアウト（レスポンシブ）
                ========================================================= */

        /* --- デフォルト設定（横向き：Landscape） --- */
        #stick-left {
            left: 20px;
            bottom: 40px;
        }

        #stick-right {
            right: 20px;
            bottom: 40px;
        }

        #launch-btn {
            right: 20px;
            bottom: 100px;
        }

        /* --- 縦向き設定（Portrait） --- */
        @media (orientation: portrait) {
            #stick-left {
                left: 20px;
                bottom: 50px;
            }

            #stick-right {
                right: 20px;
                bottom: 50px;
            }

            #launch-btn {
                right: 0px;
                bottom: 220px;
            }
        }

        /* 回転アニメーション */
        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
        /* =========================================================
                10. ランキング画面
                ========================================================= */
        #ranking-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
        }

        #ranking-scroll-container {
            width: 95%;
            max-width: 600px;
            max-height: 60vh;
            overflow-y: auto;
            margin: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        #ranking-table {
            width: 100%;
            border-collapse: collapse;
            color: #fff;
            font-family: 'Orbitron';
            font-size: 14px;
        }

            #ranking-table th {
                border-bottom: 1px solid #0ff;
                color: #0ff;
                padding: 10px;
            }

            #ranking-table td {
                border-bottom: 1px solid #333;
                padding: 8px 10px;
            }

        .rank-1 {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            font-weight: bold;
            font-size: 1.2em;
        }

        .rank-2 {
            color: #c0c0c0;
            text-shadow: 0 0 10px #c0c0c0;
            font-weight: bold;
        }

        .rank-3 {
            color: #cd7f32;
            text-shadow: 0 0 10px #cd7f32;
            font-weight: bold;
        }


        /* =========================================================
                11. 名前入力画面
                ========================================================= */
        #name-input-area {
            display: none;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 55%;
            width: 100%;
            z-index: 200;
        }

        #player-name-input {
            background: rgba(0,0,0,0.8);
            border: 2px solid #0ff;
            color: #fff;
            font-family: 'Orbitron';
            font-size: 24px;
            padding: 10px;
            text-align: center;
            width: 250px;
            outline: none;
            margin-bottom: 10px;
            box-shadow: 0 0 10px #0ff;
        }

            #player-name-input::placeholder {
                color: #055;
            }


        /* =========================================================
                12. エンディング画面
                ========================================================= */
        #ending-msg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
        }

        #final-score-val {
            background: rgba(0,255,255,0.1);
            padding: 10px 30px;
            border-top: 1px solid rgba(0,255,255,0.3);
            border-bottom: 1px solid rgba(0,255,255,0.3);
            margin-bottom: 30px;
        }


        /* =========================================================
                13. アニメーション定義
                ========================================================= */
        @keyframes blink {
            50% {
                opacity: 0.5; /* 半透明にして点滅 */
            }
        }

        /* =========================================================
                14. ミニマップ
                ========================================================= */
        /* 中央レーダー（ミニマップ）の配置設定 */
        #minimap-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%); /* 画面中央に固定 */
            width: 100px; /* 少し小さくして視界を確保 */
            height: 100px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            background: rgba(0, 10, 20, 0.6);
            backdrop-filter: blur(2px); /* 背景を少しぼかして視認性アップ */
            z-index: 30;
        }

        /* レーダー内のキャンバスもリサイズ */
        #minimap-canvas {
            width: 100px;
            height: 100px;
        }
    </style>

</head>

<body>

    <canvas id="game"></canvas>

    <div id="ui">
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="100" height="100"></canvas>
        </div>
        <div class="hud-row">
            <div id="info-box" style="display:flex; flex-direction:column; gap:8px;">
                <div id="score-display">000000</div>
                <div><span class="hud-label">STAGE</span><span id="stage-num">1</span></div>
                <div>
                    <span class="hud-label">WEAPON</span>
                    <div id="weapon-display" style="height:12px; display:flex; align-items:center;"></div>
                </div>
                <div id="invuln-wrapper" style="display:none; margin-top: 2px;">
                    <span class="bar-label" style="color:#ff0; font-size:10px;">INVINCIBLE</span>
                    <div class="bar-frame"
                         style="border-color:#ff0; background:rgba(40,40,0,0.5); width:80px; height:6px;">
                        <div id="invuln-bar" style="width:0%; height:100%; background:#ff0; box-shadow:0 0 5px #ff0;">
                        </div>
                    </div>
                </div>
            </div>
            <div id="gauge-box">
                <span class="bar-label">SHIELD</span>
                <div class="bar-frame">
                    <div id="shield-bar"></div>
                </div>

                <span class="bar-label enemy">ENEMY SWARM</span>
                <div class="bar-frame enemy">
                    <div id="enemy-bar"></div>
                </div>

                <div id="boss-ui-container">
                    <span class="bar-label" id="boss-name-label">BOSS: NAME</span>
                    <div id="boss-bar-frame" class="bar-frame boss">
                        <div id="boss-hp-bar-inline"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="warning-msg">GRAVITY CRITICAL</div>
        <div id="stage-msg">STAGE CLEAR</div>

        <div id="ending-msg">
            <h1 style="color:#fff; font-size:30px; text-shadow:0 0 30px #0ff; margin-bottom:5px;">MISSION COMPLETE</h1>
            <p style="color:#0ff; font-size:14px; letter-spacing:3px; margin-bottom:15px;">ALL SECTORS LIBERATED</p>
            <div id="final-score-val" style="color:#fff; font-size:24px; margin-bottom:20px; font-family:'Orbitron';">TOTAL SCORE: 0</div>
            <div class="menu-btn" id="btn-next-result" style="margin-top:10px;">NEXT</div>
        </div>
    </div>

    <div id="name-input-area" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:300; flex-direction:column; align-items:center; justify-content:center;">
        <h2 id="clear-congrats-msg" style="display:none; color:#ffd700; font-size:36px; text-shadow:0 0 20px #ffd700; margin-bottom:10px;">CONGRATULATIONS!</h2>

        <h2 id="result-score-display" style="color:#fff; font-size:32px; margin-bottom:20px;">SCORE: 0</h2>
        <p style="color:#0ff; margin-bottom:10px;">REGISTER TO WORLD RANKING?</p>
        <input type="text" id="player-name-input" placeholder="ENTER NAME" maxlength="10">

        <div style="display:flex; gap:20px; margin-top:10px;">
            <div class="menu-btn" id="submit-score-btn" style="min-width: 140px; padding: 10px;">SUBMIT</div>
            <div class="menu-btn" id="skip-score-btn" style="min-width: 140px; padding: 10px; border-color:#555; color:#aaa;">SKIP</div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="menu-title"
            style="color:#0ff; font-size:36px; margin-bottom:10px; text-shadow:0 0 20px #0ff; text-align:center;">
            NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>
        </h1>

        <div id="menu-buttons-container" style="display:flex; flex-direction:column; align-items:center;">
            <div class="menu-btn" id="btn-start">START GAME</div>
            <div class="menu-btn" id="btn-ranking">WORLD RANKING</div>
            <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
            <div class="menu-btn" id="btn-title" style="display:none;">TITLE</div>
        </div>

        <div id="menu-footer" style="font-size:12px;color:#888;margin-top:20px;">
            PC: [X] Bomb | MOBILE: Small Button to Bomb
        </div>
    </div>


    <div id="ranking-overlay">
        <h1 style="color:#0ff; text-shadow:0 0 20px #0ff; margin-bottom: 2px;">TOP COMMANDERS</h1>
        <div id="loading-ranking" style="color:#0ff; animation: blink 0.5s infinite;">CONNECTING...</div>

        <div id="ranking-scroll-container">
            <table id="ranking-table">
                <thead>
                    <tr>
                        <th style="width:50px;">RANK</th>
                        <th style="text-align:left;">NAME</th>
                        <th>STAGE</th>
                        <th style="text-align:right;">SCORE</th>
                    </tr>
                </thead>
                <tbody id="ranking-list-body"></tbody>
            </table>
        </div>

        <div class="menu-btn" id="close-ranking-btn">CLOSE</div>
    </div>

    <div id="pause-overlay">
        <h1 style="color:#fff; font-size:40px; text-shadow:0 0 10px #fff;">PAUSED</h1>
        <p style="color:#aaa; margin-top:20px;">TAP TO RESUME</p>
    </div>

    <div id="ost-ui">
        <h2 style="color:#0ff; text-shadow:0 0 20px #0ff; margin-bottom: 5px;">SOUNDTRACK</h2>

        <div id="ost-scroll-container">
            <div id="track-list"></div>
        </div>

        <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
    </div>

    <div id="controls">
        <div id="stick-left" class="joystick-area">
            <div class="knob" id="knob-left"></div>
        </div>
        <div id="stick-right" class="joystick-area">
            <div class="knob" id="knob-right"></div>
        </div>
        <div id="launch-btn">BOMB</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCRjHe893FZopPErdjtgX8KJ8KPT_rmgnI",
            authDomain: "stellar-gravity.firebaseapp.com",
            projectId: "stellar-gravity",
            storageBucket: "stellar-gravity.firebasestorage.app",
            messagingSenderId: "936422140891",
            appId: "1:936422140891:web:d4e55c30507570602515fe",
            measurementId: "G-0FWP5X8T2T"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const SCORES_COLLECTION = "neon_gravity_scores";

        // HTML要素の取得
        const rankingOverlay = document.getElementById("ranking-overlay");
        const rankingBody = document.getElementById("ranking-list-body");
        const loadingEl = document.getElementById("loading-ranking");
        const tableEl = document.getElementById("ranking-table");

        function escapeHtml(str) {
            if (!str) return "";
            return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        }

        // --- ランキング表示機能 ---
        window.showRanking = async function () {
            rankingOverlay.style.display = "flex";
            loadingEl.style.display = "block";
            tableEl.style.display = "none";
            rankingBody.innerHTML = "";

            try {
                const q = query(collection(db, SCORES_COLLECTION), orderBy("score", "desc"), limit(10));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    rankingBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">NO DATA</td></tr>';
                } else {
                    let rank = 1;
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const tr = document.createElement("tr");
                        let rankClass = "";
                        let rankText = "#" + rank;
                        if (rank === 1) { rankClass = "rank-1"; rankText = "1ST"; }
                        else if (rank === 2) { rankClass = "rank-2"; rankText = "2ND"; }
                        else if (rank === 3) { rankClass = "rank-3"; rankText = "3RD"; }

                        const stageVal = data.stage ? "ST." + data.stage : "-";

                        tr.innerHTML = `
                                                <td class="${rankClass}" style="text-align:center;">${rankText}</td>
                                                <td style="text-align:left;">${escapeHtml(data.name)}</td>
                                                <td style="color:#aaa; text-align:center;">${stageVal}</td>
                                                <td style="text-align:right; color:#0ff;">${data.score.toLocaleString()}</td>
                                            `;
                        rankingBody.appendChild(tr);
                        rank++;
                    });
                }

                loadingEl.style.display = "none";
                tableEl.style.display = "table";
            } catch (e) {
                console.error("Ranking Error:", e);
                loadingEl.innerText = "CONNECTION ERROR";
            }
        };

        // --- スコア送信機能 ---
        window.submitScore = async function (score, stage) {
            const nameInput = document.getElementById("player-name-input");
            const submitBtn = document.getElementById("submit-score-btn");
            const nameInputArea = document.getElementById("name-input-area");

            const name = nameInput.value.trim() || "PILOT";

            try {
                await addDoc(collection(db, SCORES_COLLECTION), {
                    name: name,
                    score: score,
                    stage: stage,
                    timestamp: serverTimestamp()
                });

                localStorage.setItem("neonGravity_last_name", name);

                // 送信成功後の処理
                nameInputArea.style.display = "none";
                if (typeof window.proceedToNextMenu === "function") {
                    window.proceedToNextMenu();
                } else {
                    window.showRanking();
                }

            } catch (e) {
                console.error("Submit Error:", e);
                alert("Error sending score. Please try again.");
                // 失敗した場合はボタンを再活性化
                submitBtn.style.pointerEvents = "auto";
                submitBtn.innerText = "SUBMIT";
            }
        };

        // --- 画面内のボタン初期設定 ---
        const btnRanking = document.getElementById("btn-ranking");
        if (btnRanking) btnRanking.onclick = () => window.showRanking();

        const closeRankingBtn = document.getElementById("close-ranking-btn");
        if (closeRankingBtn) {
            closeRankingBtn.onclick = () => {
                rankingOverlay.style.display = "none";
            };
        }

        // 保存された名前の読み込み
        const saved = localStorage.getItem("neonGravity_last_name");
        const nameInput = document.getElementById("player-name-input");
        if (saved && nameInput) nameInput.value = saved;
    </script>

    <script>
        // =========================================================
        // 1. 定数・グローバル変数定義 (Constants & Globals)
        // =========================================================
        // ゲームバランス、敵パラメータ、配列の初期化など

        // 全体の描画スケール（0.7 = 標準の70%の大きさ）
        const G_SCALE = 0.7;
        // ゲーム全体の速度倍率（値を上げるとすべてが速くなります）
        const SPEED_SCALE = 0.25;
        // 画面端の見えない壁の余白
        const WALL_MARGIN = 5;
        // 通常ショットの最大強化レベル（1〜7）
        const MAX_WEAPON_LEVEL = 7; // 最大を7に変更

        // --- ステージ・難易度設定 ---
        let currentStage = 1; // 1からスタート
        const ENEMIES_BASE_COUNT = 5; // ステージ1の基本敵数
        const ENEMY_BASE_SPEED = 1.5; // ステージ1の基本速度
        const MAX_STAGE = 8;

        // --- 難易度スケーリング設定 ---
        const DIFFICULTY_CONFIG = {
            SPEED_INC: 0.08,      // 1ステージごとの速度上昇率 (0.08 = 8%)
            HP_INC: 0.5,         // 1ステージごとのHP上昇補正
            SPAWN_INC: 15,       // 1ステージごとに増える敵の数
            BULLET_SPEED_INC: 0.06 // 1ステージごとの弾速上昇率
        };

        // 背景グリッド線の間隔（小さいほど網目が細かくなる）
        const GRID_SPACING = 25;

        // --- 敵の移動速度設定 ---
        const ENEMY_SPEEDS = {
            TRIANGLE: 4.8,  // 紫：高速で直線的な動き
            CUBE: 2.5,      // 緑：アイテムキャリア、動きは遅め
            TADPOLE: 10,    // 白：精子型、非常に素早い
            DRAGON: 5,      // 赤：ボス、最高速度が高い
            HUNTER: 7,
            HUNTER_ROT: 3,  // 接近時の回転速度
            ASTEROID: 3.5,  // 白：分裂する岩、慣性移動（★追加）
            BOSS_MISSILE: 8, // ★これを追加（ミサイルの巡航速度）
        };

        // ドラゴンがプレイヤーを追尾する際の加速力（旋回性能に影響）
        const DRAGON_ACCELERATION = 0.2;

        // --- 敵の出現（スポーン）バランス設定 ---
        const STAGE_ENEMY_COUNTS = [
            60,  // Stage 1
            80,  // Stage 2
            30,  // Stage 3
            120, // Stage 4
            150, // Stage 5
            190, // Stage 6
            240, // Stage 7
            300  // Stage 8 (Final)
        ];

        // --- ★追加：画面内に同時に存在できる敵の最大数（ステージ別） ---
        // 設定値を超えている間は、新しいワームホール（敵の出現口）が発生しなくなります
        const STAGE_MAX_ON_SCREEN = [
            10,   // Stage 1: チュートリアル的に少なめ
            15,  // Stage 2
            20,  // Stage 3
            25,  // Stage 4
            30,  // Stage 5
            35,  // Stage 6
            40,  // Stage 7
            50   // Stage 8: 激戦
        ];

        // --- STAGE_ENEMIES 定義 ---
        // Cube（アイテム）は別途15%で出現するため、ここには書きません
        const STAGE_ENEMIES = {
            // ST1: 基本の突撃敵と、少し速い敵
            1: ['triangle', 'triangle', 'triangle', 'dragon'],
            // ST2: 弾を撃つドラゴンを追加
            2: ['triangle', 'triangle', 'tadpole', 'dragon'],
            // ST3: 岩石地帯（岩多め）
            3: ['asteroid', 'asteroid', 'asteroid', 'tadpole'],
            // ST4: バランス型（岩は少なめ＝1つだけ入れる）
            4: ['triangle', 'triangle', 'tadpole', 'tadpole', 'dragon', 'dragon', 'asteroid'],
            // ST5: ★新敵 HUNTER 登場（岩少なめ）
            5: ['triangle', 'tadpole', 'dragon', 'triangle', 'hunter', 'asteroid'],
            // ST6: HUNTERの比率を上げ、激戦化
            6: ['triangle', 'tadpole', 'dragon', 'triangle', 'hunter', 'hunter', 'asteroid'],
            // ST7: 総力戦（全種均等に近いが、強い敵多め）
            7: ['triangle', 'tadpole', 'dragon', 'dragon', 'hunter', 'hunter', 'asteroid'],
            // ST8: ボス戦（取り巻きはHUNTERとDRAGONのみで圧力をかける）
            8: ['triangle', 'hunter', 'tadpole', 'dragon', 'asteroid', 'asteroid']
        };

        // --- ボスのバリエーション設定 ---
        const BOSS_VARIANTS = [
            { name: 'TRI-FORTRESS', sides: 3, color: '#f0f', hp: 100, bulletCount: 3, speedFactor: 1.5 }, // 高速
            { name: 'DIAMOND-CORE', sides: 4, color: '#ffff00', hp: 140, bulletCount: 4, speedFactor: 1.3 },
            { name: 'PENTA-BASE', sides: 5, color: '#0f8', hp: 140, bulletCount: 5, speedFactor: 1.1 },
            { name: 'HEXAGON-NEST', sides: 6, color: '#0cc', hp: 160, bulletCount: 6, speedFactor: 1.0 },
            { name: 'HEPTA-GATE', sides: 7, color: '#44f', hp: 180, bulletCount: 7, speedFactor: 0.9 },
            { name: 'OCTAGON-COMMAND', sides: 8, color: '#f40', hp: 200, bulletCount: 8, speedFactor: 0.8 },
            { name: 'NONA-REVEALER', sides: 9, color: '#f08', hp: 220, bulletCount: 9, speedFactor: 0.7 },
            { name: 'DECA-DECIMATOR', sides: 10, color: '#fff', hp: 300, bulletCount: 10, speedFactor: 0.6 } // 超巨大・鈍重
        ];

        // --- 当たり判定（半径）設定 ---
        const ENEMY_HITBOX = {
            TRIANGLE: 12,
            CUBE: 15,
            TADPOLE: 18,
            DRAGON: 25,
            HUNTER: 20,    // ★追加：星型なので少し大きめに設定
            BULLET: 8,      // 敵が撃ってくる赤い弾の判定サイズ
        };

        // --- エフェクト演出設定 ---
        // 敵撃破時の火花の飛散速度
        const EXPLOSION_SPEED_MAG = 2.0;
        // 敵撃破時の火花の量（1.5 = 1.5倍）
        const EXPLOSION_COUNT_MAG = 1.5;

        // --- ショット・弾丸の設定 ---
        const BULLET_SETTINGS = {
            PLAYER_SPEED: 32.0, // 自機の弾の速さ
            PLAYER_LIFE: 120,   // 自機の弾が消えるまでの時間（＝射程距離）
            ENEMY_SPEED: 10.0,  // 敵の弾の速さ
            ENEMY_LIFE: 200     // 敵の弾の射程
        };

        // --- 敵の出現（スポーン）バランス設定 ---
        const SPAWN_SETTINGS = {
            MAX_WORMHOLES_BASE: 3,  // 画面内に同時に存在できるワームホールの基本数 maxWormholes = SPAWN_SETTINGS.MAX_WORMHOLES_BASE + stage *1.5
            SPAWN_INTERVAL: 180,    // ワームホールから敵が出る間隔（60フレーム = 1秒）
            WORMHOLE_CHANCE: 0.02   // 毎フレーム、新しいワームホールが発生する確率
        };



        // --- アイテム・特殊状態の設定 ---
        // レーザーの持続時間（600フレーム = 10秒）
        const LASER_DURATION = 400;
        // 出現したアイテムが点滅して消えるまでの時間
        const ITEM_LIFE = 240;

        // --- Global Variables ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const miniMapCanvas = document.getElementById('minimap-canvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        const ui = {
            overlay: document.getElementById('overlay'),
            pauseOverlay: document.getElementById('pause-overlay'),
            ost: document.getElementById('ost-ui'),
            controls: document.getElementById('controls'),
            score: document.getElementById('score-display'),
            stage: document.getElementById('stage-num'),

            weaponDisplay: document.getElementById('weapon-display'),

            shieldBar: document.getElementById('shield-bar'),
            shieldVal: document.getElementById('shield-val'),
            enemyBar: document.getElementById('enemy-bar'),
            invulnWrapper: document.getElementById('invuln-wrapper'),
            invulnBar: document.getElementById('invuln-bar'),
            msg: document.getElementById('stage-msg'),
            warn: document.getElementById('warning-msg'),
            launchBtn: document.getElementById('launch-btn'),
            knobL: document.getElementById('knob-left'),
            knobR: document.getElementById('knob-right'),
            stickL: document.getElementById('stick-left'),
            stickR: document.getElementById('stick-right'),
            btnStart: document.getElementById('btn-start'),
            btnOst: document.getElementById('btn-ost'),
            btnTitle: document.getElementById('btn-title'),
            titleText: document.querySelector('#overlay h1'),

            bossContainer: document.getElementById('boss-ui-container'),
            bossNameLabel: document.getElementById('boss-name-label'),
            bossBarFrame: document.getElementById('boss-bar-frame'),
            bossHpBarInline: document.getElementById('boss-hp-bar-inline'),

            endingHud: document.getElementById('ending-msg'),
            finalScore: document.getElementById('final-score'),
            btnBackTitle: document.getElementById('btn-back-to-title'),

            btnNextResult: document.getElementById('btn-next-result'),

            submitBtn: document.getElementById("submit-score-btn"),
            skipScoreBtn: document.getElementById("skip-score-btn"),
            nameInput: document.getElementById("player-name-input"),
            nameInputArea: document.getElementById("name-input-area"),

        };

        let width, height, worldSize = 0, camera = { x: 0, y: 0 };
        let gameState = 'TITLE';
        let previousGameState = '';
        let score = 0, frame = 0, stage = 1;
        let spawnedCount = 0, enemiesToSpawn = 0, isStageClear = false;
        let dyingTimer = 0;
        let enemiesKilled = 0;
        let isBossSpawned = false;
        let isShootItemDroppedInStage = false;

        const player = { x: 0, y: 0, vx: 0, vy: 0, angle: 0, satellites: [], shield: 100, weaponLevel: 1, invuln: 0, laserTimer: 0, history: [] };
        const input = { move: { x: 0, y: 0, active: false }, aim: { x: 0, y: 0, active: false }, keys: {} };
        let bullets = [], lasers = [], enemies = [], enemyBullets = [], particles = [], crystals = [], missiles = [], powerups = [], wormholes = [], scorePopups = [], gridPoints = [], rings = [], stars = [];

        // =========================================================
        // 2. オーディオシステム (Audio System)
        // =========================================================

        const BGM_FILES = {
            title: 'audio/Neon_Gravity_Title.mp3',
            clear: 'audio/Neon_Gravity_Clear.mp3',
            boss: 'audio/Neon_Gravity_Boss.mp3',
            stages: ['audio/Neon_Gravity_00.mp3', 'audio/Neon_Gravity_01.mp3', 'audio/Neon_Gravity_02.mp3', 'audio/Neon_Gravity_03.mp3']
        };

        const AudioSys = {
            ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null,
            init() {
                if (!this.ctx) {
                    try { const AC = window.AudioContext || window.webkitAudioContext; if (AC) { this.ctx = new AC(); this.createNoise(); } } catch (e) { }
                }
                if (!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
            },
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => { }); },
            createNoise() {
                if (!this.ctx) return;
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                this.noiseBuffer = buf;
            },
            playSE(type) {
                if (!this.ctx) return;
                this.resume();
                const t = this.ctx.currentTime;
                const g = this.ctx.createGain(); g.connect(this.ctx.destination);

                if (type === 'shoot') {
                    const o = this.ctx.createOscillator();
                    o.type = 'triangle';
                    o.frequency.setValueAtTime(800, t);
                    o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.08, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g);
                    o.start(t);
                    o.stop(t + 0.1);
                } else if (type === 'laser') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(120, t); o.frequency.linearRampToValueAtTime(80, t + 0.15);
                    const mod = this.ctx.createOscillator(); mod.type = 'square'; mod.frequency.value = 500;
                    const modGain = this.ctx.createGain(); modGain.gain.value = 500;
                    mod.connect(modGain); modGain.connect(o.frequency); mod.start(t); mod.stop(t + 0.15);
                    g.gain.setValueAtTime(0.10, t); g.gain.linearRampToValueAtTime(0, t + 0.15);
                    o.connect(g); o.start(t); o.stop(t + 0.15);
                } else if (type === 'explode' || type === 'dragon_explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        const startFreq = type === 'dragon_explode' ? 200 : 600;
                        const dur = type === 'dragon_explode' ? 1.5 : 0.5;
                        f.frequency.setValueAtTime(startFreq, t); f.frequency.exponentialRampToValueAtTime(20, t + dur);
                        g.gain.setValueAtTime(type === 'dragon_explode' ? 0.9 : 0.7, t); g.gain.exponentialRampToValueAtTime(0.01, t + dur);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + dur);
                    }
                } else if (type === 'launch') {
                    // ★修正箇所：エラーになっていた行を修正
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';

                        o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(40, t + 0.3);
                        filter.frequency.setValueAtTime(1000, t); filter.frequency.exponentialRampToValueAtTime(100, t + 0.3);

                        g.gain.setValueAtTime(0.4, t); g.gain.linearRampToValueAtTime(0, t + 0.3);

                        n.connect(filter); o.connect(filter); filter.connect(g);
                        n.start(t); n.stop(t + 0.3);
                        o.start(t); o.stop(t + 0.3);
                        // 謎の関数呼び出しを削除しました
                    }
                } else if (type === 'powerup') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1800, t + 0.2);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'damage') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(50, t + 0.2);
                    g.gain.setValueAtTime(0.16, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'invincible') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(800, t + 0.5);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.connect(g); o.start(t); o.stop(t + 0.5);
                } else if (type === 'boss_hit') {
                    // --- 修正版：重厚な装甲に弾かれる音（ガキンッ！/ボゴォッ！） ---

                    // 1. 矩形波（Square）で金属質の倍音は維持
                    const o = this.ctx.createOscillator();
                    o.type = 'square';

                    // 2. ローパスフィルタに変更して、音の「太さ・重さ」を残す
                    const f = this.ctx.createBiquadFilter();
                    f.type = 'lowpass';
                    f.Q.value = 8; // 叩いた時の「硬さ」を表現

                    // 3. ピッチ：中低音域 (300Hz) から一気に下げることで打撃感を出す
                    o.frequency.setValueAtTime(350, t);
                    o.frequency.exponentialRampToValueAtTime(50, t + 0.15);

                    // フィルタ：アタック音（高い成分）から急激に閉じて余韻をカット
                    f.frequency.setValueAtTime(3000, t);
                    f.frequency.exponentialRampToValueAtTime(100, t + 0.1);

                    // 4. 音量：太い音なので少し大きめでもOK、減衰は早めに
                    g.gain.setValueAtTime(0.08, t);
                    g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                    // 接続
                    o.connect(f);
                    f.connect(g);

                    o.start(t);
                    o.stop(t + 0.15);
                }
            },
            playBGM(key, idx = 0) {
                if (!this.bgmEl) return;
                let src;
                if (key === 'title') src = BGM_FILES.title;
                else if (key === 'clear') src = BGM_FILES.clear;
                else if (key === 'boss') src = BGM_FILES.boss;
                else {

                    const actualIdx = idx % BGM_FILES.stages.length;
                    src = BGM_FILES.stages[actualIdx];
                }

                if (this.currentSrc === src && !this.bgmEl.paused) return;
                this.bgmEl.src = src;
                this.bgmEl.currentTime = 0;
                this.bgmEl.play().catch(e => { });
                this.currentSrc = src;
            },
            stopBGM() { if (this.bgmEl) this.bgmEl.pause(); },
            pauseBGM() { if (this.bgmEl && !this.bgmEl.paused) this.bgmEl.pause(); },
            resumeBGM() { if (this.bgmEl && this.bgmEl.paused && this.currentSrc) this.bgmEl.play().catch(() => { }); }
        };

        // --- Menu Logic ---
        function openOST() {
            AudioSys.resume();
            gameState = 'OST';
            ui.overlay.style.display = 'none';
            ui.ost.style.display = 'flex';
            const list = document.getElementById('track-list');
            list.innerHTML = '';

            // ★ここに 'Boss Theme' を追加します
            const tracks = [
                { n: 'Title Theme', k: 'title' },
                { n: 'Stage 1', k: 'stage', i: 0 },
                { n: 'Stage 2', k: 'stage', i: 1 },
                { n: 'Stage 3', k: 'stage', i: 2 },
                { n: 'Stage 4', k: 'stage', i: 3 },
                { n: 'Boss Theme', k: 'boss' },   // <--- ★追加
                { n: 'Clear Theme', k: 'clear' }
            ];

            tracks.forEach(t => {
                const d = document.createElement('div'); d.className = 'track-item'; d.innerText = t.n;
                d.onclick = () => {
                    // playBGMは既に 'boss' キーに対応済みなので、これだけで再生されます
                    AudioSys.playBGM(t.k, t.i);
                    document.querySelectorAll('.track-item').forEach(e => e.classList.remove('playing'));
                    d.classList.add('playing');
                };
                list.appendChild(d);
            });
        }

        function closeOST() { returnToTitle(); }


        // =========================================================
        // 3. 初期化・システム制御 (Core Logic)
        // =========================================================
        function init() { resize(); AudioSys.init(); }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const size = Math.max(width, height) * 1.5;
            worldSize = size;

            initGrid();
            initStars();
        }

        function initGrid() {
            const cols = Math.ceil(worldSize / GRID_SPACING) + 2;
            const rows = Math.ceil(worldSize / GRID_SPACING) + 2;
            gridPoints = [];
            for (let x = 0; x <= cols; x++) {
                gridPoints[x] = [];
                for (let y = 0; y <= rows; y++) gridPoints[x][y] = { x: x * GRID_SPACING, y: y * GRID_SPACING, ox: x * GRID_SPACING, oy: y * GRID_SPACING, vx: 0, vy: 0 };
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({ x: Math.random() * worldSize, y: Math.random() * worldSize, size: Math.random() * 2, brightness: Math.random(), parallax: 0.2 + Math.random() * 0.3 });
            }
        }

        function setPaused(paused) {
            if (paused) {
                if (gameState === 'PLAYING') {
                    previousGameState = gameState;
                    gameState = 'PAUSED';
                    ui.pauseOverlay.style.display = 'flex';
                }
                AudioSys.pauseBGM();
            } else {
                if (gameState === 'PAUSED') {
                    // Do nothing, wait for user interaction
                } else {
                    AudioSys.resumeBGM();
                }
            }
        }


        // =========================================================
        // 4. シーン・ステージ管理 (Scene & Stage Management)
        // =========================================================
        function startGame() {
            AudioSys.init(); AudioSys.resume(); AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            ui.overlay.style.display = 'none'; ui.ost.style.display = 'none';
            ui.controls.style.display = 'block';

            score = 0;
            stage = 1;
            frame = 0;

            player.x = worldSize / 2;
            player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 1;
            player.satellites = []; player.invuln = 0; player.laserTimer = 0;

            ui.score.innerText = "000000"; ui.stage.innerText = "1";
            // ★削除: ui.wLv.innerText = "2"; (wLvはもう存在しないため)

            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none';

            startStage();
        }

        function startStage() {
            // ステージごとの敵総数を計算
            if (stage <= STAGE_ENEMY_COUNTS.length) {
                enemiesToSpawn = STAGE_ENEMY_COUNTS[stage - 1];
            } else {
                // 万が一設定したステージ数を超えた場合（ステージ9以降）は、最後の値を増やす等の処理
                enemiesToSpawn = STAGE_ENEMY_COUNTS[STAGE_ENEMY_COUNTS.length - 1] + 50;
            }

            // --- 変数のリセット ---
            spawnedCount = 0;
            isStageClear = false;
            enemiesKilled = 0;
            isBossSpawned = false;
            isShootItemDroppedInStage = false;
            // --------------------

            ui.msg.style.display = 'none';

            // 配列の初期化
            bullets = []; lasers = []; enemies = []; enemyBullets = [];
            crystals = []; missiles = []; powerups = []; wormholes = [];
            scorePopups = []; rings = [];

            // BGM変更ロジック
            if (gameState === 'PLAYING') {
                // ★修正: ステージ8まで対応するため、剰余(%)を使ってBGMを選択
                const bgmIndex = Math.floor((stage - 1) / 2) % BGM_FILES.stages.length;
                AudioSys.playBGM('stage', bgmIndex);
            }

            // ワームホールの生成
            const whCount = Math.max(1, Math.floor((stage + 1) / 2));
            for (let i = 0; i < whCount; i++) spawnWormhole();
        }

        function resetGame() {
            // Variable Reset
            score = 0; stage = 1; frame = 0;
            spawnedCount = 0; enemiesToSpawn = 0; isStageClear = false;
            bullets = []; lasers = []; enemies = []; enemyBullets = []; particles = []; crystals = []; missiles = []; powerups = []; wormholes = []; scorePopups = []; rings = [];

            player.x = worldSize / 2; player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 1; player.invuln = 0; player.laserTimer = 0; player.satellites = [];

            // UI Reset
            ui.score.innerText = "000000"; ui.stage.innerText = "1";


            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none'; ui.msg.style.display = 'none';
            ui.overlay.style.display = 'none'; ui.controls.style.display = 'block';

            // Restart Logic
            AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            startStage();
        }

        function returnToTitle() {
            gameState = 'TITLE';
            ui.ost.style.display = 'none';
            ui.overlay.style.display = 'flex';
            ui.controls.style.display = 'none';
            ui.msg.style.display = 'none';

            ui.titleText.innerHTML = `NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>`;
            ui.titleText.style.color = '#0ff';
            ui.titleText.style.textShadow = '0 0 20px #0ff';

            ui.btnStart.innerText = 'START GAME';
            ui.btnStart.style.borderColor = '#0ff';
            ui.btnStart.style.color = '#0ff';
            ui.btnStart.onclick = startGame;

            ui.btnOst.style.display = 'block';
            ui.btnTitle.style.display = 'none';

            // ★タイトル画面なのでランキングボタンを再表示する
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) {
                btnRanking.style.display = 'block';
                btnRanking.style.borderColor = '#0ff';
                btnRanking.style.color = '#0ff';
            }
        }

        function checkStageClear() {
            // 画面上の脅威チェック
            // enemies配列の中にアステロイドも含まれているため、noEnemiesチェックでカバーされます
            const noEnemies = enemies.length === 0;
            const noBosses = (typeof bosses !== 'undefined') ? bosses.length === 0 : true;
            const noHomings = (typeof bossHomings !== 'undefined') ? bossHomings.length === 0 : true;

            // ★重要：アステロイドが分裂して増えても、enemies.length が 0 になるまでクリアになりません

            const noWormholes = wormholes.filter(w => w.active).length === 0;

            // 1. ノルマ達成クリア (アステロイド以外の撃破数で判定)
            const normalClear = enemiesKilled >= enemiesToSpawn;

            // 2. 救済クリア (出し切ったはずなのに敵がいない場合)
            const fieldClean = noEnemies && noBosses && noHomings && noWormholes;
            const spawnComplete = spawnedCount >= enemiesToSpawn;

            // 判定
            if (!isStageClear && fieldClean && (normalClear || spawnComplete)) {
                isStageClear = true;

                if (stage === MAX_STAGE) {
                    showEnding();
                } else {
                    ui.msg.style.display = 'block';
                    AudioSys.playBGM('clear');

                    setTimeout(() => {
                        stage++;
                        ui.stage.innerText = stage;
                        startStage();
                    }, 4000);
                }
            }
        }

        function showGameOver() {
            if (gameState === 'GAMEOVER_UI') return;
            gameState = 'GAMEOVER_UI';

            AudioSys.stopBGM();
            ui.controls.style.display = 'none';

            // 10ms待機してメインスレッドを解放（フリーズ対策）
            setTimeout(() => {
                ui.overlay.style.display = 'none';
                document.getElementById('result-score-display').innerText = `SCORE: ${score.toLocaleString()}`;
                ui.nameInputArea.style.display = 'flex';

                // 送信ボタンの処理
                // ★送信ボタンに機能を割り当てる
                ui.submitBtn.onclick = async () => {
                    // Firebase側の関数 (window.submitScore) を呼び出す
                    await window.submitScore(score, stage);
                };

                // スキップボタンの処理
                ui.skipScoreBtn.onclick = (e) => {
                    e.preventDefault();
                    proceedToNextMenu();
                };

                ui.nameInput.focus();
            }, 10);
        }

        function showEnding() {
            gameState = 'ENDING';
            AudioSys.stopBGM();
            AudioSys.playBGM('clear');

            bullets = []; enemyBullets = []; enemies = [];
            createExplosion(player.x, player.y, '#fff', 200);

            ui.controls.style.display = 'none';

            // エンディング画面を表示
            ui.endingHud.style.display = 'flex';
            if (ui.finalScore) ui.finalScore.innerText = "TOTAL SCORE: " + score.toLocaleString();

            // NEXTボタンのクリックイベント
            if (ui.btnNextResult) {
                ui.btnNextResult.onclick = () => {
                    // エンディング画面を消して
                    ui.endingHud.style.display = 'none';
                    // 通常のゲームオーバー（名前入力→リザルト）フローへ合流
                    showGameOver();
                };
            }
        }

        function proceedToNextMenu() {
            ui.nameInputArea.style.display = 'none';
            ui.overlay.style.display = 'flex';

            // タイトルの設定
            let titleHTML = `GAME OVER<br><span style="font-size:20px;color:#f00;">SCORE: ${score.toLocaleString()}</span>`;
            let titleColor = '#f00';

            if (isStageClear) {
                titleHTML = `MISSION COMPLETE<br><span style="font-size:20px;color:#0ff;">SCORE: ${score.toLocaleString()}</span>`;
                titleColor = '#0ff';
            }

            ui.titleText.innerHTML = titleHTML;
            ui.titleText.style.color = titleColor;
            ui.titleText.style.textShadow = `0 0 20px ${titleColor}`;

            // ボタン類の設定
            ui.btnStart.innerText = 'RETRY';
            ui.btnStart.style.display = 'block';
            ui.btnStart.style.borderColor = titleColor;
            ui.btnStart.style.color = titleColor;

            ui.btnStart.onclick = () => resetGame();

            ui.btnTitle.style.display = 'block';
            ui.btnTitle.style.borderColor = titleColor;
            ui.btnTitle.style.color = titleColor;
            ui.btnTitle.onclick = () => returnToTitle();

            // ランキングボタンとOSTボタンを非表示にする
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) btnRanking.style.display = 'none';
            if (ui.btnOst) ui.btnOst.style.display = 'none';
        }


        // =========================================================
        // 5. メインループ (Main Loop)
        // =========================================================
        function loop() {
            requestAnimationFrame(loop);
            if (gameState === 'PAUSED') return;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);

            if (gameState === 'PLAYING') update();
            else if (gameState === 'DYING') updateDying();
            // ★ENDING中もパーティクルなどは動かし続ける
            else if (gameState === 'ENDING') {
                updateParticlesAndRings();
                updateGrid();
            }

            draw();
        }

        function update() {
            frame++;

            if (!Number.isFinite(player.x)) { player.x = worldSize / 2; player.y = worldSize / 2; player.vx = 0; player.vy = 0; }

            // Controls
            let mx = input.keys['ArrowLeft'] ? -1 : input.keys['ArrowRight'] ? 1 : input.move.x;
            let my = input.keys['ArrowUp'] ? -1 : input.keys['ArrowDown'] ? 1 : input.move.y;
            const mag = Math.hypot(mx, my); if (mag > 1) { mx /= mag; my /= mag; }
            player.vx = mx * 7.8 * SPEED_SCALE; player.vy = my * 7.8 * SPEED_SCALE;
            player.x += player.vx; player.y += player.vy;

            // 履歴（残像用）の更新
            player.history.unshift({ x: player.x, y: player.y, angle: player.angle });
            if (player.history.length > 10) player.history.pop();

            // 壁の衝突判定
            if (player.x < WALL_MARGIN) player.x = WALL_MARGIN; if (player.x > worldSize - WALL_MARGIN) player.x = worldSize - WALL_MARGIN;
            if (player.y < WALL_MARGIN) player.y = WALL_MARGIN; if (player.y > worldSize - WALL_MARGIN) player.y = worldSize - WALL_MARGIN;
            camera.x = player.x - width / 2; camera.y = player.y - height / 2;

            // 向きと射撃
            if (input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
            else if (Math.hypot(mx, my) > 0.1) player.angle = Math.atan2(my, mx);

            const fireInterval = player.laserTimer > 0 ? 4 : 6;
            if ((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % fireInterval === 0) fire();



            // --- ★修正：ワームホール生成ロジックの強化と制限 ---
            const maxWormholes = SPAWN_SETTINGS.MAX_WORMHOLES_BASE + stage * 1.5;
            const activeWormholes = wormholes.filter(w => w.active).length;

            // 現在のステージの最大同時出現数を取得（設定がない場合はデフォルト40）
            const currentMaxOnScreen = STAGE_MAX_ON_SCREEN[stage - 1] || 40;

            // 基本の生成条件
            let shouldSpawnWormhole =
                spawnedCount < enemiesToSpawn &&
                activeWormholes < maxWormholes &&
                enemies.length < currentMaxOnScreen && // ★ここを追加：画面内の敵が規定数より少ない時だけ出す
                Math.random() < SPAWN_SETTINGS.WORMHOLE_CHANCE;

            // ★救済措置：敵もワームホールもいないのに、まだ出すべき敵が残っている場合は強制生成
            // (制限にかかっていても、敵がゼロなら出す必要がある)
            if (enemies.length === 0 && activeWormholes === 0 && spawnedCount < enemiesToSpawn) {
                shouldSpawnWormhole = true;
            }

            if (shouldSpawnWormhole) {
                spawnWormhole();
            }



            wormholes.forEach((w) => {
                w.life--;
                if (w.active) {
                    if (w.life > 60 && w.life % SPAWN_SETTINGS.SPAWN_INTERVAL === 0 && spawnedCount < enemiesToSpawn) {
                        const remaining = enemiesToSpawn - spawnedCount;
                        const threshold = Math.floor(enemiesToSpawn / 5);

                        if (!isBossSpawned && remaining <= threshold) {
                            spawnEnemy(w.x, w.y, 'boss');
                            isBossSpawned = true;
                        } else {
                            if (Math.random() < 0.15) {
                                spawnEnemy(w.x, w.y, 'cube');
                            } else {
                                const currentPool = STAGE_ENEMIES[stage] || STAGE_ENEMIES[7];
                                const randomType = currentPool[Math.floor(Math.random() * currentPool.length)];
                                spawnEnemy(w.x, w.y, randomType);
                            }
                        }
                    }
                    if (w.life <= 0) w.active = false;

                    const dx = player.x - w.x; const dy = player.y - w.y;
                    const d = Math.hypot(dx, dy) || 0.01;
                    if (d < 180) { const f = 500 / (d + 1); player.x += (dx / d) * f * 0.01; player.y += (dy / d) * f * 0.01; }
                }
            });
            wormholes = wormholes.filter(w => w.life > -60);

            // サテライトの更新
            player.satellites.forEach((s, i) => {
                s.angle = (s.angle || 0) + 0.15;
                const rad = 45 * G_SCALE;
                const off = (Math.PI * 2 / player.satellites.length) * i;
                s.x = player.x + Math.cos(s.angle + off) * rad; s.y = player.y + Math.sin(s.angle + off) * rad;
            });

            // 各種エンティティ・システムの更新
            updateEntities();
            updateGrid();
            updateScorePopups();
            checkStageClear();
            updateUI();
        }

        function updateDying() {
            dyingTimer--;
            camera.x += (Math.random() - 0.5) * 5; camera.y += (Math.random() - 0.5) * 5;
            updateGrid(); updateParticlesAndRings(); updateEnemyBullets(); updateEnemiesForDying();
            if (dyingTimer <= 0) showGameOver();
        }

        function updateEnemiesForDying() {
            enemies.forEach(e => {
                // 自機から敵機へのベクトル（逃げる方向）
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const d = Math.hypot(dx, dy) || 0.001;

                // 離脱ベクトルを計算（徐々に加速して去っていく）
                const escapeSpeed = e.speed * 1.5; // 離脱なので少し速めに
                e.vx += (dx / d) * 0.1;
                e.vy += (dy / d) * 0.1;

                // 速度制限をかけつつ更新
                const cv = Math.hypot(e.vx, e.vy);
                if (cv > escapeSpeed) {
                    e.vx = (e.vx / cv) * escapeSpeed;
                    e.vy = (e.vy / cv) * escapeSpeed;
                }

                e.x += e.vx;
                e.y += e.vy;

                // 進行方向を向かせる
                e.angle = Math.atan2(e.vy, e.vx);

                // 各種演出の更新（しっぽやパーツ回転）
                if (e.type === 'dragon') {
                    let lx = e.x, ly = e.y;
                    e.segments.forEach(s => {
                        const dd = Math.hypot(lx - s.x, ly - s.y);
                        if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; }
                        lx = s.x; ly = s.y;
                    });
                }
                if (e.type === 'tadpole') {
                    e.history.unshift({ x: e.x, y: e.y });
                    if (e.history.length > 60) e.history.pop();
                }
                if (e.type === 'triangle' || e.type === 'cube') {
                    e.rotX += 0.1; e.rotY += 0.1;
                }
            });
        }

        // =========================================================
        // 6. プレイヤー・武器制御 (Player & Weapon Systems)
        // =========================================================
        function fire() {
            if (player.laserTimer > 0) {
                lasers.push({ x: player.x, y: player.y, angle: player.angle, life: 5, width: 40 });
                AudioSys.playSE('laser'); distortGrid(player.x, player.y, 20, 60); return;
            }

            const s = BULLET_SETTINGS.PLAYER_SPEED * SPEED_SCALE;
            // レベルごとの発射角度オフセット設定（0 = 前方、Math.PI = 後方）
            const shotPatterns = {
                1: [0.08, -0.08], // 2way
                2: [0.15, 0, -0.15], // 3way(前のみ)
                3: [0.15, 0, -0.15, Math.PI], // 4way(前3 後1)
                4: [0.15, 0, -0.15, Math.PI - 0.15, Math.PI + 0.15], // 5way(前3 後2)
                5: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15], // 6way(前4 後2)
                6: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2], // 7way(前4 後2 左右1ずつ)
                7: [0.25, 0.12, 0, -0.12, -0.25, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2] // 8way(前5後2 左右1ずつ)
            };

            // 現在のレベルのパターンを取得（最大レベルを超えないように制限）
            const currentPattern = shotPatterns[player.weaponLevel] || shotPatterns[1];

            currentPattern.forEach(offset => {
                const a = player.angle + offset;
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: BULLET_SETTINGS.PLAYER_LIFE });
            });

            AudioSys.playSE('shoot'); distortGrid(player.x, player.y, 10, 40);
        }

        function launchSatellites() {
            // サテライトがなければ何もしない
            if (!player.satellites || player.satellites.length === 0) return;

            // 1. 音を鳴らす
            AudioSys.playSE('launch');

            // 2. ミサイルを発射（エラーが起きてもサテライト消去まで進むように try-catch で囲む手もありますが、まずは計算式を安全にします）
            player.satellites.forEach(s => {
                // ★修正: 「自機から見たサテライトの方向」を計算して、外側に飛ばす
                // s.angle (回転用) を使うと、変な方向に飛んだりNaNになったりします
                const angle = Math.atan2(s.y - player.y, s.x - player.x);

                // スピード計算（SPEED_SCALEが未定義の可能性も考慮して安全策をとる）
                const scale = (typeof SPEED_SCALE !== 'undefined') ? SPEED_SCALE : 0.25;
                const speed = 12 * scale;

                // ミサイル配列に安全に追加
                if (typeof missiles !== 'undefined') {
                    missiles.push({
                        x: s.x,
                        y: s.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        target: null, // 初期ターゲットなし
                        life: 200,    // 寿命
                        speed: speed  // 最高速度
                    });
                }
            });

            // 3. ★重要: ここでサテライトを空にしないと、自機の周りに残り続けます
            player.satellites = [];

            // 4. 画面歪み演出（関数がある場合のみ実行）
            if (typeof distortGrid === 'function') {
                distortGrid(player.x, player.y, 300, 400);
            }
        }

        function damage(v) {
            player.shield -= v;
            player.invuln = 60;
            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            AudioSys.playSE('damage');
            distortGrid(player.x, player.y, 50, 100);

            if (player.shield <= 0) {
                gameState = 'DYING';

                dyingTimer = 120;
                bullets = []; lasers = []; missiles = [];
                createExplosion(player.x, player.y, '#0f8', 100);
                AudioSys.playSE('dragon_explode');
                distortGrid(player.x, player.y, 100, 200);
            }
        }

        function updatePlayerStatus() { if (player.invuln > 0) player.invuln--; }


        // =========================================================
        // 7. 敵機生成と共通AI (Enemy Spawning & Common AI)
        // =========================================================
        function spawnWormhole() {
            wormholes.push({
                x: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                y: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                life: 400, maxLife: 400, active: true
            });
            distortGrid(wormholes[wormholes.length - 1].x, wormholes[wormholes.length - 1].y, 50, 150);
        }

        function spawnEnemy(x, y, type, size = 1) {
            const spd = SPEED_SCALE;
            const stageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.SPEED_INC;
            const hpMag = (stage - 1) * DIFFICULTY_CONFIG.HP_INC;

            const angle = Math.random() * Math.PI * 2;
            const bSpd = 5.0 * spd;
            const vx = Math.cos(angle) * bSpd; const vy = Math.sin(angle) * bSpd;
            const rnd = Math.random();

            // アイテムドロップ決定ロジック
            let dropType = 'crystal'; // デフォルト

            // 1. レベルアップアイテム (1ステージ1個、最大レベル未満)
            if (!isShootItemDroppedInStage && player.weaponLevel < MAX_WEAPON_LEVEL && rnd < 0.15) {
                dropType = 'level';
                isShootItemDroppedInStage = true; // 生成した時点でフラグを立てる
            }
            // 2. レーザーアイテム (出現率を3%に抑制)
            else if (rnd < 0.03) {
                dropType = 'laser';
            }
            // 3. 無敵アイテム (低確率、またはシールドが減っている時に少し出やすく)
            else if (rnd < (player.shield < 40 ? 0.05 : 0.01)) {
                dropType = 'invincible';
            }

            if (type === 'dragon') {
                enemies.push({
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 8 + hpMag * 2,
                    speed: ENEMY_SPEEDS.DRAGON * spd * stageMag,
                    color: '#c00', type: 'dragon',
                    angle: Math.atan2(vy, vx), // 初速に合わせた角度を設定
                    segments: [],
                    drop: 'none',
                    scale: 0.9, fireTimer: 0
                });

                const segmentCount = 8;
                const initialAngle = Math.atan2(vy, vx);
                for (let i = 0; i < segmentCount; i++) {
                    // 全ての節に初期座標と進行方向の角度をセット
                    enemies[enemies.length - 1].segments.push({
                        x: x,
                        y: y,
                        angle: initialAngle
                    });
                }
                spawnedCount++;
            } else if (type === 'cube') {
                // アイテムキャリア（Cube）はドロップ確定
                enemies.push({
                    x, y, vx, vy,
                    hp: 2 + Math.floor(hpMag),
                    speed: ENEMY_SPEEDS.CUBE * spd * stageMag,
                    color: '#0f0', type: 'cube', angle: 0,
                    drop: dropType, // ここで決定したドロップを適用
                    scale: 0.8, rotX: 0, rotY: 0
                });
                spawnedCount++;
            } else if (type === 'tadpole') {
                enemies.push({
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 1,
                    speed: ENEMY_SPEEDS.TADPOLE * spd * stageMag,
                    color: '#fff', type: 'tadpole', angle: 0,
                    drop: 'none',
                    scale: 0.6, history: []
                });
                spawnedCount++;
            } else if (type === 'triangle') {
                const forms = ['V', 'line', 'circle'];
                const form = forms[Math.floor(Math.random() * forms.length)];
                const initialAngle = Math.atan2(vy, vx);

                const formationTypes = ['blue', 'purple', 'yellow'];
                const currentFormationType = formationTypes[Math.floor(Math.random() * formationTypes.length)];

                const colorMap = {
                    blue: '#00f0ff',
                    purple: '#bf00ff',
                    yellow: '#ffdf00' // 黄色を修正
                };
                const selectedColor = colorMap[currentFormationType];

                // --- 1. リーダーの生成 ---
                const leader = {
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 1 + Math.floor(hpMag * 0.5),
                    speed: ENEMY_SPEEDS.TRIANGLE * spd * stageMag,
                    color: selectedColor,
                    type: 'triangle',
                    formationType: currentFormationType,
                    angle: initialAngle,
                    drop: dropType,
                    scale: 0.1, // 出現時は小さく
                    isLeader: true,
                    followers: [],
                    // ★出現演出用フラグ
                    isWarping: true,
                    warpPercent: 0,
                    rotX: Math.random() * Math.PI,
                    rotY: Math.random() * Math.PI,
                    rotZ: Math.random() * Math.PI
                };
                enemies.push(leader);
                spawnedCount++;

                // --- 2. 取り巻きの生成 ---
                for (let i = 1; i <= 4; i++) {
                    if (spawnedCount >= enemiesToSpawn) break;

                    let offX = 0, offY = 0;
                    if (form === 'V') {
                        offX = Math.ceil(i / 2) * -30;
                        offY = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 20;
                    } else if (form === 'line') {
                        offX = -i * 45; // 単純に i を掛けて、等間隔に後ろへ並べる
                        offY = 0;       // 一直線なのでYはずらさない
                    } else {
                        const a = (Math.PI * 2 / 5) * i;
                        offX = Math.cos(a) * 40;
                        offY = Math.sin(a) * 40;
                    }

                    // ★修正ポイント：初期座標はリーダーと同じ(x, y)にする
                    enemies.push({
                        x: x,
                        y: y,
                        vx, vy,
                        hp: 1,
                        speed: ENEMY_SPEEDS.TRIANGLE * spd * stageMag,
                        color: selectedColor,
                        type: 'triangle',
                        formationType: currentFormationType,
                        angle: initialAngle,
                        drop: 'none',
                        scale: 0.1, // 出現時は小さく
                        leader: leader,
                        formOffset: { x: offX, y: offY },
                        // ★出現演出用フラグ
                        isWarping: true,
                        warpPercent: 0,
                        rotX: Math.random() * Math.PI,
                        rotY: Math.random() * Math.PI,
                        rotZ: Math.random() * Math.PI
                    });
                    leader.followers.push(enemies[enemies.length - 1]);
                    spawnedCount++;
                }
            } else if (type === 'boss') {
                const variantIndex = (stage - 1) % BOSS_VARIANTS.length;
                const variant = BOSS_VARIANTS[variantIndex];
                const bossHp = variant.hp + (stage - 1) * 10;

                // --- ボスのドロップ品をフラグに基づいて決定する（既存ロジック） ---
                let bossDropItem = 'shield';

                enemies.push({
                    x: x, y: y,
                    vx: vx * 0.2,
                    vy: vy * 0.2,
                    hp: bossHp, maxHp: bossHp,
                    speed: 1.2 * variant.speedFactor * spd * stageMag,
                    color: variant.color,
                    type: 'boss', variant: variant, angle: 0,
                    drop: bossDropItem,
                    scale: 1.5 + (variant.sides * 0.1),
                    fireTimer: 0, flashTimer: 0,

                    // --- ★追加：出現演出用のパラメータ ---
                    spawnTimer: 0,       // 経過時間カウント用
                    spawnMax: 150,       // 演出の長さ（フレーム数。150 = 約2.5秒）
                    isSpawning: true     // 「出現中」フラグをONにする
                });
                spawnedCount++;
            } else if (type === 'asteroid') {
                const sizeFactor = 1.0 + (stage - 1) * 0.1;
                const hp = (size === 1 ? 4 : size === 2 ? 2 : 1) + Math.floor((stage - 1) * 0.5);
                const baseScale = size === 1 ? 1.8 : size === 2 ? 1.1 : 0.6;
                const finalScale = baseScale * sizeFactor;

                const moveSpeed = (ENEMY_SPEEDS.ASTEROID * 0.7) * (1 + size * 0.4) * spd * stageMag;
                const ang = Math.random() * Math.PI * 2;

                enemies.push({
                    x, y,
                    vx: Math.cos(ang) * moveSpeed,
                    vy: Math.sin(ang) * moveSpeed,
                    hp: hp,
                    speed: moveSpeed,
                    color: '#fff',
                    type: 'asteroid',
                    size: size,
                    angle: Math.random() * Math.PI * 2,
                    rotSpd: (Math.random() - 0.5) * 0.1,
                    scale: finalScale,
                    drop: 'none',

                    // --- ★追加：追跡モード用パラメータ ---
                    spawnTimer: 0,           // 経過フレーム
                    trackingStart: 300 + Math.random() * 200, // 追跡開始までの時間（約5〜8秒）
                    isTracking: false        // 追跡中フラグ
                });

                // アステロイドは出現数には含めるが撃破ノルマには含めない（前回の仕様維持）
                // spawnedCount++; // ← 前回の修正で削除した場合はそのまま
            } else if (type === 'hunter') {
                enemies.push({
                    x: x, y: y, vx: vx * 0.5, vy: vy * 0.5,
                    hp: 3 + Math.floor(hpMag * 1.5),
                    speed: ENEMY_SPEEDS.HUNTER * spd * stageMag,
                    color: '#f80',
                    type: 'hunter',
                    angle: 0,
                    drop: dropType,
                    scale: 1.2,
                    actionTimer: 0,
                    state: 'approach', // 初期状態を 'approach' (接近) に設定
                    burstCount: 0      // ★追加：連射数カウント用
                });
                spawnedCount++;
            }

        }

        function updateEnemies() {
            enemies.forEach(e => {
                // --- ★修正ポイント ---
                // Triangle型は独自のAI（updateTriangleAI）でフォーメーション制御を行うため、
                // ここの汎用フォーメーション処理（updateFormationMovement）はスキップさせる。
                const isTriangle = (e.type === 'triangle');

                if (!isTriangle && e.leader && e.leader.hp > 0) {
                    updateFormationMovement(e);
                    // Triangle以外で回転が必要な場合の処理（もしあれば）
                    if (e.type === 'cube') { e.rotX += 0.03; e.rotY += 0.04; }
                } else {
                    // Triangleはリーダー/副機に関わらずこちら（switch文）を実行
                    switch (e.type) {
                        case 'dragon': updateDragonAI(e); break;
                        case 'tadpole': updateTadpoleAI(e); break;
                        case 'triangle': updateTriangleAI(e); break; // ★ここで副機も処理されるようになる
                        case 'cube': updateCubeAI(e); break;
                        case 'boss': updateBossAI(e); break;
                        case 'asteroid': updateAsteroidAI(e); break;
                        case 'hunter': updateHunterAI(e); break;
                    }
                }


                // --- 共通処理 ---
                applySeparation(e);
                applyAsteroidCollisions(e);
                applyWorldBoundary(e);
                checkPlayerCollision(e);
                checkSatelliteCollision(e);

                // --- 破壊判定 ---
                if (e.hp <= 0) {
                    // アステロイド分裂処理
                    if (e.type === 'asteroid' && e.size < 3) {
                        for (let i = 0; i < 2; i++) {
                            const splitAngle = Math.random() * Math.PI * 2;
                            const splitSpeed = 2.0;
                            const vx = Math.cos(splitAngle) * splitSpeed;
                            const vy = Math.sin(splitAngle) * splitSpeed;
                            spawnEnemy(e.x, e.y, 'asteroid', e.size + 1);
                        }
                    }
                    destroyEnemy(e);
                }
            });

            // 死んだ敵を除去
            enemies = enemies.filter(e => e.hp > 0);
        }

        function updateFormationMovement(e) {
            if (!e.leader || e.leader.hp <= 0) return;
            const la = e.leader.angle;
            const rotatedOffX = e.formOffset.x * Math.cos(la) - e.formOffset.y * Math.sin(la);
            const rotatedOffY = e.formOffset.x * Math.sin(la) + e.formOffset.y * Math.cos(la);
            const targetX = e.leader.x + rotatedOffX; const targetY = e.leader.y + rotatedOffY;
            e.x += (targetX - e.x) * 0.3; e.y += (targetY - e.y) * 0.3;
            e.vx = e.leader.vx; e.vy = e.leader.vy; e.angle = la;
        }

        function applySeparation(e) {
            enemies.forEach(other => {
                if (e === other) return;
                const odx = e.x - other.x, ody = e.y - other.y; const od = Math.hypot(odx, ody);
                if (od < 30) { const push = (30 - od) * 0.05; e.x += (odx / od) * push; e.y += (ody / od) * push; }
            });
        }

        function applyAsteroidCollisions(e) {
            if (e.type !== 'asteroid') return;

            enemies.forEach(other => {
                // 自分自身、または死んでいる敵、アステロイド以外の敵は無視
                if (e === other || other.hp <= 0 || other.type !== 'asteroid') return;

                const dx = other.x - e.x;
                const dy = other.y - e.y;
                const dist = Math.hypot(dx, dy) || 0.001;

                // --- 判定半径の動的な計算 ---
                // 基本半径20pxにそれぞれのscaleを掛け、さらに描画倍率G_SCALEを考慮
                const r1 = 20 * e.scale * G_SCALE;
                const r2 = 20 * other.scale * G_SCALE;
                const minDist = r1 + r2;

                if (dist < minDist) {
                    // --- 1. 重なり（めり込み）の解消 ---
                    const overlap = minDist - dist;
                    const nx = dx / dist; // 法線ベクトルx
                    const ny = dy / dist; // 法線ベクトルy

                    // サイズ（scale）を重みとして、小さい方がより大きく弾かれるように調整
                    // (質量 = scaleの2乗に比例すると仮定するとよりリアルですが、シンプルにscale比で計算)
                    const totalScale = e.scale + other.scale;
                    const ratioE = other.scale / totalScale;
                    const ratioOther = e.scale / totalScale;

                    e.x -= nx * overlap * ratioE;
                    e.y -= ny * overlap * ratioE;
                    other.x += nx * overlap * ratioOther;
                    other.y += ny * overlap * ratioOther;

                    // --- 2. 速度ベクトルの反射（弾性衝突） ---
                    // 相対速度
                    const rvx = other.vx - e.vx;
                    const rvy = other.vy - e.vy;

                    // 法線方向の速度成分（内積）
                    const velAlongNormal = rvx * nx + rvy * ny;

                    // 既に離れようとしている（ベクトルが外向き）場合は処理しない
                    if (velAlongNormal > 0) return;

                    // 反発係数 (0.6〜0.8くらいが岩らしくて自然です)
                    const restitution = 0.7;
                    const j = -(1 + restitution) * velAlongNormal;

                    // 質量比に基づいた速度変化（大きい岩ほど動きにくい）
                    e.vx -= j * nx * ratioE;
                    e.vy -= j * ny * ratioE;
                    other.vx += j * nx * ratioOther;
                    other.vy += j * ny * ratioOther;

                    // --- 3. 衝突時の火花演出 ---
                    // 激しくぶつかった時だけ火花を出す
                    if (Math.abs(velAlongNormal) > 1 && frame % 2 === 0) {
                        const midX = (e.x + other.x) / 2;
                        const midY = (e.y + other.y) / 2;
                        createExplosion(midX, midY, '#fff', 2);
                    }
                }
            });
        }

        function applyWorldBoundary(e) {
            if (e.x < WALL_MARGIN || e.x > worldSize - WALL_MARGIN) e.vx *= -1.2;
            if (e.y < WALL_MARGIN || e.y > worldSize - WALL_MARGIN) e.vy *= -1.2;
            e.x = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.x));
            e.y = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.y));
        }

        function checkPlayerCollision(e) {
            if (gameState === 'DYING' || gameState === 'GAMEOVER') return;

            const dist = Math.hypot(player.x - e.x, player.y - e.y);

            // --- 当たり判定半径の決定 ---
            let radius = 15;
            if (e.type === 'asteroid') {
                // 岩の基本半径20pxに、ステージ補正等で大きくなったscaleを掛ける
                radius = 20 * e.scale;
            } else if (e.type === 'triangle') {
                radius = ENEMY_HITBOX.TRIANGLE;
            } else if (e.type === 'cube') {
                radius = ENEMY_HITBOX.CUBE;
            } else if (e.type === 'tadpole') {
                radius = ENEMY_HITBOX.TADPOLE;
            } else if (e.type === 'dragon') {
                radius = ENEMY_HITBOX.DRAGON;
            } else if (e.type === 'hunter') {
                radius = ENEMY_HITBOX.HUNTER;
            } else if (e.type === 'boss') {
                radius = 45; // ボスの判定サイズ
            }

            // 衝突境界距離の計算（G_SCALEを考慮しつつ、無敵バリア時は判定を広げる）
            // scale/0.7 の補正をアステロイド以外にも適用
            const collisionDist = radius * (e.type === 'asteroid' ? 1 : (e.scale / 0.7)) + (player.invuln > 0 ? 20 : 0);

            if (dist < collisionDist) {
                // ★追加：出現中のボスには当たらない
                if (e.type === 'boss' && e.isSpawning) return;

                // --- ★無敵バリア展開中、または最大レベルフェニックス時の体当たり処理 ---
                if (player.invuln > 0) {
                    // アステロイド、ボス、ドラゴンの場合はHPを削る（多段ヒット）
                    if (e.type === 'boss' || e.type === 'dragon' || e.type === 'asteroid') {
                        e.hp -= 0.5;
                        if (e.type === 'boss') e.flashTimer = 5;

                        // 火花エフェクト（アステロイドなら白、それ以外なら黄色）
                        if (frame % 3 === 0) {
                            const sparkColor = e.type === 'asteroid' ? '#fff' : '#ff0';
                            createExplosion(e.x, e.y, sparkColor, 3);
                            AudioSys.playSE('damage');
                        }
                    } else {
                        // その他の雑魚敵は即死
                        e.hp = 0;
                        score += 100;
                        createExplosion(e.x, e.y, e.color, 15);
                        AudioSys.playSE('explode');
                        distortGrid(e.x, e.y, 30, 60);
                    }
                    return; // 自分がダメージを受ける処理をスキップ
                }

                // --- 通常時のダメージ処理 ---
                player.shield -= 0.5;
                if (player.invuln <= 0) {
                    player.shield -= 10;
                    player.invuln = 10;
                    createExplosion(player.x, player.y, '#f00', 5);
                    AudioSys.playSE('damage');
                }
                ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                if (player.shield <= 0) damage(0);
            }
        }

        function checkSatelliteCollision(e) {
            for (let i = player.satellites.length - 1; i >= 0; i--) {
                const s = player.satellites[i];
                if (Math.hypot(s.x - e.x, s.y - e.y) < 25) { e.hp = 0; player.satellites.splice(i, 1); e.noDrop = true; break; }
            }
        }

        function destroyEnemy(e) {
            // --- ★修正：ASTEROID以外の場合のみ撃破カウントを進める ---
            if (e.type !== 'asteroid') {
                enemiesKilled++;
            }

            // --- 爆発エフェクトのカスタマイズ ---
            const particleCount = (e.type === 'boss') ? 120 : (e.type === 'asteroid' ? 30 : 40);
            for (let i = 0; i < particleCount; i++) {
                // (中略：エフェクトのコードはそのまま)
                let pColor;
                const rand = Math.random();
                if (e.type === 'asteroid') {
                    if (rand < 0.85) pColor = '#ffffff';
                    else if (rand < 0.95) pColor = '#888888';
                    else pColor = '#ffaa00';
                } else {
                    if (rand < 0.85) pColor = e.color;
                    else if (rand < 0.95) pColor = '#ffffff';
                    else pColor = '#ffff00';
                }
                createExplosion(e.x, e.y, pColor, 1);
            }

            // --- 効果音と特殊演出 ---
            if (e.type === 'boss') {
                // (中略)
                AudioSys.playSE('dragon_explode');
                if (typeof screenShake !== 'undefined') screenShake = 40;
                distortGrid(e.x, e.y, 100, 200);

                // --- ★追加：ボス撃破時にホーミング弾(Missile)を全消去 ---
                // 1. 残っているミサイルの場所で小さな爆発を起こす（演出）
                enemyBullets.forEach(b => {
                    if (b.isMissile) {
                        createExplosion(b.x, b.y, b.color, 5); // 小さな爆発
                    }
                });

                // 2. 配列からミサイルを除外する（消滅）
                enemyBullets = enemyBullets.filter(b => !b.isMissile);
                // ----------------------------------------------------

            } else if (e.type === 'dragon') {
                // (中略)
                AudioSys.playSE('dragon_explode');
                distortGrid(e.x, e.y, 40, 80);
            } else if (e.type === 'asteroid') {
                AudioSys.playSE('explode');
                distortGrid(e.x, e.y, 20, 40);
            } else {
                AudioSys.playSE('explode');
                distortGrid(e.x, e.y, 30, 60);
            }

            // スコア処理
            const pts = (e.type === 'dragon' || e.type === 'boss') ? 1000 : (e.type === 'asteroid' ? 150 : 100);
            score += pts;
            ui.score.innerText = score.toString().padStart(6, '0');
            scorePopups.push({ x: e.x, y: e.y, text: pts, life: 40, alpha: 1, vy: -1 });

            // (中略：ドロップ処理はそのまま)
            if (e.noDrop || e.drop === 'none' || e.type === 'asteroid') return;
            // ...以下ドロップ生成コード...
            const itemProps = { x: e.x, y: e.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 };
            if (e.drop === 'level') powerups.push({ ...itemProps, type: 'level', life: 999999 });
            else if (e.drop === 'laser') powerups.push({ ...itemProps, type: 'laser', life: ITEM_LIFE });
            else if (e.drop === 'invincible') powerups.push({ ...itemProps, type: 'invincible', life: ITEM_LIFE });
            else if (e.drop === 'crystal') crystals.push({ ...itemProps, life: ITEM_LIFE });
            else if (e.drop === 'shield') powerups.push({ ...itemProps, type: 'shield', life: ITEM_LIFE });
        }


        // =========================================================
        // 8. 個別敵機AI (Specific Enemy AIs)
        // =========================================================
        function updateTriangleAI(e) {
            // --- 1. 出現・展開アニメーション (全員共通) ---
            if (e.isWarping) {
                e.warpPercent = (e.warpPercent || 0) + 0.015;
                if (e.warpPercent >= 1) {
                    e.warpPercent = 1;
                    e.isWarping = false;
                    e.scale = 0.7;
                } else {
                    e.scale = 0.1 + 0.6 * e.warpPercent;
                }
            }

            // --- 2. 座標と移動の計算 ---
            if (!e.isLeader && e.leader && e.leader.hp > 0) {
                // 【副機】
                // リーダーの角度がNaNなら0扱いにする（安全対策）
                const angle = Number.isFinite(e.leader.angle) ? e.leader.angle : 0;

                const targetRx = e.formOffset.x * Math.cos(angle) - e.formOffset.y * Math.sin(angle);
                const targetRy = e.formOffset.x * Math.sin(angle) + e.formOffset.y * Math.cos(angle);

                const ratio = e.isWarping ? e.warpPercent : 1.0;

                e.x = e.leader.x + targetRx * ratio;
                e.y = e.leader.y + targetRy * ratio;
                e.angle = angle;
                e.vx = e.leader.vx || 0;
                e.vy = e.leader.vy || 0;

            } else {
                // 【リーダー機】
                const dx = player.x - e.x;
                const dy = player.y - e.y;

                if (e.isWarping) {
                    // --- 出現中の挙動 ---

                    // 1. 移動にはブレーキをかけ、穴の中心付近に留める
                    e.vx *= 0.5;
                    e.vy *= 0.5;

                    // 2. ★追加：その場でプレイヤーの方へ旋回（ロックオン）する
                    const targetAngle = Math.atan2(dy, dx);

                    // 現在の角度との差分を計算してスムーズに回す
                    let diff = targetAngle - e.angle;
                    // -PI ~ PI の範囲に正規化（最短距離で回るため）
                    while (diff <= -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;

                    e.angle += diff * 0.1; // 0.1 は旋回速度（お好みで調整）

                } else {
                    // --- 通常時の挙動 ---
                    const d = Math.hypot(dx, dy) || 0.001;

                    // プレイヤーへ向かって加速
                    e.vx += (dx / d) * 0.2 * SPEED_SCALE;
                    e.vy += (dy / d) * 0.2 * SPEED_SCALE;

                    // 速度制限
                    const cv = Math.hypot(e.vx, e.vy);
                    if (cv > 0.0001 && cv > e.speed) {
                        e.vx = (e.vx / cv) * e.speed;
                        e.vy = (e.vy / cv) * e.speed;
                    }

                    // 通常時は「進行方向」を向く
                    e.angle = Math.atan2(e.vy, e.vx);
                }

                // 座標更新
                e.x += e.vx;
                e.y += e.vy;
            }

            // --- 3. 演出更新 ---
            e.rotX += 0.08;
            e.rotY += 0.12;
            e.rotZ += 0.05;
        }

        function updateTadpoleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(dy, dx);
            e.history.unshift({ x: e.x, y: e.y }); if (e.history.length > 60) e.history.pop();
        }

        function updateDragonAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            const spd = SPEED_SCALE;

            // 1. 頭部の移動（既存）
            e.vx += (dx / d) * DRAGON_ACCELERATION * spd;
            e.vy += (dy / d) * DRAGON_ACCELERATION * spd;
            e.vx *= 0.98; e.vy *= 0.98;

            const stageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.SPEED_INC;
            const lim = ENEMY_SPEEDS.DRAGON * spd * stageMag;

            if (Math.hypot(e.vx, e.vy) > lim) {
                const cv = Math.hypot(e.vx, e.vy);
                e.vx = (e.vx / cv) * lim; e.vy = (e.vy / cv) * lim;
            }
            e.x += e.vx; e.y += e.vy;
            e.angle = Math.atan2(e.vy, e.vx);

            // 2. ★体節の滑らかな連結追従ロジック
            let leaderX = e.x;
            let leaderY = e.y;
            const spacing = 18; // 節同士の固定距離（ここを調整すると体の伸び縮みが変わります）

            e.segments.forEach((s, i) => {
                const sDx = leaderX - s.x;
                const sDy = leaderY - s.y;
                const distance = Math.hypot(sDx, sDy);
                const targetAngle = Math.atan2(sDy, sDx);

                // パーツの向きを前のパーツに向かせる
                s.angle = targetAngle;

                // 物理的な距離を保つように座標を更新（カクつきの解消）
                if (distance > spacing) {
                    const moveDist = distance - spacing;
                    s.x += Math.cos(targetAngle) * moveDist;
                    s.y += Math.sin(targetAngle) * moveDist;
                }

                // 次の節のために現在の位置をリーダーに設定
                leaderX = s.x;
                leaderY = s.y;
            });

            // --- 弾速の変更箇所 ---
            e.fireTimer++;
            if (e.fireTimer > 100) {
                e.fireTimer = 0;

                // ここで直接、現在のステージに応じた弾速を計算
                const currentEnemyBulletSpd = BULLET_SETTINGS.ENEMY_SPEED * SPEED_SCALE * (1 + (stage - 1) * DIFFICULTY_CONFIG.BULLET_SPEED_INC);

                enemyBullets.push({
                    x: e.x,
                    y: e.y,
                    vx: Math.cos(e.angle) * currentEnemyBulletSpd,
                    vy: Math.sin(e.angle) * currentEnemyBulletSpd,
                    life: BULLET_SETTINGS.ENEMY_LIFE
                });
                AudioSys.playSE('shoot');
            }
        }

        function updateCubeAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.rotX += 0.03; e.rotY += 0.04;
        }

        function updateHunterAI(e) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy) || 0.001;

            // 定数から基本スピードを取得（SPEED_SCALEは既に掛かっている前提か、ここで掛けるか）
            // 今回は e.speed (生成時に計算済み) をベースにします
            const baseSpd = e.speed;

            e.actionTimer++;

            // --- 状態1: 高速接近 (APPROACH) ---
            if (e.state === 'approach') {
                // 定数 HUNTER_ROT があれば使用、なければ直書き
                e.angle += ENEMY_SPEEDS.HUNTER_ROT;

                // プレイヤーに向かって加速
                // 加速度も baseSpd に比例させることで、ステージが進んで速くなっても挙動が安定します
                const acc = baseSpd * 0.1;
                e.vx += (dx / dist) * acc;
                e.vy += (dy / dist) * acc;

                if (dist < 180) {
                    e.state = 'attack';
                    e.actionTimer = 0;
                    e.burstCount = 0;
                }
            }
            // --- 状態2: 攻撃 (ATTACK) ---
            else if (e.state === 'attack') {
                e.vx *= 0.85;
                e.vy *= 0.85;

                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - e.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                e.angle += diff * 0.2;

                if (e.actionTimer > 20 && e.actionTimer % 10 === 0 && e.burstCount < 3) {
                    // 弾速も定数の影響を受ける
                    const bulletSpd = BULLET_SETTINGS.ENEMY_SPEED * 1.3 * SPEED_SCALE;

                    enemyBullets.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(e.angle) * bulletSpd,
                        vy: Math.sin(e.angle) * bulletSpd,
                        life: BULLET_SETTINGS.ENEMY_LIFE,
                        color: '#f80'
                    });

                    // 反動
                    e.vx -= Math.cos(e.angle) * (baseSpd * 0.5);
                    e.vy -= Math.sin(e.angle) * (baseSpd * 0.5);

                    AudioSys.playSE('shoot');
                    e.burstCount++;
                }

                if (e.burstCount >= 3 && e.actionTimer > 60) {
                    e.state = 'retreat';
                    e.actionTimer = 0;
                }
            }
            // --- 状態3: 離脱 (RETREAT) ---
            else if (e.state === 'retreat') {
                e.angle -= 0.2;

                const escapeAcc = baseSpd * 0.08;
                e.vx -= (dx / dist) * escapeAcc;
                e.vy -= (dy / dist) * escapeAcc;

                if (dist > 450 || e.actionTimer > 120) {
                    e.state = 'approach';
                    e.actionTimer = 0;
                }
            }

            // --- 速度制限（ここが定数活用のキモ） ---
            const currentSpeed = Math.hypot(e.vx, e.vy);
            // 状態に合わせて制限速度を可変にする（接近時は基本の1.5倍まで許容）
            let maxLimit = baseSpd;
            if (e.state === 'approach') maxLimit = baseSpd * 1.5;
            if (e.state === 'retreat') maxLimit = baseSpd * 1.2;

            if (currentSpeed > maxLimit) {
                e.vx = (e.vx / currentSpeed) * maxLimit;
                e.vy = (e.vy / currentSpeed) * maxLimit;
            }

            e.x += e.vx;
            e.y += e.vy;
        }

        function updateAsteroidAI(e) {
            // 時間経過のカウント
            e.spawnTimer = (e.spawnTimer || 0) + 1;

            // --- 覚醒判定（白 → 赤） ---
            if (!e.isTracking && e.spawnTimer > e.trackingStart) {
                e.isTracking = true;
                e.color = '#ff4444'; // より鮮やかな赤に

                // ★修正ポイント1：モード切替時の速度変換と減速
                // 今までの移動速度(vx * speed)を計算し、実速度としてvx, vyに適用します。
                // さらに * 0.2 を掛けることで、一度急ブレーキをかけます。
                // これにより「ギョロっとこっちを見て動き出す」ような挙動になります。
                e.vx = (e.vx * e.speed) * 0.2;
                e.vy = (e.vy * e.speed) * 0.2;

                // 以降は speed 変数は使わず、vx, vy を直接操作するため 1 にリセット
                e.speed = 1;

                // 回転を速くする（荒ぶる演出）
                e.rotSpd *= 5;
            }

            if (e.isTracking) {
                // --- 追跡モード（自機へ加速） ---
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.hypot(dx, dy) || 0.001;

                // ★修正ポイント2：誘導性能（加速度）を強化
                // 以前の値(0.15)だと弱すぎたため、0.6程度まで上げます
                const accel = (0.6 / e.size) * SPEED_SCALE;

                e.vx += (dx / dist) * accel;
                e.vy += (dy / dist) * accel;

                // ★修正ポイント3：最高速度制限と摩擦
                // ずっと加速し続けると制御不能になるため、適度な摩擦(0.98)と上限を設けます
                const maxSpeed = 7.0 * SPEED_SCALE;
                e.vx *= 0.99; // 空気抵抗（宇宙だけど制御しやすくするため）
                e.vy *= 0.99;

                const currentSpeed = Math.hypot(e.vx, e.vy);
                if (currentSpeed > maxSpeed) {
                    e.vx = (e.vx / currentSpeed) * maxSpeed;
                    e.vy = (e.vy / currentSpeed) * maxSpeed;
                }

                // 移動
                e.x += e.vx;
                e.y += e.vy;

            } else {
                // --- 通常モード（漂流） ---
                // 以前のロジック：e.vx * e.speed で移動
                e.x += e.vx * e.speed;
                e.y += e.vy * e.speed;

                // 画面端の処理（漂流中のみループor反射）
                if (e.x < 0 || e.x > worldSize) e.vx *= -1;
                if (e.y < 0 || e.y > worldSize) e.vy *= -1;
            }

            // 自転
            e.angle += e.rotSpd;
        }

        function updateBossAI(e) {
            // --- ★追加：出現演出中の処理 ---
            if (e.isSpawning) {
                e.spawnTimer++;

                // 演出完了判定
                if (e.spawnTimer >= e.spawnMax) {
                    e.isSpawning = false;
                    // 実体化した瞬間に衝撃波（オプション）
                    if (typeof distortGrid === 'function') distortGrid(e.x, e.y, 200, 300);
                }
                return; // 出現中は移動・攻撃ロジックを実行しない
            }
            // ----------------------------

            // --- 1. 移動ロジック ---
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.02 * SPEED_SCALE;
            e.vy += (dy / d) * 0.02 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy;

            // --- 2. 高速回転・停止・発射・硬直ロジック ---
            e.fireTimer++;

            const maxCycle = 280;   // 全体のサイクルを少し長めに設定
            const brakeStart = 160; // 減速開始タイミング
            const fireTime = 220;   // 発射タイミング（ここで完全に止まる）
            const restartTime = 250; // 硬直が解けて再回転するタイミング

            let rotationSpeed = 0.08; // 通常時の高速回転

            if (e.fireTimer > brakeStart && e.fireTimer < fireTime) {
                // 【減速フェーズ】発射に向けてゆっくりに
                const ratio = 1.0 - (e.fireTimer - brakeStart) / (fireTime - brakeStart);
                rotationSpeed = Math.pow(ratio, 1.5) * 0.08;

                // エネルギー収束パーティクル
                if (frame % 3 === 0) {
                    const ang = Math.random() * Math.PI * 2;
                    particles.push({
                        x: e.x + Math.cos(ang) * 80, y: e.y + Math.sin(ang) * 80,
                        vx: -Math.cos(ang) * 4, vy: -Math.sin(ang) * 4,
                        color: '#fff', life: 0.2, size: 1.5
                    });
                }
            }
            else if (e.fireTimer >= fireTime && e.fireTimer < restartTime) {
                // 【発射＆硬直フェーズ】完全に停止
                rotationSpeed = 0;

                // 発射の瞬間（fireTime ぴったり）に弾を生成
                if (e.fireTimer === fireTime) {
                    const sides = e.variant.sides;
                    //camera.x += (Math.random() - 0.5) * 30; // 強い衝撃
                    //camera.y += (Math.random() - 0.5) * 30;

                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 60, y: e.y + Math.sin(a) * 60,
                            vx: Math.cos(a) * ENEMY_SPEEDS.BOSS_MISSILE * SPEED_SCALE,
                            vy: Math.sin(a) * ENEMY_SPEEDS.BOSS_MISSILE * SPEED_SCALE,
                            life: 300, isMissile: true, color: e.color
                        });
                    }
                    AudioSys.playSE('launch');
                    rings.push({ x: e.x, y: e.y, r: 20, color: '#fff', life: 1.0 });
                    rings.push({ x: e.x, y: e.y, r: 100, color: e.color, life: 0.8 });
                }
            }
            else if (e.fireTimer >= restartTime) {
                // 【再始動フェーズ】徐々に元の回転速度に戻る
                const ratio = (e.fireTimer - restartTime) / (maxCycle - restartTime);
                rotationSpeed = Math.pow(ratio, 2) * 0.08;
            }

            e.angle += rotationSpeed;
            if (e.fireTimer >= maxCycle) e.fireTimer = 0;
        }


        // =========================================================
        // 9. エンティティ更新 (Entity Updates)
        // =========================================================
        function updateEntities() {
            updatePlayerBullets();
            updateLasers();
            updateEnemies();
            updateEnemyBullets();
            updateCrystals();
            updatePowerups();
            updateMissiles();
            updateParticlesAndRings();
            updatePlayerStatus();
        }

        function updatePlayerBullets() {
            bullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // --- ワールド境界との衝突判定 ---
                if (b.x < WALL_MARGIN || b.x > worldSize - WALL_MARGIN ||
                    b.y < WALL_MARGIN || b.y > worldSize - WALL_MARGIN) {

                    const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, b.x));
                    const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, b.y));

                    createWallImpact(impactX, impactY, '#0f8');
                    b.life = 0;
                }

                // --- 敵との当たり判定 ---
                enemies.forEach(e => {
                    // 弾が既に消えている、または敵が死んでいる場合はスキップ
                    if (b.life <= 0 || e.hp <= 0) return;

                    // 敵の種類ごとの判定半径
                    let hitRadius = 30 * e.scale;
                    if (e.type === 'asteroid') hitRadius = 25 * e.scale;
                    else if (e.type === 'dragon') hitRadius = ENEMY_HITBOX.DRAGON;
                    else if (e.type === 'triangle') hitRadius = ENEMY_HITBOX.TRIANGLE;
                    else if (e.type === 'cube') hitRadius = ENEMY_HITBOX.CUBE;
                    else if (e.type === 'tadpole') hitRadius = ENEMY_HITBOX.TADPOLE;
                    else if (e.type === 'hunter') hitRadius = ENEMY_HITBOX.HUNTER;
                    else if (e.type === 'boss') hitRadius = 45;

                    // 距離チェック
                    if (Math.hypot(b.x - e.x, b.y - e.y) < hitRadius) {

                        b.life = 0; // 弾を消す
                        e.hp--;     // ダメージを与える

                        // --- ★修正ポイント：ヒット演出 ---

                        // 1. ボスの場合（既存）
                        if (e.type === 'boss') {
                            e.flashTimer = 5;
                            AudioSys.playSE('boss_hit');
                            for (let i = 0; i < 3; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    color: '#fff', life: 0.2, size: 2
                                });
                            }
                        }
                        // 2. ボス以外の敵（ここが重要）
                        else {
                            // HPがまだ残っているなら火花を出す
                            if (e.hp > 0) {
                                const sparkColor = e.color || '#fff';
                                for (let i = 0; i < 4; i++) {
                                    particles.push({
                                        x: b.x,
                                        y: b.y,
                                        // 弾が当たって砕けるイメージで拡散
                                        vx: (Math.random() - 0.5) * 8, // ★速度を少し上げて散らばりやすく
                                        vy: (Math.random() - 0.5) * 8,
                                        color: sparkColor,

                                        // ★ここを修正：0.2だと薄すぎるので、0.8～1.2程度にする
                                        life: 0.8 + Math.random() * 0.4,

                                        size: 2.0 // ★少し大きくして視認性アップ
                                    });
                                }
                            }
                        }
                    }
                });
            });
            bullets = bullets.filter(b => b.life > 0);
        }

        function updateLasers() {
            lasers.forEach(l => {
                l.life--;
                const maxLen = 2000;
                let currentLen = maxLen; // デフォルトの長さ

                const cos = Math.cos(l.angle);
                const sin = Math.sin(l.angle);

                // --- ★追加：壁との交差判定（壁で止める処理） ---
                const min = WALL_MARGIN;
                const max = worldSize - WALL_MARGIN;

                // 1. X方向の壁（左右）までの距離を計算
                // cosがプラスなら右壁(max)、マイナスなら左壁(min)を見る
                let distX = Infinity;
                if (cos !== 0) {
                    distX = (cos > 0 ? max - l.x : min - l.x) / cos;
                }

                // 2. Y方向の壁（上下）までの距離を計算
                // sinがプラスなら下壁(max)、マイナスなら上壁(min)を見る
                let distY = Infinity;
                if (sin !== 0) {
                    distY = (sin > 0 ? max - l.y : min - l.y) / sin;
                }

                // 3. 近い方の壁までの距離を採用
                const distToWall = Math.min(distX, distY);

                // 4. 壁が射程より近ければ、そこでレーザーを止める
                if (distToWall < currentLen) {
                    currentLen = distToWall;

                    // 壁に当たった地点でエフェクト発生
                    const hitX = l.x + cos * currentLen;
                    const hitY = l.y + sin * currentLen;
                    createWallImpact(hitX, hitY, '#0ff'); // シアン色の火花
                }
                // ------------------------------------------

                const p1x = l.x;
                const p1y = l.y;

                // 5. 敵との衝突判定（壁より手前に敵がいればさらに短くなる）
                enemies.forEach(e => {
                    const dx = e.x - p1x;
                    const dy = e.y - p1y;
                    const distToEnemy = Math.hypot(dx, dy);

                    // 敵の方向とレーザーの方向が一致しているか
                    const angleToEnemy = Math.atan2(dy, dx);
                    let diff = Math.abs(l.angle - angleToEnemy);
                    if (diff > Math.PI) diff = Math.PI * 2 - diff;

                    // 角度が近く、かつ現在の長さ（壁までの距離含む）より近い場合
                    if (diff < 0.2 && distToEnemy < currentLen) { // ★修正: maxLenではなくcurrentLenと比較
                        const hitRadius = (e.type === 'boss' ? 45 : 15) * e.scale;

                        // BOSSの場合はレーザーを遮断（長さを更新）
                        if (e.type === 'boss') {
                            currentLen = Math.min(currentLen, distToEnemy);
                            e.flashTimer = 5;
                        }

                        // ダメージ処理
                        e.hp -= 0.5;
                        if (frame % 2 === 0) {
                            createExplosion(e.x, e.y, e.color, 2);
                            // ヒット地点のエフェクト
                            const hitX = p1x + Math.cos(l.angle) * distToEnemy;
                            const hitY = p1y + Math.sin(l.angle) * distToEnemy;
                            particles.push({
                                x: hitX, y: hitY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                color: '#fff', life: 0.2, size: 2
                            });
                        }
                    }
                });

                // 6. 最終的な描画長さを保存
                l.renderLen = currentLen;

                // 7. 敵弾の消去判定（既存のまま）
                enemyBullets.forEach(eb => {
                    const A = p1x - (p1x + cos * currentLen);
                    const B = p1y - (p1y + sin * currentLen);
                    const C = (p1x + cos * currentLen) * p1y - p1x * (p1y + sin * currentLen);
                    const dist = Math.abs(A * eb.y - B * eb.x + C) / (Math.hypot(A, B) || 1);
                    const dot = (eb.x - p1x) * cos + (eb.y - p1y) * sin;

                    if (dist < (l.width / 2 + 5) && dot > 0 && dot < currentLen) {
                        eb.life = 0;
                        score += 10;
                    }
                });
            });
            lasers = lasers.filter(l => l.life > 0);
        }

        function updateEnemyBullets() {
            // ステージごとの弾速上昇率を計算
            const bulletStageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.BULLET_SPEED_INC;

            enemyBullets.forEach(eb => {
                const oldX = eb.x;
                const oldY = eb.y;

                // 1. 移動処理
                eb.x += eb.vx;
                eb.y += eb.vy;
                eb.life--;

                // --- ★追加：ワールド境界との衝突判定 ---
                // WALL_MARGINは画面端の余裕。worldSizeはエリアの最大値
                if (eb.x < WALL_MARGIN || eb.x > worldSize - WALL_MARGIN ||
                    eb.y < WALL_MARGIN || eb.y > worldSize - WALL_MARGIN) {

                    // 当たった座標をクランプして特定
                    const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, eb.x));
                    const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, eb.y));

                    if (eb.isMissile) {
                        // ミサイルは壁でドゴォンと爆発
                        createExplosion(impactX, impactY, eb.color, 12);
                        AudioSys.playSE('explode');
                        distortGrid(impactX, impactY, 20, 40); // グリッドを少し歪ませる
                    } else {
                        // 通常弾はパチッと火花
                        createWallImpact(impactX, impactY, eb.color || '#f00');
                    }
                    eb.life = 0; // 弾を消滅させる
                    return; // この弾の以降の処理（当たり判定等）をスキップ
                }

                // ミサイルの挙動制御
                if (eb.isMissile && eb.life > 0) {
                    // 初速の減衰
                    eb.vx *= 0.96;
                    eb.vy *= 0.96;

                    const dx = player.x - eb.x;
                    const dy = player.y - eb.y;
                    const dist = Math.hypot(dx, dy) || 0.001;

                    // 追尾力の適用
                    eb.vx += (dx / dist) * 0.25 * SPEED_SCALE;
                    eb.vy += (dy / dist) * 0.25 * SPEED_SCALE;

                    // 巡航速度の制限
                    const v = Math.hypot(eb.vx, eb.vy);
                    const cruiseSpeed = ENEMY_SPEEDS.BOSS_MISSILE * SPEED_SCALE * bulletStageMag;
                    if (v > cruiseSpeed) {
                        eb.vx = (eb.vx / v) * (v * 0.9 + cruiseSpeed * 0.1);
                        eb.vy = (eb.vy / v) * (v * 0.9 + cruiseSpeed * 0.1);
                    }

                    // 煙演出
                    if (frame % 2 === 0) {
                        particles.push({
                            x: eb.x, y: eb.y,
                            vx: -eb.vx * 0.2, vy: -eb.vy * 0.2,
                            color: eb.color, life: 0.3, size: 1.5
                        });
                    }

                    // プレイヤーの弾との当たり判定（既存）
                    bullets.forEach(b => {
                        if (b.life > 0 && Math.hypot(b.x - eb.x, b.y - eb.y) < 20) {
                            eb.life = 0; b.life = 0;
                            score += 50;
                            createExplosion(eb.x, eb.y, eb.color, 15);
                            AudioSys.playSE('explode');
                        }
                    });
                }

                // --- プレイヤーとの判定処理 (既存ロジック) ---
                if (eb.life > 0 && gameState !== 'DYING' && player.invuln <= 0) {
                    const dx = eb.x - oldX;
                    const dy = eb.y - oldY;
                    const t = ((player.x - oldX) * dx + (player.y - oldY) * dy) / (dx * dx + dy * dy || 1);
                    const closestT = Math.max(0, Math.min(1, t));
                    const closestX = oldX + closestT * dx;
                    const closestY = oldY + closestT * dy;

                    const dist = Math.hypot(player.x - closestX, player.y - closestY);
                    const hitboxSize = eb.isMissile ? ENEMY_HITBOX.BULLET * 1.5 : ENEMY_HITBOX.BULLET;

                    if (dist < hitboxSize) {
                        eb.life = 0;
                        createExplosion(player.x, player.y, eb.color || '#f00', 10);
                        damage(15);
                    }
                }
            });

            // 寿命切れや激突した弾を削除
            enemyBullets = enemyBullets.filter(eb => eb.life > 0);
        }

        function updateMissiles() {
            // missiles配列がない場合は何もしない
            if (typeof missiles === 'undefined') return;

            missiles.forEach(m => {
                // --- 1. ターゲット探索 ---
                if (!m.target || !enemies.includes(m.target)) {
                    let min = 9999;
                    enemies.forEach(e => {
                        if (e.hp > 0) { // 生きている敵だけ対象
                            const d = Math.hypot(e.x - m.x, e.y - m.y);
                            if (d < min) { min = d; m.target = e; }
                        }
                    });
                }

                // --- 2. 誘導（ホーミング） ---
                const scale = (typeof SPEED_SCALE !== 'undefined') ? SPEED_SCALE : 0.25;

                if (m.target) {
                    const ta = Math.atan2(m.target.y - m.y, m.target.x - m.x);
                    // 旋回力にも SCALE を適用
                    m.vx += Math.cos(ta) * 0.5 * scale;
                    m.vy += Math.sin(ta) * 0.5 * scale;
                }

                // --- 3. 速度制限と更新 ---
                const s = Math.hypot(m.vx, m.vy);
                if (s > 0.001) {
                    // m.speed は生成時に scale 済みなのでそのまま使う
                    m.vx = (m.vx / s) * m.speed;
                    m.vy = (m.vy / s) * m.speed;
                }

                // 移動
                m.x += m.vx;
                m.y += m.vy;
                m.life--;

                // --- 4. 壁衝突判定 ---
                if (m.x < WALL_MARGIN || m.x > worldSize - WALL_MARGIN ||
                    m.y < WALL_MARGIN || m.y > worldSize - WALL_MARGIN) {

                    // 壁に当たったら爆発
                    if (typeof createExplosion === 'function') {
                        const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, m.x));
                        const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, m.y));
                        createExplosion(impactX, impactY, '#fd0', 10);
                    }
                    if (AudioSys) AudioSys.playSE('explode');
                    m.life = 0;
                    return;
                }

                // --- 5. 敵との衝突判定 ---
                enemies.forEach(e => {
                    if (e.hp <= 0) return;
                    const hitRadius = (e.type === 'asteroid' ? 25 * e.scale : 30);

                    if (Math.hypot(e.x - m.x, e.y - m.y) < hitRadius) {
                        e.hp -= 15;
                        m.life = 0;
                        if (typeof createExplosion === 'function') createExplosion(m.x, m.y, '#fd0', 8);
                        if (AudioSys) AudioSys.playSE('explode');
                        if (typeof distortGrid === 'function') distortGrid(m.x, m.y, 20, 50);
                    }
                });

                // --- 6. 軌跡パーティクル ---
                if (frame % 2 === 0 && typeof particles !== 'undefined') {
                    particles.push({
                        x: m.x, y: m.y,
                        vx: (Math.random() - 0.5) * scale,
                        vy: (Math.random() - 0.5) * scale,
                        color: '#fd0', life: 0.3, size: 2 * G_SCALE
                    });
                }
            });

            // 寿命切れを削除
            missiles = missiles.filter(m => m.life > 0);
        }

        function updateCrystals() {
            crystals.forEach(c => {
                c.life--;

                // --- 1. 初速（飛び散り）の適用 ---
                // destroyEnemyで設定された vx, vy があれば使用します
                // 0.95 を掛けることで、飛び散った勢いが徐々に弱まる（摩擦）表現になります
                c.vx = (c.vx || 0) * 0.95;
                c.vy = (c.vy || 0) * 0.95;

                // 初速にも SPEED_SCALE を適用して移動させる
                c.x += c.vx * SPEED_SCALE;
                c.y += c.vy * SPEED_SCALE;

                // --- 2. 自機への吸い寄せ（マグネット） ---
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const dist = Math.hypot(dx, dy) || 0.0001;

                // 吸い寄せスピード計算に SPEED_SCALE を適用
                // ベース速度(10.0) + 距離による加速(0.08)
                // これにより、遠くにあるときは高速で、近くでも適度な速さで吸い寄せられます
                const pullSpeed = (10.0 + (dist * 0.08)) * SPEED_SCALE;

                const moveAmount = Math.min(dist, pullSpeed);

                c.x += (dx / dist) * moveAmount;
                c.y += (dy / dist) * moveAmount;

                // --- 3. 回収判定 ---
                if (dist < 30) { // 判定距離（少し広めに30px）
                    c.life = 0;

                    // 衛星（サテライト）追加ロジック
                    if (player.satellites.length < 12) {
                        // 初期座標と角度を持たせて push
                        player.satellites.push({
                            x: player.x,
                            y: player.y,
                            angle: Math.random() * Math.PI * 2
                        });
                    }
                }
            });

            // 寿命切れを削除
            crystals = crystals.filter(c => c.life > 0);
        }

        function updatePowerups() {
            powerups.forEach(p => {
                // --- 1. 消失防止と寿命の更新 ---
                // レベルアップアイテム以外は寿命を減らす
                if (p.type !== 'level') {
                    p.life--;
                }

                // 自機との距離と方向ベクトルを計算
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.hypot(dx, dy) || 0.001;

                // --- 2. レベルアップアイテム専用：吸い寄せロジック ---
                if (p.type === 'level') {
                    // 遠くても確実に自機へ向かう（距離に応じた加速）
                    const pullSpeed = (2.0 + (dist * 0.04)) * SPEED_SCALE;
                    const moveAmount = Math.min(dist, pullSpeed);

                    p.x += (dx / dist) * moveAmount;
                    p.y += (dy / dist) * moveAmount;

                    // 飛んでいる間、キラキラしたパーティクルを出す演出
                    if (frame % 3 === 0) {
                        particles.push({
                            x: p.x, y: p.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#0f8', life: 0.3, size: 1.5
                        });
                    }
                }

                // --- 3. 回収判定 ---
                if (dist < 30) {
                    p.life = 0;
                    AudioSys.playSE('powerup');

                    if (p.type === 'laser') {
                        player.laserTimer = LASER_DURATION;
                        rings.push({ x: player.x, y: player.y, r: 10, color: '#0ff', life: 1 });
                        rings.push({ x: player.x, y: player.y, r: 50, color: '#0ff', life: 1 });
                    }
                    else if (p.type === 'invincible') {
                        player.invuln = 600;
                        AudioSys.playSE('invincible');
                    }
                    else if (p.type === 'level') {
                        player.weaponLevel = Math.min(MAX_WEAPON_LEVEL, player.weaponLevel + 1);
                        // スコアポップアップと同じ仕組みで「LEVEL UP!」と表示
                        scorePopups.push({
                            x: player.x,
                            y: player.y - 20,
                            text: "LEVEL UP!",
                            life: 60, alpha: 1, vy: -1.2
                        });
                    }
                    else if (p.type === 'shield') {
                        // 10ポイント回復（上限100を超えないように）
                        player.shield = Math.min(100, player.shield + 10);

                        // バーの表示更新
                        ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                        if (player.shield < 30) ui.shieldBar.classList.add('shield-critical');
                        else ui.shieldBar.classList.remove('shield-critical');
                        if (ui.shieldVal) ui.shieldVal.innerText = Math.floor(player.shield);

                        // ポップアップ表示
                        scorePopups.push({
                            x: player.x,
                            y: player.y - 20,
                            text: "SHIELD +10",
                            life: 60, alpha: 1, vy: -1.2
                        });
                    }
                }
            });
            // 取得済み(life=0)または時間切れのものを削除
            powerups = powerups.filter(p => p.life > 0);
        }

        function updateScorePopups() { scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; }); scorePopups = scorePopups.filter(s => s.life > 0); }

        function updateParticlesAndRings() {
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.vy += 0.005; p.life -= 0.02; });
            particles = particles.filter(p => p.life > 0);
            rings.forEach(r => { r.r += 2; r.life -= 0.02; });
            rings = rings.filter(r => r.life > 0);
        }

        function updateGrid() {
            // スクロール時の乱れを防ぐため、計算バッファ（10）を追加
            const buffer = 10;
            const startX = Math.max(0, Math.floor(camera.x / GRID_SPACING) - buffer);
            const endX = Math.min(gridPoints.length - 1, Math.ceil((camera.x + width) / GRID_SPACING) + buffer);
            const startY = Math.max(0, Math.floor(camera.y / GRID_SPACING) - buffer);
            const endY = Math.min(gridPoints[0].length - 1, Math.ceil((camera.y + height) / GRID_SPACING) + buffer);

            for (let i = startX; i <= endX; i++) {
                for (let j = startY; j <= endY; j++) {
                    const p = gridPoints[i][j];
                    const dx = p.x - p.ox, dy = p.y - p.oy;

                    // バネの復元力
                    const dist = Math.hypot(dx, dy);
                    if (dist > 0.1) {
                        const f = -0.12 * dist;
                        const ang = Math.atan2(dy, dx);
                        p.vx += Math.cos(ang) * f;
                        p.vy += Math.sin(ang) * f;
                    }

                    p.vx *= 0.85;
                    p.vy *= 0.85;

                    // 停止判定
                    if (Math.abs(p.vx) < 0.01 && Math.abs(p.vy) < 0.01 && dist < 0.1) {
                        p.x = p.ox; p.y = p.oy;
                        p.vx = 0; p.vy = 0;
                    } else {
                        p.x += p.vx;
                        p.y += p.vy;
                    }
                }
            }
        }

        function distortGrid(x, y, force, radius) {
            const cx = Math.floor(x / GRID_SPACING), cy = Math.floor(y / GRID_SPACING), r = Math.ceil(radius / GRID_SPACING);
            for (let i = Math.max(0, cx - r); i < Math.min(gridPoints.length, cx + r); i++) for (let j = Math.max(0, cy - r); j < Math.min(gridPoints[0].length, cy + r); j++) {
                const p = gridPoints[i][j], d = Math.hypot(p.x - x, p.y - y);
                if (d < radius) { const f = force * (1 - d / radius), a = Math.atan2(p.y - y, p.x - x); p.vx += Math.cos(a) * f; p.vy += Math.sin(a) * f; }
            }
        }

        // =========================================================
        // 10. 描画システム (Rendering Systems)
        // =========================================================
        function draw() {
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const sx = (s.x - camera.x * s.parallax) % worldSize; const sy = (s.y - camera.y * s.parallax) % worldSize;
                const dx = (sx + worldSize) % worldSize; const dy = (sy + worldSize) % worldSize;
                ctx.globalAlpha = s.brightness; ctx.beginPath(); ctx.arc(dx, dy, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            ctx.save(); ctx.beginPath(); ctx.rect(0, 0, worldSize, worldSize); ctx.clip();

            ctx.strokeStyle = 'rgba(0, 150, 255, 0.3)'; // 水色(0,150,255)で透明度0.15。かなり薄くなります。
            ctx.lineWidth = 1; // 線自体も少し細くすると繊細になります
            ctx.shadowBlur = 5;  // 光彩を抑える（以前は15）
            ctx.shadowColor = '#08f';

            ctx.beginPath();
            const viewX = camera.x; const viewY = camera.y; const viewW = width; const viewH = height;
            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j]; if (!p) continue;
                if (p.x < viewX - 50 || p.x > viewX + viewW + 50 || p.y < viewY - 50 || p.y > viewY + viewH + 50) continue;
                if (i > 0 && gridPoints[i - 1] && gridPoints[i - 1][j]) { ctx.moveTo(gridPoints[i - 1][j].x, gridPoints[i - 1][j].y); ctx.lineTo(p.x, p.y); }
                if (j > 0 && gridPoints[i][j - 1]) { ctx.moveTo(gridPoints[i][j - 1].x, gridPoints[i][j - 1].y); ctx.lineTo(p.x, p.y); }
            }
            ctx.stroke(); ctx.shadowBlur = 0; ctx.restore();

            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, worldSize - WALL_MARGIN * 2, worldSize - WALL_MARGIN * 2);

            wormholes.forEach(w => {
                if (w.active || w.life > -60) {
                    let scale = 1; if (w.life > 300) scale = (400 - w.life) / 100; else if (w.life <= 0) scale = Math.max(0, (60 + w.life) / 60);
                    ctx.save(); ctx.translate(w.x, w.y); ctx.scale(scale, scale);
                    ctx.shadowBlur = 30; ctx.shadowColor = '#20f';
                    const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.2, '#000'); grad.addColorStop(0.8, '#000'); grad.addColorStop(1, '#0ff');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 20 + Math.sin(frame * 0.1) * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, 35 + Math.cos(frame * 0.05) * 5, 0, Math.PI * 2); ctx.stroke();
                    ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(5, 5); ctx.stroke();
                    ctx.restore();
                }
            });

            enemies.forEach(e => {
                ctx.save(); // 個別にsave/restoreすることで透明度の影響を防ぐ

                // 出現演出中の透明度を適用
                if (e.isWarping) {
                    ctx.globalAlpha = e.warpPercent || 0;
                } else {
                    ctx.globalAlpha = 1.0;
                }

                if (e.type === 'dragon') drawDragonEnemy(ctx, e);
                else if (e.type === 'triangle') drawTriangleEnemy(ctx, e);
                else if (e.type === 'cube') drawCubeEnemy(ctx, e);
                else if (e.type === 'tadpole') drawTadpoleEnemy(ctx, e);
                else if (e.type === 'boss') drawBossEnemy(ctx, e);
                else if (e.type === 'asteroid') drawAsteroidEnemy(ctx, e);
                else if (e.type === 'hunter') drawHunterEnemy(ctx, e);

                ctx.restore();
            });

            // 敵の弾の描画ループ
            enemyBullets.forEach(eb => {
                ctx.save();
                ctx.translate(eb.x, eb.y);

                // ミサイルか通常の弾かで描画関数を切り替える
                if (eb.isMissile) {
                    drawHomingMissile(ctx, eb);
                } else {
                    drawNormalBullet(ctx, eb);
                }

                ctx.restore();
            });

            ctx.shadowBlur = 0;

            if (gameState === 'PLAYING') {
                // --- 残像（トレイル）の描画処理 ---
                player.history.forEach((pos, i) => {
                    // i=0 は現在の自機と同じ位置なのでスキップ
                    if (i === 0) return;

                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(pos.angle);
                    ctx.scale(G_SCALE, G_SCALE);

                    // 配列の後ろに行くほど（古いほど）透明にする
                    const alpha = 0.4 * (1 - i / player.history.length);
                    ctx.globalAlpha = alpha;

                    // 残像の色を状態に合わせて設定
                    let trailColor = '#0f8';
                    if (player.invuln > 0) trailColor = '#ff0';
                    else if (player.laserTimer > 0) trailColor = '#0ff';

                    ctx.strokeStyle = trailColor;
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = trailColor;

                    // 自機の形を描画（本体より少し簡略化してもOK）
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(-5, 0);
                    ctx.lineTo(-10, -10);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                });

                // 1. 最大レベルなら碧き不死鳥を纏う
                if (player.weaponLevel >= MAX_WEAPON_LEVEL - 1) {
                    drawEmeraldPhoenix(ctx, player);
                }

                // 2. 無敵状態ならバリアを展開する
                if (player.invuln > 0) {
                    drawInvulnBarrier(ctx, player);
                }

                // --- 自機本体（レイヤー上層） ---
                drawPlayer(ctx, player);
            }

            drawLasers();
            ctx.fillStyle = '#0f8'; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); ctx.fill(); });

            // --- 1. クリスタルの描画（暗い緑） ---
            ctx.fillStyle = '#008000'; // Dark Green
            crystals.forEach(c => {
                ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(frame * 0.1);
                const scale = c.life > 60 ? 1 : c.life / 60; ctx.scale(scale, scale);
                // 形状はひし形のまま
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill();

                // もし「C」という文字にしたい場合は上記2行を消して以下を使ってください
                // ctx.fillStyle = '#008000'; ctx.font = '10px monospace'; ctx.fillText('C', 0, 0);

                ctx.restore();
            });

            // --- 2. パワーアップアイテムの描画（指定の文字と色） ---
            powerups.forEach(p => {
                let char = '?';
                let color = '#fff';

                // タイプごとの色と文字の設定
                if (p.type === 'laser') {
                    color = '#aff'; // Laser: 青
                    char = 'L';
                } else if (p.type === 'level') {
                    color = '#0f0'; // Level Up: 明るい緑
                    char = 'W';     // Weapon? Shot? (W指定)
                } else if (p.type === 'invincible') {
                    color = '#ff0'; // Invincible: 黄
                    char = 'I';
                } else if (p.type === 'shield') {
                    color = '#0ff'; // Shield: 青（少し濃い目にして区別）
                    char = 'S';
                }

                ctx.strokeStyle = color;

                ctx.save();
                ctx.translate(p.x, p.y);
                const scale = p.life > 60 ? 1 : p.life / 60;
                ctx.scale(scale, scale);

                // 枠線の描画
                ctx.lineWidth = 2;
                ctx.strokeRect(-8, -8, 16, 16);

                // 文字の描画
                ctx.fillStyle = color;
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(char, 0, 0);

                ctx.restore();
            });

            ctx.fillStyle = '#fd0'; missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });

            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = Math.min(1, p.life);
                ctx.beginPath(); const length = 4.0; ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * length, p.y - p.vy * length);
                ctx.lineWidth = p.size || 2; ctx.strokeStyle = p.color; ctx.lineCap = 'round'; ctx.stroke();
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;

            rings.forEach(r => { ctx.strokeStyle = r.color; ctx.lineWidth = 3; ctx.globalAlpha = r.life; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1.0; });

            // カメラリセット後に描画することで、画面上の固定位置（左上）に表示される
            if (gameState === 'PLAYING' || gameState === 'DYING') {
                drawMiniMap();
            }

            drawScorePopups(); ctx.restore();
        }

        // player
        function drawPlayer(ctx, p) {
            // --- 1. 自機本体の描画 ---
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            ctx.scale(G_SCALE, G_SCALE);

            // 状態に応じた機体色の決定
            let shipColor = '#0f8';
            if (p.invuln > 0) shipColor = '#ff0';
            else if (p.laserTimer > 0) shipColor = '#0ff';

            ctx.strokeStyle = shipColor;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = shipColor;

            // 機体の形状パス
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
            ctx.closePath();

            // ウィング部分の装飾ライン
            ctx.moveTo(-5, 0);
            ctx.lineTo(-15, 15);
            ctx.moveTo(-5, 0);
            ctx.lineTo(-15, -15);

            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0; // シャドウをリセット

            // --- 2. サテライト（衛星）の描画 ---
            p.satellites.forEach(s => {
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(s.x, s.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawInvulnBarrier(ctx, p) {
            ctx.save();
            ctx.translate(p.x, p.y);

            const bRadius = 45 * G_SCALE;
            // バリア全体の「呼吸」のようなパルス
            const pulse = Math.sin(frame * 0.1) * 3;
            const r = bRadius + pulse;

            // 基本カラー設定
            ctx.strokeStyle = '#ff0';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff0';
            ctx.lineWidth = 1.5;
            ctx.globalCompositeOperation = 'lighter'; // 光を重ねる

            // --- 1. 球体を構成する3つの回転リングを描画 ---
            // 3つの円を角度を変えて配置し、それぞれを「押しつぶす(scale)」ことで回転を表現
            for (let i = 0; i < 3; i++) {
                ctx.save();

                // リングごとの角度ズレ（0度, 60度, 120度）
                ctx.rotate((Math.PI / 3) * i);

                // 擬似3D回転：Y軸方向のスケールを -1 ～ 1 の間で往復させる
                // i * 2 を足すことで、リングごとに回転のタイミングをずらす
                const scaleY = Math.sin(frame * 0.05 + i * 2);
                ctx.scale(1, scaleY);

                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            // --- 2. 輪郭の薄い円（球体の外郭） ---
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // --- 3. 内部の薄い塗りつぶし ---
            ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
            ctx.fill();
            ctx.globalAlpha = 1.0;

            ctx.restore();

            // --- 4. バリアから漏れ出るエネルギー粒子 ---
            if (frame % 2 === 0) {
                particles.push({
                    x: p.x + (Math.random() - 0.5) * 60,
                    y: p.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: '#ff0',
                    life: 0.3,
                    size: 1
                });
            }
        }

        function drawEmeraldPhoenix(ctx, p) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);

            // カラー設定：エメラルドグリーンとシアン
            const wingColor = '#0f8';
            const highlightColor = '#0ff';

            ctx.shadowBlur = 20;
            ctx.shadowColor = wingColor;
            ctx.globalCompositeOperation = 'lighter';

            // 1. 揺らめく緑の翼
            const wingFlap = Math.sin(frame * 0.15) * 15;
            ctx.lineWidth = 2;
            ctx.strokeStyle = wingColor;

            for (let side of [-1, 1]) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    -10 * G_SCALE, side * (30 + wingFlap) * G_SCALE,
                    -40 * G_SCALE, side * (40 + wingFlap) * G_SCALE,
                    -20 * G_SCALE, side * 5 * G_SCALE
                );
                ctx.stroke();

                // 翼内の水色ハイライト
                ctx.save();
                ctx.strokeStyle = highlightColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.moveTo(-5 * G_SCALE, side * 5 * G_SCALE);
                ctx.lineTo(-25 * G_SCALE, side * (25 + wingFlap) * G_SCALE);
                ctx.stroke();
                ctx.restore();
            }

            // 2. 輝く3本の尾羽
            for (let i = 0; i < 3; i++) {
                const tailOff = Math.sin(frame * 0.2 + i) * 10;
                ctx.beginPath();
                ctx.strokeStyle = i === 1 ? highlightColor : wingColor;
                ctx.lineWidth = 3 - i;
                ctx.moveTo(-10 * G_SCALE, (i - 1) * 5 * G_SCALE);
                ctx.quadraticCurveTo(
                    -40 * G_SCALE, tailOff * G_SCALE,
                    -60 * G_SCALE, (tailOff + (i - 1) * 10) * G_SCALE
                );
                ctx.stroke();
            }

            // 3. 頭部の鋭い光（嘴）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(22 * G_SCALE, 0, 3 * G_SCALE, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';

            // 4. 羽毛パーティクルの生成
            if (frame % 2 === 0) {
                const pAngle = p.angle + Math.PI + (Math.random() - 0.5);
                const pSpeed = 2 + Math.random() * 4;
                particles.push({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(pAngle) * pSpeed,
                    vy: Math.sin(pAngle) * pSpeed,
                    color: Math.random() > 0.5 ? wingColor : highlightColor,
                    life: 0.6,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function drawLasers() {
            lasers.forEach(l => {
                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.angle);
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 1.5;

                // 修正：固定値 2000 ではなく、計算された l.renderLen を使う
                const len = l.renderLen || 2000;

                const segments = 20;
                const segLen = len / segments;
                const jitter = 15 * (l.life / 5);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let i = 1; i <= segments; i++) {
                    const px = i * segLen;
                    const py = (Math.random() - 0.5) * jitter * 2;
                    ctx.lineTo(px, py);
                }
                ctx.stroke();

                // 芯の白い線
                if (Math.random() > 0.2) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(len, (Math.random() - 0.5) * 5);
                    ctx.stroke();
                }

                // ヒット地点の光（BOSSに当たっている時）
                if (len < 1900) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(len, 0, 10 + Math.random() * 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        // enemy
        function drawDragonEnemy(ctx, e) {
            // 全体サイズを1.2倍に
            const dragonScale = e.scale * G_SCALE;

            // --- 1. 胴体セグメント（コンテナブロック）の描画 ---
            for (let i = e.segments.length - 1; i >= 0; i--) {
                const s = e.segments[i];

                ctx.save();
                // ★修正：ワールド絶対座標 s.x, s.y を使用し、カメラの移動は draw ループ全体の translate で解決
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                ctx.scale(dragonScale, dragonScale);

                // 六角形コンテナ装甲
                const sizeMod = Math.max(0.6, 1 - (i * 0.08));
                const w = 12 * sizeMod;
                const h = 18 * sizeMod;

                ctx.strokeStyle = e.color;
                ctx.lineWidth = 3.5;
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';

                ctx.beginPath();
                ctx.moveTo(w, -h / 2);
                ctx.lineTo(w, h / 2);
                ctx.lineTo(-w * 0.9, h * 0.35); // 絞りの修正
                ctx.lineTo(-w * 0.9, -h * 0.35);
                ctx.closePath();

                ctx.fillStyle = 'rgba(20, 0, 0, 0.9)';
                ctx.fill();
                ctx.stroke();

                // フィン
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-w * 0.5, -h / 3); ctx.lineTo(w, -h / 3);
                ctx.moveTo(-w * 0.5, h / 3); ctx.lineTo(w, h / 3);
                ctx.stroke();

                ctx.restore();
            }

            // --- 2. 頭部ユニット ---
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(dragonScale, dragonScale);

            // メインヘッド
            ctx.fillStyle = '#300';
            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(-10, -12);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, 12);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 4;
            ctx.stroke();

            // センサーアイ：オレンジ色の点滅
            const blink = (Math.sin(frame * 0.15) * 0.5) + 0.5;
            const eyeColor = `rgb(255, ${128 + 127 * blink}, ${60 * blink})`;
            ctx.fillStyle = eyeColor;
            ctx.shadowBlur = 15 * blink;
            ctx.shadowColor = '#ff8800';
            ctx.beginPath();
            ctx.rect(5, -3, 8, 6);
            ctx.fill();
            ctx.shadowBlur = 0;

            // アンテナ
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, -10); ctx.lineTo(-15, -20);
            ctx.moveTo(-5, 10); ctx.lineTo(-15, 20);
            ctx.stroke();

            ctx.restore();
        }

        function drawTriangleEnemy(ctx, e) {
            // セーフガード: 万が一数値が異常な場合は描画をスキップ
            if (!e || typeof e.x !== 'number' || isNaN(e.x)) return;

            ctx.save();

            // --- 1. 座標とスケールの設定 ---
            ctx.translate(e.x, e.y);

            // 出現完了後は e.scale (0.7) に固定、出現中は 0.1 ～ 0.7 へ変化
            const currentScale = (e.scale || 0.7) * G_SCALE;
            ctx.scale(currentScale, currentScale);

            // --- 2. 出現演出用の透明度とグロー設定 ---
            // Warping中のみ warpPercent に依存させ、それ以外は不透明(1.0)にする
            const visualAlpha = e.isWarping ? (e.warpPercent || 0) : 1.0;
            ctx.globalAlpha = visualAlpha;

            // --- 3. ネオンカラー設定 ---
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = e.color || '#0ff';
            ctx.lineWidth = 3.5;

            // グロー効果（出現中は控えめから徐々に強く）
            ctx.shadowBlur = e.isWarping ? (5 + visualAlpha * 20) : 25;
            ctx.shadowColor = e.color || '#0ff';

            // --- 4. 3D形状（正四面体：テトラヒドロン）の計算 ---
            const size = 15;
            const pts = [
                { x: 1, y: 1, z: 1 },
                { x: -1, y: -1, z: 1 },
                { x: -1, y: 1, z: -1 },
                { x: 1, y: -1, z: -1 }
            ];

            // 回転速度の適用（e.rotX 等が更新されている前提）
            const cosX = Math.cos(e.rotX || 0), sinX = Math.sin(e.rotX || 0);
            const cosY = Math.cos(e.rotY || 0), sinY = Math.sin(e.rotY || 0);
            const cosZ = Math.cos(e.rotZ || 0), sinZ = Math.sin(e.rotZ || 0);

            const proj = pts.map(p => {
                // 3D回転行列計算
                let y1 = p.y * cosX - p.z * sinX;
                let z1 = p.y * sinX + p.z * cosX;
                let x2 = p.x * cosY + z1 * sinY;
                let z2 = -p.x * sinY + z1 * cosY;
                let x3 = x2 * cosZ - y1 * sinZ;
                let y3 = x2 * sinZ + y1 * cosZ;
                return { x: x3 * size, y: y3 * size };
            });

            const lines = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]];

            // 外殻ワイヤーフレームの描画
            ctx.beginPath();
            lines.forEach(l => {
                ctx.moveTo(proj[l[0]].x, proj[l[0]].y);
                ctx.lineTo(proj[l[1]].x, proj[l[1]].y);
            });
            ctx.stroke();

            // --- 5. 中心の白いコア ---
            // コア自体に個別の透明度設定を上書きしないよう、save/restore内で計算
            ctx.save();
            // コアは本体よりも少しだけ明るく強調
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#fff";
            ctx.fillStyle = "#fff";
            // globalAlphaは親（visualAlpha）を引き継ぐ
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.restore();

            // globalCompositeOperationを元に戻す（重要）
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawCubeEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // --- 1. アイテムの種類に応じたコアの色設定 ---
            let coreColor = '#ff0'; // デフォルト（クリスタル/なし）：黄
            if (e.drop === 'laser') coreColor = '#0ff';      // レーザー：シアン
            if (e.drop === 'level') coreColor = '#0f0';      // レベルアップ：緑
            if (e.drop === 'invincible') coreColor = '#fff'; // 無敵：白

            // 点滅演出
            const pulse = (Math.sin(frame * 0.15) * 0.5) + 0.5;
            const coreSize = 6 + pulse * 4;

            ctx.shadowBlur = 15 + pulse * 10;
            ctx.shadowColor = coreColor;

            // コアの外光（パルスに合わせて透明度変化）
            const rgb = coreColor === '#ff0' ? '255, 255, 0' :
                coreColor === '#0ff' ? '0, 255, 255' :
                    coreColor === '#0f0' ? '0, 255, 0' : '255, 255, 255';

            ctx.fillStyle = `rgba(${rgb}, ${0.4 + pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();

            // コアの中心（高輝度）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. 外殻のワイヤーフレーム (緑色で固定) ---
            ctx.shadowBlur = 5;
            ctx.shadowColor = e.color;
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 1.5;

            const size = 16;
            const pts = [
                { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 },
                { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
                { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
            ];

            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX);
            const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY);

            const proj = pts.map(p => {
                let y = p.y * cosX - p.z * sinX;
                let z = p.y * sinX + p.z * cosX;
                let x = p.x * cosY + z * sinY;
                return { x: x * size, y: y * size };
            });

            const lines = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            ctx.beginPath();
            lines.forEach(l => {
                ctx.moveTo(proj[l[0]].x, proj[l[0]].y);
                ctx.lineTo(proj[l[1]].x, proj[l[1]].y);
            });
            ctx.stroke();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawHunterEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // 射撃予備動作中はより強く光る
            const isAiming = (e.state === 'aim');

            // --- カラー定義 ---
            // 中心のハイライト色（通常は黄色っぽく、狙うと白っぽく）
            const coreColor = isAiming ? '#FFFFDD' : '#FFD700'; // Gold
            // ベースとなる明るいオレンジ
            const baseColor = '#FF8C00'; // DarkOrange
            // 外側の影となる濃いオレンジ
            const edgeColor = '#BF3622'; // Deep Orange

            // 発光の色（周囲への照り返し）
            const glowColor = isAiming ? '#FFA500' : '#FF4500'; // Orange / OrangeRed

            // --- 本体の描画 ---

            // 1. 強烈なオレンジ色の発光を設定
            ctx.shadowBlur = isAiming ? 35 : 20;
            ctx.shadowColor = glowColor;

            // パスの定義（形状は元のまま）
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (Math.PI / 2) * i;
                // 外側の点
                ctx.lineTo(Math.cos(angle) * 15, Math.sin(angle) * 15);
                // 内側の点（くぼみ）
                ctx.lineTo(Math.cos(angle + 0.4) * 6, Math.sin(angle + 0.4) * 6);
                // 次の頂点の手前装飾
                ctx.lineTo(Math.cos(angle + 0.8) * 15, Math.sin(angle + 0.8) * 15);
            }
            ctx.closePath();

            // 2. 立体的なグラデーションで塗りつぶす
            // 中心から外側に向かう放射状グラデーション
            const bodyGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, 15);
            bodyGrad.addColorStop(0, coreColor);    // 中心：ハイライト
            bodyGrad.addColorStop(0.5, baseColor);  // 中間：ベース色
            bodyGrad.addColorStop(1, edgeColor);    // 外側：シェーディング

            ctx.fillStyle = bodyGrad;
            // 塗りつぶし時は、輪郭がぼやけすぎないよう影を一時的に弱める
            const currentShadowBlur = ctx.shadowBlur;
            ctx.shadowBlur = 5;
            ctx.fill();
            ctx.shadowBlur = currentShadowBlur; // 影を戻す

            // 3. 発光するワイヤーフレームで縁取り
            // 狙っている時は白く、通常は黄色い線で輪郭を強調
            ctx.strokeStyle = isAiming ? '#FFFFFF' : '#FFECB3';
            ctx.lineWidth = 2;
            ctx.stroke();

            // --- 中央の目 ---
            // 目も少し立体的に光らせる
            const eyeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
            if (isAiming) {
                // 狙っている時：赤く鋭く光る
                eyeGrad.addColorStop(0, '#FFEEEE');
                eyeGrad.addColorStop(0.5, '#FF0000');
                eyeGrad.addColorStop(1, '#8B0000');
            } else {
                // 通常時：暗く無機質に
                eyeGrad.addColorStop(0, '#555555');
                eyeGrad.addColorStop(1, '#000000');
            }
            ctx.fillStyle = eyeGrad;
            ctx.shadowBlur = 0; // 目はくっきりと
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // 目の縁取り
            ctx.strokeStyle = isAiming ? '#FF4444' : '#333333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // --- 狙っている時の照準線（レーザーサイト） ---
            if (isAiming) {
                // 本体の強い光に合わせてレーザーも強化
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#FF0000';

                ctx.globalAlpha = 0.8;
                // 根本が白く、先端に向かって赤く消えていくグラデーション
                const laserGrad = ctx.createLinearGradient(15, 0, 250, 0);
                laserGrad.addColorStop(0, '#FFFFFF');      // 根本は高エネルギー
                laserGrad.addColorStop(0.1, '#FF4500');    // すぐに赤熱
                laserGrad.addColorStop(1, 'rgba(255, 0, 0, 0)'); // 先端は消える

                ctx.strokeStyle = laserGrad;
                ctx.setLineDash([8, 4]); // 点線の間隔を少し広げる
                ctx.lineWidth = 2.5;     // 線を太く
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(250, 0); // 視線を少し長く
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawTadpoleEnemy(ctx, e) {
            ctx.save();

            // --- カラー設定：明るい水色（シアンネオン） ---
            const neonCyan = "#0ff";      // 鮮やかなシアン
            const lightCyan = "#ccffff";  // ハイライト用の白に近い青

            // --- 1. テイル（高速流動フラグメント）の描画 ---
            if (e.history.length > 1) {
                ctx.setLineDash([12, 18]);
                for (let i = 0; i < e.history.length - 1; i += 3) {
                    const p1 = e.history[i];
                    const p2 = e.history[i + 1];
                    if (!p2) break;

                    const ratio = i / e.history.length;
                    const alpha = (1 - ratio) * 0.6;

                    // 尾も水色のグラデーションに
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = (14 - ratio * 14) * G_SCALE;

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }

            // --- 2. 幾何学メカニカル・ヘッド（頭部）の描画 ---
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // 背景の遮蔽（より深い紺色で水色を引き立てる）
            ctx.fillStyle = 'rgba(0, 10, 20, 0.9)';
            ctx.beginPath();
            ctx.rect(-10, -15, 45, 30);
            ctx.fill();

            // ワイヤーフレームの設定
            ctx.strokeStyle = neonCyan;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = neonCyan;

            // --- メインボディ「＝＝＝」部分 ---
            for (let j = 0; j < 3; j++) {
                const xPos = j * 12;
                // シリンダーリング
                ctx.beginPath();
                ctx.ellipse(xPos, 0, 8, 15, 0, 0, Math.PI * 2);
                ctx.stroke();

                // 水平支柱（ハイライト色を混ぜる）
                ctx.save();
                ctx.strokeStyle = lightCyan;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(xPos, -15); ctx.lineTo(xPos + 12, -15);
                ctx.moveTo(xPos, 15); ctx.lineTo(xPos + 12, 15);
                ctx.stroke();
                ctx.restore();
            }

            // --- 先端ユニット「＜＜」部分 ---
            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.moveTo(35, -14); ctx.lineTo(52, 0); ctx.lineTo(35, 14); // 外側の ＜
            ctx.stroke();

            ctx.save();
            ctx.strokeStyle = lightCyan;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(25, -9); ctx.lineTo(42, 0); ctx.lineTo(25, 9);   // 内側の ＜
            ctx.stroke();
            ctx.restore();

            // --- コア・ユニット ---
            // 中心部で強く輝く水色のエネルギー体
            ctx.fillStyle = lightCyan;
            ctx.shadowBlur = 20;
            ctx.shadowColor = neonCyan;
            ctx.beginPath();
            ctx.rect(5, -4, 8, 8);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawAsteroidEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);

            // スケールを適用
            const s = e.scale * G_SCALE;
            ctx.scale(s, s);

            // ネオンホワイトのワイヤーフレーム設定
            ctx.strokeStyle = '#fff';

            // ★ポイント: 小さくなっても線の太さを維持する計算
            // スケール s で割ることで、画面上の見た目の太さを常に一定（約1.5px）に保ちます
            ctx.lineWidth = 1.5 / s;

            ctx.shadowBlur = 12 / s; // 発光もスケールに合わせて調整
            ctx.shadowColor = '#fff';

            ctx.beginPath();
            // 岩の形状（e.sizeをシードにして形状を固定）
            for (let i = 0; i < 8; i++) {
                const r = 22 * (0.8 + Math.sin(i * 2.1 + e.size * 5) * 0.25);
                const ang = (Math.PI * 2 / 8) * i;
                const tx = Math.cos(ang) * r;
                const ty = Math.sin(ang) * r;
                if (i === 0) ctx.moveTo(tx, ty); else ctx.lineTo(tx, ty);
            }
            ctx.closePath();
            ctx.stroke();

            // 内部の亀裂（これも線の太さを維持）
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.moveTo(-10, -5); ctx.lineTo(5, 8);
            ctx.stroke();

            ctx.restore();
        }

        function drawBossEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            // --- ★修正：シンプルな出現演出（ズームイン ＆ フェードイン） ---
            if (e.isSpawning) {
                // 進行度 (0.0 → 1.0)
                const t = e.spawnTimer / e.spawnMax;

                // イージング関数（動きに緩急をつける）
                // 最初は速く、最後はゆっくり定着する "EaseOutCubic" 計算
                const easeOut = 1 - Math.pow(1 - t, 3);

                // 1. フェードイン（徐々に不透明に）
                ctx.globalAlpha = t;

                // 2. ズームイン（拡大）
                // 0倍からスタートすると見えにくいので、0.1倍から1.0倍へ拡大
                const zoom = 0.1 + (0.9 * easeOut);
                ctx.scale(zoom, zoom);

                // 3. 転送光（出現中は白くぼんやり光らせる）
                ctx.shadowBlur = 50 * (1 - easeOut); // 出現完了に近づくほど光が収まる
                ctx.shadowColor = '#fff';

                // 実体化中は少しだけ明るく描画
                ctx.globalCompositeOperation = 'lighter';
            }
            // ----------------------------

            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // --- 1. カラー・設定の構築 ---
            const isDmg = e.flashTimer > 0;
            if (isDmg) e.flashTimer--;

            // 基本の色
            const baseColor = e.color;
            // 「色味のある白（城）」: HSLを使って明度(L)だけを90%まで引き上げた色を作る
            // ※既存の色（#f0fなど）から自動で高輝度版を生成するロジック
            const brightColor = `hsl(${getHue(baseColor)}, 100%, 70%)`;

            // 描画に使用するメイン/サブカラー（ダメージ時は全体が明るくなる）
            const mainStroke = isDmg ? brightColor : baseColor;
            const subStroke = isDmg ? '#fff' : brightColor;

            const sides = e.variant.sides;
            const radius = 45;

            // --- 2. 内部精密構造（淡い高輝度カラー） ---
            ctx.strokeStyle = subStroke;
            ctx.lineWidth = 0.4;
            ctx.globalAlpha = isDmg ? 1.0 : 0.6;
            ctx.shadowBlur = isDmg ? 20 : 0;
            ctx.shadowColor = subStroke;

            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                const nextA = (Math.PI * 2 / sides) * (i + 1);
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a) * radius, Math.sin(a) * radius); ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * radius * 0.6, Math.sin(a) * radius * 0.6);
                ctx.lineTo(Math.cos(nextA) * radius * 0.6, Math.sin(nextA) * radius * 0.6);
                ctx.stroke();
            }

            // --- 3. 装甲フレーム（メインカラー） ---
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = isDmg ? 30 : 12;
            ctx.shadowColor = mainStroke;

            [radius, radius - 4, radius - 15].forEach((r, idx) => {
                ctx.strokeStyle = (idx === 1) ? subStroke : mainStroke;
                ctx.lineWidth = (idx === 0) ? 1.8 : 0.8;
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const a = (Math.PI * 2 / sides) * i;
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.stroke();
            });

            // --- 4. コアユニット（同系色グラデーション風） ---
            ctx.save();
            ctx.rotate(-e.angle * 4);
            ctx.strokeStyle = subStroke;
            ctx.strokeRect(-8, -8, 16, 16);
            ctx.fillStyle = mainStroke;
            ctx.globalAlpha = isDmg ? 1.0 : 0.5;
            ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // --- 5. 砲塔ユニット ---
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                ctx.save();
                ctx.translate(Math.cos(a) * radius, Math.sin(a) * radius);
                ctx.rotate(a);
                ctx.strokeStyle = subStroke; ctx.lineWidth = 0.6; ctx.strokeRect(-8, -10, 10, 20);
                ctx.strokeStyle = mainStroke; ctx.lineWidth = 1.2;
                [-4, 4].forEach(y => { ctx.beginPath(); ctx.moveTo(2, y); ctx.lineTo(24, y); ctx.stroke(); });
                ctx.restore();
            }

            // --- 6. 強化ダメージエフェクト（火花とリング） ---
            if (isDmg) {
                // 【火花】
                for (let i = 0; i < 4; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const spd = 4 + Math.random() * 10;
                    particles.push({
                        x: e.x + (Math.random() - 0.5) * 40,
                        y: e.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
                        color: Math.random() > 0.4 ? brightColor : baseColor,
                        life: 0.5, size: 2 + Math.random() * 2
                    });
                }

                // 【リング爆風】
                // flashTimerが最大値の瞬間（＝当たった直後の1フレームだけ）にリングを出す
                if (e.flashTimer === 4) { // flashTimerの初期値に合わせて調整
                    rings.push({
                        x: e.x,
                        y: e.y,
                        r: 10,           // 開始サイズ
                        color: brightColor, // 「色味のある城」で光の輪を作る
                        life: 0.5        // 消えるまでの時間
                    });
                }
            }
            ctx.restore();
        }

        function drawNormalBullet(ctx, eb) {
            ctx.rotate(frame * 0.15);
            const bulletColor = (Math.floor(frame / 5) % 2 === 0) ? '#ff0000' : '#ff8800';
            ctx.fillStyle = bulletColor;
            ctx.shadowBlur = 8;
            ctx.shadowColor = bulletColor;

            const size = 6 * G_SCALE;
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.7, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size * 0.7, 0);
            ctx.closePath();
            ctx.fill();
        }

        function drawHomingMissile(ctx, eb) {
            // ミサイルを進行方向（速度ベクトル）に向ける
            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);

            const mSize = 12 * G_SCALE; // ミサイルは少し大きめに
            const color = eb.color || '#f00';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 12;
            ctx.shadowColor = color;

            // ミサイルの形状（鋭い矢印型）
            ctx.beginPath();
            ctx.moveTo(mSize, 0);            // 先端
            ctx.lineTo(-mSize, mSize * 0.6);   // 右後ろ
            ctx.lineTo(-mSize * 0.4, 0);     // 中央のくぼみ
            ctx.lineTo(-mSize, -mSize * 0.6);  // 左後ろ
            ctx.closePath();
            ctx.stroke();

            // 推進エンジンの中心点
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-mSize * 0.5, 0, 2 * G_SCALE, 0, Math.PI * 2);
            ctx.fill();
        }

        // score map popups
        function drawScorePopups() {
            ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
            scorePopups.forEach(s => { ctx.globalAlpha = s.alpha; ctx.fillText(s.text, s.x, s.y); });
            ctx.globalAlpha = 1.0;
        }

        function drawMiniMap() {
            // プレイ中または死亡演出中以外は非表示
            const container = document.getElementById('minimap-container');
            if (gameState !== 'PLAYING' && gameState !== 'DYING') {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';

            const mSize = 100; // HTMLで指定したサイズ
            const scale = mSize / worldSize; // 変換倍率

            // --- 描画開始 ---
            miniMapCtx.clearRect(0, 0, mSize, mSize);

            // 1. ワールド境界（薄い枠線）
            miniMapCtx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            miniMapCtx.strokeRect(0, 0, mSize, mSize);

            // 2. ワームホール（青い点）
            miniMapCtx.fillStyle = '#22f';
            wormholes.forEach(w => {
                if (w.active) {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(w.x * scale, w.y * scale, 1.5, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            });

            // 3. 敵の位置
            enemies.forEach(e => {
                if (e.type === 'boss') {
                    // ボス：大きな赤点（点滅）
                    miniMapCtx.fillStyle = (frame % 30 < 15) ? '#f00' : '#fff';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(e.x * scale, e.y * scale, 3.5, 0, Math.PI * 2);
                    miniMapCtx.fill();
                    // ボスのグロー効果
                    miniMapCtx.shadowBlur = 5;
                    miniMapCtx.shadowColor = '#f00';
                } else {
                    // 雑魚敵：小さな紫点
                    miniMapCtx.fillStyle = e.color || '#f0f';
                    miniMapCtx.shadowBlur = 0;
                    miniMapCtx.fillRect(e.x * scale - 1, e.y * scale - 1, 2, 2);
                }
            });

            // 4. 自機の位置（緑の点 + 軽い光）
            miniMapCtx.fillStyle = '#0f0';
            miniMapCtx.shadowBlur = 8;
            miniMapCtx.shadowColor = '#0f0';
            miniMapCtx.beginPath();
            miniMapCtx.arc(player.x * scale, player.y * scale, 2.5, 0, Math.PI * 2);
            miniMapCtx.fill();

            // シャドウ設定をリセット（他への影響を防ぐ）
            miniMapCtx.shadowBlur = 0;
        }

        function updateUI() {
            // --- 1. ボスHPバーの更新 ---
            const currentBoss = enemies.find(e => e.type === 'boss');
            if (currentBoss) {
                ui.bossContainer.style.display = 'block';
                const hpPct = Math.max(0, (currentBoss.hp / currentBoss.variant.hp) * 100);
                const bColor = currentBoss.color;

                ui.bossHpBarInline.style.width = hpPct + "%";
                ui.bossHpBarInline.style.backgroundColor = bColor;
                ui.bossHpBarInline.style.boxShadow = `0 0 10px ${bColor}`;

                ui.bossBarFrame.style.borderColor = bColor;
                ui.bossNameLabel.style.color = bColor;
                ui.bossNameLabel.innerText = currentBoss.variant.name;

                // ピンチ時の点滅演出
                if (hpPct < 25 && frame % 10 < 5) {
                    ui.bossHpBarInline.style.backgroundColor = '#fff';
                }
            } else {
                ui.bossContainer.style.display = 'none';
            }

            // --- 2. 敵スウォーム（残り数）バーの更新 ---
            const enemyRemains = Math.max(0, enemiesToSpawn - enemiesKilled);
            ui.enemyBar.style.width = `${(enemyRemains / enemiesToSpawn) * 100}%`;
            document.querySelector('.bar-label.enemy').innerText = `ENEMY: ${enemyRemains}`;

            // --- 3. シールドバーの更新 ---
            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            // 30%以下でクリティカル表示
            if (player.shield < 30) ui.shieldBar.classList.add('shield-critical');
            else ui.shieldBar.classList.remove('shield-critical');

            // 数値表示（HTMLに存在する場合のみ）
            if (ui.shieldVal) ui.shieldVal.innerText = Math.floor(Math.max(0, player.shield));

            // --- 4. 武器表示（レーザー/通常レベル）の更新 ---
            ui.weaponDisplay.innerHTML = '';
            if (player.laserTimer > 0) {
                const maxTime = 600;
                const pct = Math.max(0, (player.laserTimer / maxTime) * 100);
                const frameDiv = document.createElement('div');
                frameDiv.className = 'laser-bar-frame';
                const fillDiv = document.createElement('div');
                fillDiv.className = 'laser-bar-fill';
                fillDiv.style.width = pct + '%';
                // 終了間際の点滅
                if (player.laserTimer < 120 && Math.floor(frame / 4) % 2 === 0) fillDiv.style.opacity = 0.3;
                frameDiv.appendChild(fillDiv);
                ui.weaponDisplay.appendChild(frameDiv);
                player.laserTimer--;
            } else {
                // 通常のウェポンレベルブロック表示
                for (let i = 1; i <= MAX_WEAPON_LEVEL; i++) {
                    const block = document.createElement('div');
                    block.className = 'w-block';
                    if (i <= player.weaponLevel) block.classList.add('active');
                    ui.weaponDisplay.appendChild(block);
                }
            }

            // --- 5. 無敵状態バーの更新 ---
            if (player.invuln > 20) {
                ui.invulnWrapper.style.display = 'block';
                const pct = Math.min(100, (player.invuln / 600) * 100);
                ui.invulnBar.style.width = pct + "%";
                // 終了間際の点滅
                if (player.invuln < 120 && Math.floor(frame / 4) % 2 === 0) ui.invulnBar.style.opacity = 0.3;
                else ui.invulnBar.style.opacity = 1.0;
            } else {
                ui.invulnWrapper.style.display = 'none';
            }

            // ミニマップの描画（以前作成したものがあればここで呼ぶ）
            if (typeof drawMiniMap === 'function') drawMiniMap();
        }

        // エフェクト関連
        function createWallImpact(x, y, color) {
            // 壁に当たった際のエネルギーの火花
            for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * SPEED_SCALE * 15; // 弾の勢いを表現
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    size: 1.5 * G_SCALE,
                    life: 0.3 + Math.random() * 0.2
                });
            }
            // 小さな光のリング
            rings.push({ x: x, y: y, r: 2, color: color, life: 0.3 });
        }

        function createExplosion(x, y, baseColor, n) {
            const count = Math.floor(n * EXPLOSION_COUNT_MAG);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 8 + 2) * EXPLOSION_SPEED_MAG;

                let color;
                const rnd = Math.random();

                // --- 色の決定ロジックを整理 ---
                if (rnd < 0.85) {
                    // 85% は指定されたベースカラー（敵の色）
                    color = baseColor;
                } else {
                    // 残り 15% は「白」または「高輝度な黄色」のみに絞る（火花表現）
                    color = Math.random() > 0.5 ? '#ffffff' : '#ffff00';
                }

                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    size: (Math.random() * 3 + 1) * G_SCALE,
                    life: 1.0 + Math.random() * 0.5
                });
            }
        }

        // ユーティリティ
        // 補助関数：色から色相(Hue)を取り出す（コードの最後の方に追加してください）
        function getHue(color) {
            if (color.startsWith('#')) {
                // 簡易的な16進数→Hue変換（ボスの主要色に対応）
                if (color === '#f0f') return 300; // マゼンタ
                if (color === '#ffff00') return 60; // 黄
                if (color === '#0f8') return 150; // エメラルド
                if (color === '#0cc') return 180; // シアン
                if (color === '#44f') return 240; // 青
                if (color === '#f40') return 20;  // オレンジ赤
                if (color === '#f08') return 330; // ローズ
                if (color === '#fff') return 0;   // 白
            }
            return 0;
        }

        // =========================================================
        // 11. 入力・イベントリスナー (Input & Event Listeners)
        // =========================================================
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) setPaused(true); else setPaused(false);
        });

        window.addEventListener('blur', () => setPaused(true));
        window.addEventListener('focus', () => setPaused(false));

        const resumeAction = (e) => {
            if (e) e.preventDefault();
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                ui.pauseOverlay.style.display = 'none';
                AudioSys.resumeBGM();
            }
        };

        ui.pauseOverlay.addEventListener('click', resumeAction);
        ui.pauseOverlay.addEventListener('touchstart', resumeAction, { passive: false });

        function handleTouch(e) {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.move.active = false; input.aim.active = false;

            const lR = ui.stickL.getBoundingClientRect(); const rR = ui.stickR.getBoundingClientRect();
            const lC = { x: lR.left + lR.width / 2, y: lR.top + lR.height / 2 };
            const rC = { x: rR.left + rR.width / 2, y: rR.top + rR.height / 2 };

            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                const dL = Math.hypot(t.clientX - lC.x, t.clientY - lC.y);
                const dR = Math.hypot(t.clientX - rC.x, t.clientY - rC.y);

                if (dL < 100) {
                    input.move.active = true; const a = Math.atan2(t.clientY - lC.y, t.clientX - lC.x); const d = Math.min(dL, 40);
                    input.move.x = Math.cos(a) * (d / 40); input.move.y = Math.sin(a) * (d / 40);
                    ui.knobL.style.transform = `translate(${input.move.x * 40}px,${input.move.y * 40}px)`;
                } else if (dR < 100) {
                    input.aim.active = true; const a = Math.atan2(t.clientY - rC.y, t.clientX - rC.x); const d = Math.min(dR, 40);
                    input.aim.x = Math.cos(a) * (d / 40); input.aim.y = Math.sin(a) * (d / 40);
                    ui.knobR.style.transform = `translate(${input.aim.x * 40}px,${input.aim.y * 40}px)`;
                }
            }
            if (!input.move.active) { input.move.x = 0; input.move.y = 0; ui.knobL.style.transform = 'translate(0,0)'; }
            if (!input.aim.active) { input.aim.x = 0; input.aim.y = 0; ui.knobR.style.transform = 'translate(0,0)'; }
        }

        ui.launchBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            launchSatellites();
            ui.launchBtn.classList.add('active');
            setTimeout(() => ui.launchBtn.classList.remove('active'), 100);
        });
        ui.controls.addEventListener('touchstart', handleTouch, { passive: false });
        ui.controls.addEventListener('touchmove', handleTouch, { passive: false });
        ui.controls.addEventListener('touchend', handleTouch, { passive: false });

        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-ost').onclick = openOST;
        document.getElementById('btn-back').onclick = closeOST;

        window.addEventListener('keydown', e => {
            if (document.activeElement === document.getElementById('player-name-input')) return;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyZ', 'KeyX'].includes(e.code)) e.preventDefault();
            input.keys[e.code] = true;
            if (gameState === 'TITLE' && e.code === 'Space') startGame();
            if (gameState === 'PLAYING' && e.code === 'KeyX') launchSatellites();
        });
        window.addEventListener('keyup', e => input.keys[e.code] = false);
        window.addEventListener('resize', resize);

        let isInit = false;
        const handleInteraction = () => {
            if (isInit) return;
            isInit = true;
            AudioSys.resume();
            if (gameState === 'TITLE' && !AudioSys.currentSrc) AudioSys.playBGM('title');
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('touchstart', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };
        document.addEventListener('click', handleInteraction);
        document.addEventListener('touchstart', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        init(); loop();
    </script>
</body>

</html>
