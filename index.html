<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON GEOMETRY: FIXED</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; font-family: monospace; color: #fff; 
            user-select: none; -webkit-user-select: none; touch-action: none;
        }
        canvas { display: block; }
        
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; font-size: 14px; font-weight: bold; z-index: 5; text-shadow: 0 0 5px #0ff; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; z-index: 100;
        }
        h1 { margin: 0; font-size: 8vw; color: #0ff; text-shadow: 0 0 20px #0ff; }
        p { font-size: 4vw; color: #fff; margin-top: 10px; line-height: 1.5; }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* スティック位置調整 (bottomを80pxに上げて操作しやすく) */
        .joystick-area {
            position: absolute; bottom: 80px; 
            width: 120px; height: 120px;
            border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.15);
            display: flex; justify-content: center; align-items: center; pointer-events: none;
        }
        .knob {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.4); position: absolute; transform: translate(0, 0);
        }

        /* 左スティック */
        #stick-left { left: 40px; border-color: rgba(0, 255, 255, 0.3); }
        
        /* 右スティック */
        #stick-right { right: 40px; border-color: rgba(255, 0, 0, 0.3); }
        #knob-right { background: rgba(255, 100, 100, 0.4); }

        /* BOMBボタン (スティックのさらに上) */
        #launch-btn {
            position: absolute; bottom: 220px; right: 65px;
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(255, 200, 0, 0.2); border: 2px solid #fd0;
            color: #fd0; font-weight: bold; display: flex; justify-content: center; align-items: center;
            font-size: 14px; z-index: 50; box-shadow: 0 0 10px #fd0;
            transition: transform 0.1s;
        }
        #launch-btn:active { background: #fd0; color: #000; transform: scale(0.9); }

    </style>
</head>
<body>

<div id="ui">SCORE: <span id="score">0</span><br>WEAPON LV: <span id="w-lv">1</span> / 10<br>SATELLITES: <span id="sat-count">0</span></div>

<div id="overlay">
    <h1>NEON DRAGON</h1>
    <p>TAP TO START</p>
    <p style="color:#f00; font-size: 3.5vw;">DRAGON'S WEAKNESS IS HEAD!</p>
</div>

<div id="controls" style="display:none;">
    <div id="stick-left" class="joystick-area"><div class="knob" id="knob-left"></div></div>
    <div id="stick-right" class="joystick-area"><div class="knob" id="knob-right"></div></div>
    <div id="launch-btn">BOMB</div>
</div>

<canvas id="game"></canvas>

<script>
// --- GLOBAL SETTINGS ---
const G_SCALE = 0.7; 
const SPEED_SCALE = 0.4; 
const WALL_MARGIN = 20;

// --- オーディオシステム ---
const AudioSys = {
    ctx: null,
    init: function() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                this.ctx = new AudioContext();
            }
        } catch(e) { console.log('Audio init failed'); }
    },
    play: function(type) {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);

        if (type === 'shoot') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(100, t+0.1);
            gain.gain.setValueAtTime(0.05, t); gain.gain.linearRampToValueAtTime(0, t+0.1); osc.start(t); osc.stop(t+0.1);
        } else if (type === 'powerup') {
            osc.type = 'square'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(1200, t+0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.3); osc.start(t); osc.stop(t+0.3);
        } else if (type === 'bounce') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(50, t+0.2);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.2); osc.start(t); osc.stop(t+0.2);
        } else if (type === 'launch') {
            osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(800, t+0.5);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5); osc.start(t); osc.stop(t+0.5);
        } else if (type === 'explode') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.3);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.3); osc.start(t); osc.stop(t+0.3);
        } else if (type === 'damage') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.linearRampToValueAtTime(50, t+0.2);
            gain.gain.setValueAtTime(0.3, t); gain.gain.linearRampToValueAtTime(0, t+0.2); osc.start(t); osc.stop(t+0.2);
        } else if (type === 'deflect') {
            osc.type = 'square'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(200, t+0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.1); osc.start(t); osc.stop(t+0.1);
        }
    }
};

// --- DOM Elements ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const scoreEl = document.getElementById('score');
const wLvEl = document.getElementById('w-lv');
const satCountEl = document.getElementById('sat-count');
const controlsDiv = document.getElementById('controls');
const launchBtn = document.getElementById('launch-btn');
const stickLeftEl = document.getElementById('stick-left');
const knobLeftEl = document.getElementById('knob-left');
const stickRightEl = document.getElementById('stick-right');
const knobRightEl = document.getElementById('knob-right');

let width, height;
let gameState = 'START';
let score = 0;
let frame = 0;

// Player
const player = { 
    x:0, y:0, vx:0, vy:0, angle:0, satellites: [], 
    shield: 100, maxShield: 100, 
    weaponLevel: 1, maxWeaponLevel: 10,
    invuln: 0 
};
const keys = {};
const input = { move:{x:0, y:0, active:false}, aim:{x:0, y:0, active:false} };

// Objects
let bullets=[], enemies=[], particles=[], gridPoints=[], crystals=[], missiles=[], powerups=[];

// --- グリッド ---
function initGrid() {
    gridPoints = [];
    const spacing = 40 * G_SCALE;
    const cols = Math.ceil(width/spacing)+1, rows = Math.ceil(height/spacing)+1;
    for(let x=0; x<cols; x++) {
        gridPoints[x] = [];
        for(let y=0; y<rows; y++) {
            gridPoints[x][y] = {x:x*spacing, y:y*spacing, ox:x*spacing, oy:y*spacing, vx:0, vy:0};
        }
    }
}
function updateGrid() {
    for(let col of gridPoints) {
        for(let p of col) {
            const dx=p.x-p.ox, dy=p.y-p.oy;
            p.vx -= dx*0.05; p.vy -= dy*0.05; p.vx*=0.9; p.vy*=0.9; p.x+=p.vx; p.y+=p.vy;
        }
    }
}
function distortGrid(x, y, force, radius) {
    const spacing = 40 * G_SCALE;
    const cx = Math.floor(x/spacing), cy = Math.floor(y/spacing), r = Math.ceil(radius/spacing);
    for(let i=cx-r; i<=cx+r; i++) {
        if(!gridPoints[i]) continue;
        for(let j=cy-r; j<=cy+r; j++) {
            const p = gridPoints[i][j];
            if(!p) continue;
            const dx=p.x-x, dy=p.y-y, d2=dx*dx+dy*dy;
            if(d2<radius*radius) {
                const dist=Math.sqrt(d2), f=force*(1-dist/radius), a=Math.atan2(dy,dx);
                p.vx+=Math.cos(a)*f; p.vy+=Math.sin(a)*f;
            }
        }
    }
}
function drawGrid() {
    ctx.strokeStyle = 'rgba(0, 100, 255, 0.15)'; ctx.lineWidth = 1; ctx.beginPath();
    for(let x=0; x<gridPoints.length-1; x++) for(let y=0; y<gridPoints[0].length; y++) { ctx.moveTo(gridPoints[x][y].x, gridPoints[x][y].y); ctx.lineTo(gridPoints[x+1][y].x, gridPoints[x+1][y].y); }
    for(let x=0; x<gridPoints.length; x++) for(let y=0; y<gridPoints[0].length-1; y++) { ctx.moveTo(gridPoints[x][y].x, gridPoints[x][y].y); ctx.lineTo(gridPoints[x][y+1].x, gridPoints[x][y+1].y); }
    ctx.stroke();
    ctx.strokeStyle = '#f0f'; ctx.lineWidth = 4;
    ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, width - WALL_MARGIN*2, height - WALL_MARGIN*2);
}

// --- メイン処理 ---
function init() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    player.x = width/2; player.y = height/2;
    initGrid();
}

function startGame() {
    AudioSys.init();
    score = 0; scoreEl.innerText = score;
    bullets=[]; enemies=[]; particles=[]; crystals=[]; missiles=[]; powerups=[]; player.satellites=[];
    player.x=width/2; player.y=height/2; player.vx=0; player.vy=0;
    player.shield = player.maxShield;
    player.weaponLevel = 1;
    wLvEl.innerText = "1"; satCountEl.innerText = "0";
    gameState = 'PLAYING';
    overlay.style.display='none'; controlsDiv.style.display='block';
}

function launchSatellites() {
    if(player.satellites.length === 0) return;
    AudioSys.play('launch');
    player.satellites.forEach(s => {
        missiles.push({
            x: s.x, y: s.y, vx: Math.cos(s.angle)*5*SPEED_SCALE, vy: Math.sin(s.angle)*5*SPEED_SCALE,
            target: null, life: 200, speed: 10*SPEED_SCALE, color: '#fd0'
        });
    });
    player.satellites = [];
    satCountEl.innerText = "0";
    distortGrid(player.x, player.y, 200*G_SCALE, 300*G_SCALE);
}

function spawnCrystal(x, y) {
    crystals.push({x:x, y:y, vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2, life:600});
}

function spawnPowerup(x, y) {
    powerups.push({x:x, y:y, vx:(Math.random()-0.5)*1, vy:(Math.random()-0.5)*1, life:800});
}

function fireBullet() {
    const spd = 20 * SPEED_SCALE;
    const lv = player.weaponLevel;
    const shoot = (angleOffset, speedMult=1) => {
        bullets.push({
            x:player.x, y:player.y, 
            vx:Math.cos(player.angle + angleOffset) * spd * speedMult, 
            vy:Math.sin(player.angle + angleOffset) * spd * speedMult, 
            life: 80
        });
    };
    if (lv === 1) { shoot(0); } 
    else if (lv === 2) { shoot(-0.05); shoot(0.05); } 
    else if (lv === 3) { shoot(-0.15); shoot(0); shoot(0.15); } 
    else if (lv === 4) { shoot(-0.15); shoot(0); shoot(0.15); shoot(Math.PI); } 
    else if (lv === 5) { shoot(-0.2); shoot(-0.1); shoot(0); shoot(0.1); shoot(0.2); } 
    else if (lv === 6) { shoot(-0.2); shoot(-0.1); shoot(0); shoot(0.1); shoot(0.2); shoot(Math.PI - 0.1); shoot(Math.PI + 0.1); } 
    else if (lv === 7) { for(let i=-3; i<=3; i++) shoot(i * 0.15); } 
    else if (lv >= 8) { 
        const count = lv; 
        for(let i=0; i<count; i++) {
            const spread = (Math.PI / 2); const a = -spread/2 + (spread/(count-1)) * i; shoot(a);
        }
        if(lv === 10) { shoot(Math.PI); shoot(Math.PI-0.2); shoot(Math.PI+0.2); }
    }
    player.vx -= Math.cos(player.angle)*1*SPEED_SCALE; player.vy -= Math.sin(player.angle)*1*SPEED_SCALE;
    distortGrid(player.x, player.y, 10, 50);
    AudioSys.play('shoot');
}

function update() {
    if (gameState !== 'PLAYING') return;
    frame++;

    let mx=0, my=0;
    if(keys['ArrowUp']) my-=1; if(keys['ArrowDown']) my+=1;
    if(keys['ArrowLeft']) mx-=1; if(keys['ArrowRight']) mx+=1;
    if(input.move.active) { mx+=input.move.x; my+=input.move.y; }
    const accel = 0.8 * SPEED_SCALE;
    player.vx+=mx*accel; player.vy+=my*accel;
    player.vx*=0.95; player.vy*=0.95; 
    player.x+=player.vx; player.y+=player.vy;

    let bounced = false;
    if (player.x < WALL_MARGIN) { player.x = WALL_MARGIN; player.vx *= -0.8; bounced=true; }
    if (player.x > width - WALL_MARGIN) { player.x = width - WALL_MARGIN; player.vx *= -0.8; bounced=true; }
    if (player.y < WALL_MARGIN) { player.y = WALL_MARGIN; player.vy *= -0.8; bounced=true; }
    if (player.y > height - WALL_MARGIN) { player.y = height - WALL_MARGIN; player.vy *= -0.8; bounced=true; }
    if (bounced && Math.hypot(player.vx, player.vy) > 1) {
        distortGrid(player.x, player.y, 50, 100); AudioSys.play('bounce');
    }

    let shooting = false;
    if (input.aim.active && (Math.abs(input.aim.x)>0.1 || Math.abs(input.aim.y)>0.1)) {
        player.angle = Math.atan2(input.aim.y, input.aim.x); shooting = true;
    } else if (Math.hypot(player.vx, player.vy) > 0.1) {
        player.angle = Math.atan2(player.vy, player.vx);
    }
    let fireRate = 8; if (player.weaponLevel >= 5) fireRate = 6; if (player.weaponLevel >= 9) fireRate = 4;
    if((shooting || keys['Space']) && frame % fireRate === 0) fireBullet();
    if(keys['KeyZ']) { launchSatellites(); keys['KeyZ']=false; }

    // Satellites Radius increased (65 + wave)
    player.satellites.forEach((s, i) => {
        s.angle += 0.05 * SPEED_SCALE;
        const radius = (65 + Math.sin(frame*0.05)*10) * G_SCALE;
        const offset = (Math.PI*2 / player.satellites.length) * i;
        s.x = player.x + Math.cos(s.angle + offset) * radius;
        s.y = player.y + Math.sin(s.angle + offset) * radius;
    });

    missiles.forEach(m => {
        if(!m.target || !enemies.includes(m.target)) {
            let minDist = 9999;
            enemies.forEach(e => {
                const targetX = e.type === 'dragon' ? e.x : e.x;
                const targetY = e.type === 'dragon' ? e.y : e.y;
                const d = Math.hypot(targetX-m.x, targetY-m.y);
                if(d < minDist) { minDist = d; m.target = e; }
            });
        }
        if(m.target) {
            const targetX = m.target.type === 'dragon' ? m.target.x : m.target.x;
            const targetY = m.target.type === 'dragon' ? m.target.y : m.target.y;
            const angle = Math.atan2(targetY - m.y, targetX - m.x);
            m.vx += Math.cos(angle) * 0.5; m.vy += Math.sin(angle) * 0.5;
        }
        const spd = Math.hypot(m.vx, m.vy);
        m.vx = (m.vx/spd)*m.speed; m.vy = (m.vy/spd)*m.speed;
        m.x+=m.vx; m.y+=m.vy; m.life--;
        particles.push({x:m.x, y:m.y, vx:(Math.random()-0.5), vy:(Math.random()-0.5), color:'#fd0', life:0.3});
    });
    missiles = missiles.filter(m => m.life>0);

    crystals.forEach(c => {
        c.x+=c.vx; c.y+=c.vy; c.vx*=0.95; c.vy*=0.95; c.life--;
        const dist = Math.hypot(player.x-c.x, player.y-c.y);
        if(dist < 150 * G_SCALE) { c.x += (player.x-c.x)*0.1; c.y += (player.y-c.y)*0.1; }
        if(dist < 30 * G_SCALE) {
            c.life = 0;
            if(player.satellites.length < 16) {
                player.satellites.push({angle: Math.random()*Math.PI*2, x:0, y:0});
                satCountEl.innerText = player.satellites.length;
            }
            else score += 500;
        }
    });
    crystals = crystals.filter(c => c.life>0);

    powerups.forEach(p => {
        p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life--;
        const dist = Math.hypot(player.x-p.x, player.y-p.y);
        if(dist < 150 * G_SCALE) { p.x += (player.x-p.x)*0.08; p.y += (player.y-p.y)*0.08; }
        if(dist < 30 * G_SCALE) {
            p.life = 0;
            if(player.weaponLevel < player.maxWeaponLevel) {
                player.weaponLevel++;
                wLvEl.innerText = player.weaponLevel;
            } else {
                score += 2000;
                player.shield = Math.min(player.shield + 20, player.maxShield);
            }
            createExplosion(player.x, player.y, '#0ff', 20);
            AudioSys.play('powerup');
        }
    });
    powerups = powerups.filter(p => p.life>0);

    if(frame % 60 === 0) spawnEnemy(); 
    updateGrid();

    bullets.forEach(b => { b.x+=b.vx; b.y+=b.vy; b.life--; });
    bullets = bullets.filter(b => b.life>0);

    enemies.forEach(e => {
        if(e.type === 'dragon') {
            const dx = player.x - e.x, dy = player.y - e.y;
            const targetAngle = Math.atan2(dy, dx);
            let diff = targetAngle - e.angle;
            while (diff < -Math.PI) diff += Math.PI*2; while (diff > Math.PI) diff -= Math.PI*2;
            e.angle += diff * 0.05;
            e.x += Math.cos(e.angle) * e.speed; e.y += Math.sin(e.angle) * e.speed;
            
            let leaderX = e.x, leaderY = e.y;
            e.segments.forEach((seg, i) => {
                const dx = leaderX - seg.x, dy = leaderY - seg.y, d = Math.hypot(dx, dy);
                const spacing = 15 * G_SCALE;
                if(d > spacing) {
                    const moveDist = d - spacing;
                    seg.x += (dx/d) * moveDist; seg.y += (dy/d) * moveDist;
                }
                seg.angle = Math.atan2(leaderY - seg.y, leaderX - seg.x);
                leaderX = seg.x; leaderY = seg.y;
            });
        } else {
            const dx=player.x-e.x, dy=player.y-e.y, d=Math.sqrt(dx*dx+dy*dy);
            e.vx += (dx/d)*e.speed*0.05; e.vy += (dy/d)*e.speed*0.05;
            e.vx *= 0.98; e.vy *= 0.98;
            e.x+=e.vx; e.y+=e.vy;
            e.angle = Math.atan2(e.vy, e.vx);
        }
        
        if(e.x < WALL_MARGIN || e.x > width-WALL_MARGIN) { e.x = Math.max(WALL_MARGIN, Math.min(e.x, width-WALL_MARGIN)); e.vx*=-0.8; }
        if(e.y < WALL_MARGIN || e.y > height-WALL_MARGIN) { e.y = Math.max(WALL_MARGIN, Math.min(e.y, height-WALL_MARGIN)); e.vy*=-0.8; }

        const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
        if(distToPlayer < 25 * G_SCALE && player.invuln <= 0) {
            damagePlayer(e.type==='dragon' ? 30 : 15);
            createExplosion(player.x, player.y, '#f00', 10);
            if(e.type !== 'dragon') destroyEnemy(e);
        }

        for (let i = player.satellites.length - 1; i >= 0; i--) {
            const s = player.satellites[i];
            let isHit = false;
            if(e.type === 'dragon') {
                if(Math.hypot(s.x - e.x, s.y - e.y) < 22 * G_SCALE) isHit = true; 
                else {
                    for(let seg of e.segments) {
                        if(Math.hypot(s.x - seg.x, s.y - seg.y) < 18 * G_SCALE) {
                            createExplosion(s.x, s.y, '#fff', 3); AudioSys.play('deflect');
                            player.satellites.splice(i, 1); 
                            break; 
                        }
                    }
                }
            } else {
                if(Math.hypot(s.x - e.x, s.y - e.y) < 25 * G_SCALE) isHit = true;
            }

            if(isHit) {
                player.satellites.splice(i, 1); 
                e.hp = 0; 
                createExplosion(e.x, e.y, '#fd0', 10); AudioSys.play('explode');
                satCountEl.innerText = player.satellites.length;
                break; 
            }
        }
        if(e.hp<=0) { destroyEnemy(e); continue; }

        bullets.forEach(b => {
            let isHit = false, isDeflect = false;
            if(e.type === 'dragon') {
                if(Math.hypot(b.x - e.x, b.y - e.y) < 22 * G_SCALE) isHit = true;
                else {
                    for(let seg of e.segments) if(Math.hypot(b.x - seg.x, b.y - seg.y) < 18 * G_SCALE) isDeflect = true;
                }
            } else {
                if(Math.hypot(b.x - e.x, b.y - e.y) < 30 * G_SCALE) isHit = true;
            }

            if(isHit) { e.hp--; b.life=0; createExplosion(b.x, b.y, '#fff', 2); }
            else if(isDeflect) { b.life=0; createExplosion(b.x, b.y, '#fff', 1); AudioSys.play('deflect'); }
        });
        if(e.hp<=0) { destroyEnemy(e); continue; }

        missiles.forEach(m => {
            let isHit = false, isDeflect = false;
            if(e.type === 'dragon') {
                if(Math.hypot(m.x - e.x, m.y - e.y) < 22 * G_SCALE) isHit = true;
                else for(let seg of e.segments) if(Math.hypot(m.x - seg.x, m.y - seg.y) < 18 * G_SCALE) isDeflect = true;
            } else {
                if(Math.hypot(m.x - e.x, m.y - e.y) < 30 * G_SCALE) isHit = true;
            }
            if(isHit) { e.hp-=10; m.life=0; createExplosion(m.x, m.y, '#fd0', 5); }
            else if(isDeflect) { m.life=0; createExplosion(m.x, m.y, '#fff', 3); AudioSys.play('deflect'); }
        });
    });
    enemies = enemies.filter(e => e.hp>0);

    particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life-=0.05; });
    particles = particles.filter(p => p.life>0);

    if(player.invuln > 0) player.invuln--;
}

function damagePlayer(amount) {
    player.shield -= amount;
    player.invuln = 45;
    AudioSys.play('damage');
    distortGrid(player.x, player.y, 200*G_SCALE, 100*G_SCALE);
    if (player.shield <= 0) gameOver();
}

function destroyEnemy(e) {
    createExplosion(e.x, e.y, e.color, e.type==='dragon'?30:15);
    distortGrid(e.x, e.y, 50*G_SCALE, 100*G_SCALE);
    score += e.type==='dragon' ? 500 : 100; scoreEl.innerText = score;
    AudioSys.play('explode');
    if (e.dropType === 'powerup') spawnPowerup(e.x, e.y);
    else {
        const count = e.type==='dragon' ? 5 : 1;
        for(let i=0; i<count; i++) spawnCrystal(e.x + (Math.random()-0.5)*20, e.y + (Math.random()-0.5)*20);
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    overlay.style.display='flex'; controlsDiv.style.display='none';
    overlay.innerHTML = `<h1>GAME OVER</h1><p>SCORE: ${score}</p><p>TAP TO RETRY</p>`;
    createExplosion(player.x, player.y, '#fff', 50);
    AudioSys.play('explode');
}

function spawnEnemy() {
    let ex, ey;
    if(Math.random()<0.5) { 
        ex = Math.random() < 0.5 ? WALL_MARGIN+10 : width-WALL_MARGIN-10; 
        ey = WALL_MARGIN + Math.random()*(height-WALL_MARGIN*2);
    } else { 
        ex = WALL_MARGIN + Math.random()*(width-WALL_MARGIN*2);
        ey = Math.random() < 0.5 ? WALL_MARGIN+10 : height-WALL_MARGIN-10;
    }
    
    const t=Math.random();
    if(t<0.15) { 
        let e={x:ex, y:ey, vx:0, vy:0, hp:1, speed:1.5*SPEED_SCALE, color:'#f00', dropType:'powerup', type:'dragon', angle:0, segments:[]};
        for(let i=0; i<8; i++) e.segments.push({x:ex, y:ey, angle:0});
        enemies.push(e);
    } else {
        let e={x:ex, y:ey, vx:0, vy:0, hp:1, speed:(2+Math.random()*2)*SPEED_SCALE, color:'#f0f', dropType:'crystal', type:'normal', angle:0};
        if(t<0.6) { e.color='#0ff'; }
        else { e.speed=4*SPEED_SCALE; e.color='#0f0'; }
        enemies.push(e);
    }
}

function createExplosion(x, y, color, count) {
    for(let i=0; i<count; i++) {
        const a=Math.random()*Math.PI*2, s=Math.random()*5*G_SCALE;
        particles.push({x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, color, life:1.0});
    }
}

function drawPlayerShip(ctx, x, y, angle, scale) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(scale, scale);
    ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.strokeStyle = '#0ff';
    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 5); ctx.lineTo(-10, -5); ctx.closePath(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-5, 0); ctx.lineTo(-15, 20); ctx.lineTo(-10, 5); ctx.moveTo(-5, 0); ctx.lineTo(-15, -20); ctx.lineTo(-10, -5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-10, 5); ctx.lineTo(-18, 5); ctx.moveTo(-10, -5); ctx.lineTo(-18, -5); ctx.stroke();
    if (Math.hypot(player.vx, player.vy) > 0.5) {
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.moveTo(-18, 5); ctx.lineTo(-30-Math.random()*10, 5); ctx.lineTo(-18, 3); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-18, -5); ctx.lineTo(-30-Math.random()*10, -5); ctx.lineTo(-18, -3); ctx.fill();
    }
    ctx.restore();
}

function drawNormalEnemy(ctx, e) {
    ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.scale(G_SCALE, G_SCALE);
    ctx.strokeStyle=e.color; ctx.shadowBlur=10; ctx.shadowColor=e.color; ctx.lineWidth=2;
    ctx.beginPath();
    if(e.color === '#0ff') { 
        ctx.moveTo(15,0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath();
    } else if(e.color === '#0f0') {
        ctx.moveTo(20,0); ctx.lineTo(0, 5); ctx.lineTo(-15, 15); ctx.moveTo(0, -5); ctx.lineTo(-15, -15); ctx.moveTo(0,5); ctx.lineTo(0,-5);
    } else {
        ctx.moveTo(10,10); ctx.lineTo(-10,10); ctx.lineTo(-15,0); ctx.lineTo(-10,-10); ctx.lineTo(10,-10); ctx.lineTo(15,0); ctx.closePath();
    }
    ctx.stroke();
    ctx.restore();
}

function drawDragonEnemy(ctx, e) {
    ctx.save(); ctx.scale(G_SCALE, G_SCALE);
    ctx.strokeStyle=e.color; ctx.shadowBlur=10; ctx.shadowColor=e.color; ctx.lineWidth=2;
    e.segments.forEach((seg, i) => {
        ctx.save(); ctx.translate(seg.x/G_SCALE, seg.y/G_SCALE); ctx.rotate(seg.angle);
        ctx.beginPath();
        const size = i < e.segments.length - 2 ? 12 : (12 - (i - (e.segments.length-3))*3);
        ctx.arc(0, 0, size, 0, Math.PI*2); ctx.stroke(); ctx.restore();
    });
    ctx.save(); ctx.translate(e.x/G_SCALE, e.y/G_SCALE); ctx.rotate(e.angle);
    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(5, 15); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.lineTo(5, -15); ctx.closePath(); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(10, 5, 2, 0, Math.PI*2); ctx.arc(10, -5, 2, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.restore();
}

function draw() {
    ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(0,0,width,height);
    ctx.globalCompositeOperation='lighter';

    drawGrid();

    crystals.forEach(c => {
        ctx.fillStyle = '#fd0'; ctx.shadowBlur = 10; ctx.shadowColor='#fd0';
        const s = 5 * G_SCALE;
        ctx.beginPath(); ctx.moveTo(c.x, c.y-s); ctx.lineTo(c.x+s, c.y); ctx.lineTo(c.x, c.y+s); ctx.lineTo(c.x-s, c.y); ctx.fill();
    });
    powerups.forEach(p => {
        ctx.strokeStyle = '#0ff'; ctx.lineWidth=2; ctx.shadowBlur=10; ctx.shadowColor='#0ff';
        const s = 16 * G_SCALE;
        ctx.strokeRect(p.x-s/2, p.y-s/2, s, s);
        ctx.font = (12*G_SCALE)+'px monospace'; ctx.fillStyle='#0ff'; ctx.fillText('P', p.x-(4*G_SCALE), p.y+(4*G_SCALE));
    });

    if(gameState === 'PLAYING') {
        if (player.invuln <= 0 || frame % 4 < 2) {
            drawPlayerShip(ctx, player.x, player.y, player.angle, G_SCALE);
        }
        player.satellites.forEach(s => {
            ctx.fillStyle = '#fd0'; ctx.shadowColor = '#fd0'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(s.x, s.y, 4*G_SCALE, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'rgba(255, 200, 0, 0.3)'; ctx.lineWidth=1; ctx.shadowBlur=0;
            ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(s.x, s.y); ctx.stroke();
        });
    }

    missiles.forEach(m => { ctx.fillStyle = '#fd0'; ctx.beginPath(); ctx.arc(m.x, m.y, 4*G_SCALE, 0, Math.PI*2); ctx.fill(); });
    enemies.forEach(e => {
        if(e.type === 'dragon') drawDragonEnemy(ctx, e);
        else drawNormalEnemy(ctx, e);
    });
    ctx.fillStyle='#ff0'; bullets.forEach(b=>{ctx.beginPath(); ctx.arc(b.x, b.y, 3*G_SCALE, 0, Math.PI*2); ctx.fill();});
    particles.forEach(p=>{ctx.fillStyle=p.color; ctx.globalAlpha=p.life; ctx.beginPath(); ctx.arc(p.x, p.y, 2*G_SCALE, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0;});

    if(gameState === 'PLAYING') {
        const barW = 200*G_SCALE, barH = 10*G_SCALE;
        const barX = width/2 - barW/2, barY = 20;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.shadowBlur=0; ctx.strokeRect(barX, barY, barW, barH);
        ctx.fillStyle = '#00f';
        const fillW = (player.shield / player.maxShield) * (barW-4);
        if(fillW > 0) ctx.fillRect(barX+2, barY+2, fillW, barH-4);
    }

    ctx.globalCompositeOperation='source-over';
    requestAnimationFrame(()=>{update(); draw();});
}

function handleTouch(e) {
    e.preventDefault();
    input.move.active=false; input.move.x=0; input.move.y=0;
    input.aim.active=false; input.aim.x=0; input.aim.y=0;
    
    const lR=stickLeftEl.getBoundingClientRect(), lCX=lR.left+lR.width/2, lCY=lR.top+lR.height/2;
    const rR=stickRightEl.getBoundingClientRect(), rCX=rR.left+rR.width/2, rCY=rR.top+rR.height/2;
    const maxD=40;

    for(let i=0; i<e.touches.length; i++) {
        const t=e.touches[i], tx=t.clientX, ty=t.clientY;
        if(tx < width/2) {
            const dx=tx-lCX, dy=ty-lCY, d=Math.sqrt(dx*dx+dy*dy);
            if(d<150) {
                input.move.active=true; const dist=Math.min(d,maxD), ang=Math.atan2(dy,dx);
                input.move.x=(Math.cos(ang)*dist)/maxD; input.move.y=(Math.sin(ang)*dist)/maxD;
                knobLeftEl.style.transform=`translate(${input.move.x*maxD}px, ${input.move.y*maxD}px)`;
            }
        } else {
            const dx=tx-rCX, dy=ty-rCY, d=Math.sqrt(dx*dx+dy*dy);
            if(d<150) {
                input.aim.active=true; const dist=Math.min(d,maxD), ang=Math.atan2(dy,dx);
                input.aim.x=(Math.cos(ang)*dist)/maxD; input.aim.y=(Math.sin(ang)*dist)/maxD;
                knobRightEl.style.transform=`translate(${input.aim.x*maxD}px, ${input.aim.y*maxD}px)`;
            }
        }
    }
    if(!input.move.active) knobLeftEl.style.transform=`translate(0px, 0px)`;
    if(!input.aim.active) knobRightEl.style.transform=`translate(0px, 0px)`;
}

launchBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); launchSatellites(); });

window.addEventListener('keydown', e=>keys[e.code]=true);
window.addEventListener('keyup', e=>keys[e.code]=false);
window.addEventListener('touchstart', e=>{
    if(e.target===launchBtn) return;
    if(gameState==='PLAYING')handleTouch(e);
}, {passive:false});
window.addEventListener('touchmove', e=>{if(gameState==='PLAYING')handleTouch(e);}, {passive:false});
window.addEventListener('touchend', e=>{if(gameState==='PLAYING')handleTouch(e);}, {passive:false});
overlay.addEventListener('touchstart', e=>{e.preventDefault(); if(gameState!=='PLAYING') startGame();});
overlay.addEventListener('click', ()=>{if(gameState!=='PLAYING') startGame();});
window.addEventListener('resize', init);
init(); draw();
</script>
</body>
</html>
