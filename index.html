<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>NEON GRAVITY: ORBITAL</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        /* --- 基本レイアウト設定 --- */
        body {
            margin: 0;
            background: #050505;
            /* 真っ黒に近い背景でネオンを引き立てる */
            overflow: hidden;
            /* スクロールバーを隠す */
            font-family: 'Orbitron', monospace;
            /* 近未来的なフォントを採用 */
            color: #fff;
            user-select: none;
            /* プレイ中にテキストが選択されるのを防ぐ */
            -webkit-user-select: none;
            touch-action: none;
            /* スマホでのブラウザ標準ジェスチャーを無効化 */
            -webkit-tap-highlight-color: transparent;
            /* タップ時の青い枠を消す */
        }

        /* ゲーム描画用のメインキャンバス */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            /* 背景として配置 */
        }

        /* UI全体のコンテナ（HUDやメッセージ） */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* 下にあるジョイスティック等の操作を邪魔しない */
            z-index: 20;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }

        /* 上部の情報表示（スコア・ステージ・シールド等）を左右に分ける列 */
        .hud-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        /* スコア表示：水色の発光エフェクト */
        #score-display {
            font-size: 28px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            /* ネオンのような光 */
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        /* 補助テキスト（STAGE等のラベル） */
        .sub-text {
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }

        /* ゲージ類（右側）のボックス */
        #gauge-box {
            width: 160px;
            text-align: right;
            pointer-events: auto;
            /* ここだけは必要に応じてイベントを拾えるように設定 */
        }

        /* ゲージのタイトルラベル */
        .bar-label {
            font-size: 10px;
            color: #0ff;
            display: block;
            margin-bottom: 2px;
        }

        /* ゲージの外枠 */
        .bar-frame {
            width: 100%;
            height: 12px;
            border: 1px solid #0ff;
            background: rgba(0, 20, 40, 0.8);
            margin-bottom: 5px;
        }

        /* シールドの中身：水色のバー */
        #shield-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: width 0.1s;
            /* 減少を滑らかに見せる */
            box-shadow: 0 0 10px #0ff;
        }

        /* シールド危険時：赤色の点滅アニメーション用 */
        .shield-critical {
            animation: blink 0.2s infinite;
            background: #f00 !important;
        }

        /* 敵軍勢ゲージ：赤色の配色 */
        .bar-label.enemy {
            color: #f00;
        }

        .bar-frame.enemy {
            border-color: #f00;
            background: rgba(40, 0, 0, 0.8);
        }

        #enemy-bar {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.5s;
        }

        /* 警告メッセージ（画面中央付近） */
        #warning-msg {
            display: none;
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #f00;
            font-size: 24px;
            animation: blink 0.2s infinite;
        }

        /* ステージクリア等の大型メッセージ */
        #stage-msg {
            display: none;
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 40px;
            text-shadow: 0 0 20px #0ff;
        }

        /* --- 新しいHUD（ステージ番号・武器レベル） --- */
        .hud-label {
            font-size: 10px;
            color: #aaa;
            display: block;
            margin-bottom: -2px;
        }

        /* ステージ番号：大きく強調 */
        #stage-num {
            font-size: 28px;
            color: #fff;
            font-weight: bold;
            line-height: 1.0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* 武器レベルのブロック（通常時） */
        .w-block {
            width: 12px;
            height: 8px;
            margin-right: 3px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            display: inline-block;
        }

            /* レベルアップした時に付与されるクラス：緑色の発光 */
            .w-block.active {
                background: #0f0;
                border-color: #0f0;
                box-shadow: 0 0 5px #0f0;
            }

        /* レーザー装備時の持続時間バー */
        .laser-bar-frame {
            width: 80px;
            height: 8px;
            border: 1px solid #0ff;
            background: rgba(0, 20, 40, 0.5);
        }

        .laser-bar-fill {
            height: 100%;
            background: #0ff;
            box-shadow: 0 0 8px #0ff;
        }

        /* タイトル画面やリトライ画面の全画面オーバーレイ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            /* 半透明の黒でゲーム画面を暗くする */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            /* UI背面を触れないようにする */
        }

        /* ポーズ画面：ぼかしエフェクト付き */
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 105;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            /* 背景をボケさせる */
        }

        /* メニューボタン（START GAME等）のデザイン */
        .menu-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 20px 50px;
            margin: 10px;
            font-size: 22px;
            font-family: 'Orbitron';
            cursor: pointer;
            min-width: 240px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

            /* ボタンクリック/タップ時の押し込み演出 */
            .menu-btn:active {
                background: #0ff;
                color: #000;
                transform: scale(0.95);
            }

        /* サウンドトラック画面 */
        #ost-ui {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 110;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        /* 楽曲リストの項目 */
        .track-item {
            padding: 20px;
            width: 80%;
            border-bottom: 1px solid #333;
            color: #888;
            text-align: center;
            font-size: 18px;
        }

            /* 現在再生中の楽曲：水色で強調 */
            .track-item.playing {
                color: #0ff;
                border-color: #0ff;
            }

        /* 操作パネル（ジョイスティック等） */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            touch-action: none;
            pointer-events: auto;
        }

        /* ジョイスティックの外枠（円） */
        .joystick-area {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        /* 実際に動かすスティック部分（つまみ） */
        .knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            position: absolute;
            transform: translate(0, 0);
            transition: transform 0.05s;
            /* 指の動きに滑らかに追従 */
        }

        /* 特殊攻撃（ボム）ボタン：黄色のネオン */
        #launch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.15);
            border: 2px solid #ff0;
            color: #ff0;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            box-shadow: 0 0 10px #ff0;
            pointer-events: auto;
        }

            /* ボムボタン使用時のフィードバック */
            #launch-btn.active {
                background: #ff0;
                color: #000;
                transform: scale(0.9);
            }

        /* 共通アニメーション：0.2秒ごとに不透明度を半分にする点滅 */
        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        /* --- ランキング機能用 CSS (ここから追加) --- */
        #ranking-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 150;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
        }

        /* ランキングテーブル */
        #ranking-table {
            width: 90%;
            max-width: 600px;
            border-collapse: collapse;
            color: #fff;
            font-family: 'Orbitron';
            margin-bottom: 20px;
        }

            #ranking-table th {
                border-bottom: 2px solid #0ff;
                color: #0ff;
                padding: 10px;
            }

            #ranking-table td {
                border-bottom: 1px solid #333;
                padding: 10px;
            }

        /* 順位ごとの色 */
        .rank-1 {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* 金 */
        .rank-2 {
            color: #c0c0c0;
            text-shadow: 0 0 10px #c0c0c0;
            font-weight: bold;
        }

        /* 銀 */
        .rank-3 {
            color: #cd7f32;
            text-shadow: 0 0 10px #cd7f32;
            font-weight: bold;
        }

        /* 銅 */

        /* 名前入力エリア */
        #name-input-area {
            display: none;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 55%;
            width: 100%;
            z-index: 200;
        }

        #player-name-input {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            color: #fff;
            font-family: 'Orbitron';
            font-size: 24px;
            padding: 10px;
            text-align: center;
            width: 250px;
            outline: none;
            margin-bottom: 10px;
            box-shadow: 0 0 10px #0ff;
        }

            #player-name-input::placeholder {
                color: #055;
            }

        /* エンディング画面 (全画面・黒背景) */
        #ending-msg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* 背景をしっかり暗くする */
            z-index: 200;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
        }

            /* エンディング画面内の各要素の間隔を調整 */
            #ending-msg h1 {
                margin-bottom: 10px;
            }

            #ending-msg p {
                margin-bottom: 20px;
            }

        /* スコア表示の強調 */
        #final-score-val {
            background: rgba(0, 255, 255, 0.1);
            padding: 10px 30px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            margin-bottom: 30px;
        }
    </style>

</head>

<body>

    <canvas id="game"></canvas>

    <div id="ui">
        <div class="hud-row">
            <div id="info-box" style="display:flex; flex-direction:column; gap:8px;">
                <div id="score-display">000000</div>
                <div><span class="hud-label">STAGE</span><span id="stage-num">1</span></div>
                <div>
                    <span class="hud-label">WEAPON</span>
                    <div id="weapon-display" style="height:12px; display:flex; align-items:center;"></div>
                </div>
                <div id="invuln-wrapper" style="display:none; margin-top: 2px;">
                    <span class="bar-label" style="color:#ff0; font-size:10px;">INVINCIBLE</span>
                    <div class="bar-frame"
                         style="border-color:#ff0; background:rgba(40,40,0,0.5); width:80px; height:6px;">
                        <div id="invuln-bar" style="width:0%; height:100%; background:#ff0; box-shadow:0 0 5px #ff0;">
                        </div>
                    </div>
                </div>
            </div>
            <div id="gauge-box">
                <span class="bar-label">SHIELD: <span id="shield-val" style="color:#fff; font-size:12px;">100</span></span>
                <div class="bar-frame">
                    <div id="shield-bar"></div>
                </div>
                <span class="bar-label enemy">ENEMY SWARM</span>
                <div class="bar-frame enemy">
                    <div id="enemy-bar"></div>
                </div>
                <div id="boss-ui-container" style="display:none; margin-top: 10px;">
                    <span class="bar-label" id="boss-name-label" style="color:#f00; font-size:10px;">BOSS: NAME</span>
                    <div id="boss-bar-frame" class="bar-frame" style="border-color:#f00;">
                        <div id="boss-hp-bar-inline"
                             style="width:100%; height:100%; background:#f00; box-shadow:0 0 10px #f00; transition: width 0.2s, background-color 0.3s;">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="warning-msg">GRAVITY CRITICAL</div>
        <div id="stage-msg">STAGE CLEAR</div>

        <div id="ending-msg">
            <h1 style="color:#fff; font-size:30px; text-shadow:0 0 30px #0ff; margin-bottom:5px;">MISSION COMPLETE</h1>
            <p style="color:#0ff; font-size:14px; letter-spacing:3px; margin-bottom:15px;">ALL SECTORS LIBERATED</p>
            <div id="final-score-val" style="color:#fff; font-size:24px; margin-bottom:20px; font-family:'Orbitron';">TOTAL SCORE: 0</div>
            <div class="menu-btn" id="btn-next-result" style="margin-top:10px;">NEXT</div>
        </div>
    </div>

    <div id="name-input-area" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:300; flex-direction:column; align-items:center; justify-content:center;">
        <h2 id="clear-congrats-msg" style="display:none; color:#ffd700; font-size:36px; text-shadow:0 0 20px #ffd700; margin-bottom:10px;">CONGRATULATIONS!</h2>

        <h2 id="result-score-display" style="color:#fff; font-size:32px; margin-bottom:20px;">SCORE: 0</h2>
        <p style="color:#0ff; margin-bottom:10px;">REGISTER TO WORLD RANKING?</p>
        <input type="text" id="player-name-input" placeholder="ENTER NAME" maxlength="10">

        <div style="display:flex; gap:20px; margin-top:10px;">
            <div class="menu-btn" id="submit-score-btn" style="min-width: 140px; padding: 10px;">SUBMIT</div>
            <div class="menu-btn" id="skip-score-btn" style="min-width: 140px; padding: 10px; border-color:#555; color:#aaa;">SKIP</div>
        </div>
    </div>

    <div id="overlay" style="display:flex;">
        <h1 id="menu-title"
            style="color:#0ff; font-size:40px; margin-bottom:40px; text-shadow:0 0 20px #0ff; text-align:center;">
            NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>
        </h1>

        <div id="menu-buttons-container" style="display:flex; flex-direction:column; align-items:center;">
            <div class="menu-btn" id="btn-start">START GAME</div>
            <div class="menu-btn" id="btn-ranking">WORLD RANKING</div>
            <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
            <div class="menu-btn" id="btn-title" style="display:none;">TITLE</div>
        </div>

        <div id="menu-footer" style="font-size:12px;color:#888;margin-top:20px;">
            PC: [X] Bomb | MOBILE: Small Button to Bomb
        </div>
    </div>


    <div id="ranking-overlay">
        <h1 style="color:#0ff; text-shadow:0 0 20px #0ff; margin-bottom: 20px;">TOP COMMANDERS</h1>
        <div id="loading-ranking" style="color:#0ff; animation: blink 0.5s infinite;">CONNECTING...</div>
        <table id="ranking-table" style="display:none;">
            <thead>
                <tr>
                    <th style="width:50px;">RANK</th>
                    <th style="text-align:left;">NAME</th>
                    <th>STAGE</th>
                    <th style="text-align:right;">SCORE</th>
                </tr>
            </thead>
            <tbody id="ranking-list-body"></tbody>
        </table>
        <div class="menu-btn" id="close-ranking-btn">CLOSE</div>
    </div>

    <div id="pause-overlay">
        <h1 style="color:#fff; font-size:40px; text-shadow:0 0 10px #fff;">PAUSED</h1>
        <p style="color:#aaa; margin-top:20px;">TAP TO RESUME</p>
    </div>

    <div id="ost-ui">
        <h2 style="color:#0ff;">SOUNDTRACK</h2>
        <div id="track-list" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
        <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
    </div>

    <div id="controls">
        <div id="stick-left" class="joystick-area">
            <div class="knob" id="knob-left"></div>
        </div>
        <div id="stick-right" class="joystick-area">
            <div class="knob" id="knob-right"></div>
        </div>
        <div id="launch-btn">BOMB</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // ★★★ ここをあなたのFirebase設定に書き換えてください ★★★
        const firebaseConfig = {
            apiKey: "AIzaSyCRjHe893FZopPErdjtgX8KJ8KPT_rmgnI",
            authDomain: "stellar-gravity.firebaseapp.com",
            projectId: "stellar-gravity",
            storageBucket: "stellar-gravity.firebasestorage.app",
            messagingSenderId: "936422140891",
            appId: "1:936422140891:web:d4e55c30507570602515fe",
            measurementId: "G-0FWP5X8T2T"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const SCORES_COLLECTION = "neon_gravity_scores";

        // HTML Elements
        const rankingOverlay = document.getElementById("ranking-overlay");
        const rankingBody = document.getElementById("ranking-list-body");
        const loadingEl = document.getElementById("loading-ranking");
        const tableEl = document.getElementById("ranking-table");

        //const nameInputArea = document.getElementById("name-input-area");
        //const nameInput = document.getElementById("player-name-input");
        //const submitBtn = document.getElementById("submit-score-btn");

        function escapeHtml(str) {
            if (!str) return "";
            return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        }

        window.showRanking = async function () {
            rankingOverlay.style.display = "flex";
            loadingEl.style.display = "block";
            tableEl.style.display = "none";
            rankingBody.innerHTML = "";

            try {
                const q = query(collection(db, SCORES_COLLECTION), orderBy("score", "desc"), limit(10));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    rankingBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">NO DATA</td></tr>';
                }

                let rank = 1;
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const tr = document.createElement("tr");

                    let rankClass = "";
                    let rankText = "#" + rank;
                    if (rank === 1) { rankClass = "rank-1"; rankText = "1ST"; }
                    else if (rank === 2) { rankClass = "rank-2"; rankText = "2ND"; }
                    else if (rank === 3) { rankClass = "rank-3"; rankText = "3RD"; }

                    const stageVal = data.stage ? "ST." + data.stage : "-";

                    tr.innerHTML = `
                                                            <td class="${rankClass}" style="text-align:center;">${rankText}</td>
                                                            <td style="text-align:left;">${escapeHtml(data.name)}</td>
                                                            <td style="color:#aaa; text-align:center;">${stageVal}</td>
                                                            <td style="text-align:right; color:#0ff;">${data.score.toLocaleString()}</td>
                                                        `;
                    rankingBody.appendChild(tr);
                    rank++;
                });

                loadingEl.style.display = "none";
                tableEl.style.display = "table";
            } catch (e) {
                console.error("Ranking Error:", e);
                loadingEl.innerText = "CONNECTION ERROR";
            }
        };

        window.submitScore = async function (score, stage) {
            const name = nameInput.value.trim() || "PILOT";
            submitBtn.innerText = "SENDING...";
            submitBtn.style.pointerEvents = "none";

            try {
                await addDoc(collection(db, SCORES_COLLECTION), {
                    name: name,
                    score: score,
                    stage: stage,
                    timestamp: serverTimestamp()
                });

                localStorage.setItem("neonGravity_last_name", name);

                // 入力エリアを隠す
                nameInputArea.style.display = "none";
                submitBtn.innerText = "SUBMIT";
                submitBtn.style.pointerEvents = "auto";

                // 次のメニューへ
                if (typeof window.proceedToNextMenu === "function") {
                    window.proceedToNextMenu();
                } else {
                    window.showRanking();
                }

            } catch (e) {
                console.error("Submit Error:", e);
                alert("Error sending score.");
                submitBtn.innerText = "SUBMIT";
                submitBtn.style.pointerEvents = "auto";
            }
        };

        document.getElementById("skip-score-btn").onclick = () => {
            if (typeof window.proceedToNextMenu === "function") {
                window.proceedToNextMenu();
            } else {
                document.getElementById('name-input-area').style.display = 'none';
            }
        };

        document.getElementById("btn-ranking").onclick = () => window.showRanking();
        document.getElementById("close-ranking-btn").onclick = () => {
            rankingOverlay.style.display = "none";
        };
        submitBtn.onclick = () => {
            const s = window.finalGameScore || 0;
            const st = window.finalGameStage || 1;
            window.submitScore(s, st);
        };

        const saved = localStorage.getItem("neonGravity_last_name");
        if (saved) nameInput.value = saved;
    </script>


    <script>
        // --- ゲームバランス・グラフィック設定 ---

        // 全体の描画スケール（0.7 = 標準の70%の大きさ）
        const G_SCALE = 0.7;
        // ゲーム全体の速度倍率（値を上げるとすべてが速くなります）
        const SPEED_SCALE = 0.25;
        // 画面端の見えない壁の余白
        const WALL_MARGIN = 5;
        // 通常ショットの最大強化レベル（1〜7）
        const MAX_WEAPON_LEVEL = 7; // 最大を7に変更

        const MAX_STAGE = 8;

        // 背景グリッド線の間隔（小さいほど網目が細かくなる）
        const GRID_SPACING = 25;

        // --- 敵の移動速度設定 ---
        const ENEMY_SPEEDS = {
            TRIANGLE: 4.8, // 紫：高速で直線的な動き
            CUBE: 2.5,     // 緑：アイテムキャリア、動きは遅め
            TADPOLE: 10,    // 白：精子型、非常に素早い
            DRAGON: 8,      // 赤：ボス、最高速度が高い
        };

        // ドラゴンがプレイヤーを追尾する際の加速力（旋回性能に影響）
        const DRAGON_ACCELERATION = 0.2;

        // --- ボスのバリエーション設定 ---
        const BOSS_VARIANTS = [
            { name: 'TRI-FORTRESS', sides: 3, color: '#f0f', hp: 100, bulletCount: 3, speedFactor: 1.5 }, // 高速
            { name: 'DIAMOND-CORE', sides: 4, color: '#ffff00', hp: 120, bulletCount: 4, speedFactor: 1.3 },
            { name: 'PENTA-BASE', sides: 5, color: '#0f8', hp: 140, bulletCount: 5, speedFactor: 1.1 },
            { name: 'HEXAGON-NEST', sides: 6, color: '#0cc', hp: 160, bulletCount: 6, speedFactor: 1.0 },
            { name: 'HEPTA-GATE', sides: 7, color: '#44f', hp: 180, bulletCount: 7, speedFactor: 0.9 },
            { name: 'OCTAGON-COMMAND', sides: 8, color: '#f40', hp: 200, bulletCount: 8, speedFactor: 0.8 },
            { name: 'NONA-REVEALER', sides: 9, color: '#f08', hp: 220, bulletCount: 9, speedFactor: 0.7 },
            { name: 'DECA-DECIMATOR', sides: 10, color: '#fff', hp: 250, bulletCount: 10, speedFactor: 0.6 } // 超巨大・鈍重
        ];

        // --- 当たり判定（半径）設定 ---
        const ENEMY_HITBOX = {
            TRIANGLE: 12,
            CUBE: 15,
            TADPOLE: 18,
            DRAGON: 25,
            BULLET: 8      // 敵が撃ってくる赤い弾の判定サイズ
        };

        // --- エフェクト演出設定 ---
        // 敵撃破時の火花の飛散速度
        const EXPLOSION_SPEED_MAG = 2.0;
        // 敵撃破時の火花の量（1.5 = 1.5倍）
        const EXPLOSION_COUNT_MAG = 1.5;

        // --- ショット・弾丸の設定 ---
        const BULLET_SETTINGS = {
            PLAYER_SPEED: 32.0, // 自機の弾の速さ
            PLAYER_LIFE: 120,   // 自機の弾が消えるまでの時間（＝射程距離）
            ENEMY_SPEED: 10.0,  // 敵の弾の速さ
            ENEMY_LIFE: 200     // 敵の弾の射程
        };

        // --- 敵の出現（スポーン）バランス設定 ---
        const SPAWN_SETTINGS = {
            BASE_ENEMIES: 60,       // ステージ1の目標撃破数
            ENEMIES_PER_STAGE: 15,  // ステージが進む毎に増える敵の数
            MAX_WORMHOLES_BASE: 5,  // 画面内に同時に存在できるワームホールの基本数
            SPAWN_INTERVAL: 180,    // ワームホールから敵が出る間隔（60フレーム = 1秒）
            WORMHOLE_CHANCE: 0.03   // 毎フレーム、新しいワームホールが発生する確率
        };



        // --- アイテム・特殊状態の設定 ---
        // レーザーの持続時間（600フレーム = 10秒）
        const LASER_DURATION = 600;
        // 出現したアイテムが点滅して消えるまでの時間
        const ITEM_LIFE = 240;

        // --- Global Variables ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const ui = {
            overlay: document.getElementById('overlay'),
            pauseOverlay: document.getElementById('pause-overlay'),
            ost: document.getElementById('ost-ui'),
            controls: document.getElementById('controls'),
            score: document.getElementById('score-display'),
            stage: document.getElementById('stage-num'),

            weaponDisplay: document.getElementById('weapon-display'),

            shieldBar: document.getElementById('shield-bar'),
            shieldVal: document.getElementById('shield-val'),
            enemyBar: document.getElementById('enemy-bar'),
            invulnWrapper: document.getElementById('invuln-wrapper'),
            invulnBar: document.getElementById('invuln-bar'),
            msg: document.getElementById('stage-msg'),
            warn: document.getElementById('warning-msg'),
            launchBtn: document.getElementById('launch-btn'),
            knobL: document.getElementById('knob-left'),
            knobR: document.getElementById('knob-right'),
            stickL: document.getElementById('stick-left'),
            stickR: document.getElementById('stick-right'),
            btnStart: document.getElementById('btn-start'),
            btnOst: document.getElementById('btn-ost'),
            btnTitle: document.getElementById('btn-title'),
            titleText: document.querySelector('#overlay h1'),

            bossContainer: document.getElementById('boss-ui-container'),
            bossNameLabel: document.getElementById('boss-name-label'),
            bossBarFrame: document.getElementById('boss-bar-frame'),
            bossHpBarInline: document.getElementById('boss-hp-bar-inline'),

            endingHud: document.getElementById('ending-msg'),
            finalScore: document.getElementById('final-score'),
            btnBackTitle: document.getElementById('btn-back-to-title'),

            btnNextResult: document.getElementById('btn-next-result'),
            closeRankingBtn: document.getElementById("close-ranking-btn"),

            submitBtn: document.getElementById("submit-score-btn"),
            skipScoreBtn: document.getElementById("skip-score-btn"),
            nameInput: document.getElementById("player-name-input"),
            nameInputArea: document.getElementById("name-input-area"),

        };

        let width, height, worldSize = 0, camera = { x: 0, y: 0 };
        let gameState = 'TITLE';
        let previousGameState = '';
        let score = 0, frame = 0, stage = 1;
        let spawnedCount = 0, enemiesToSpawn = 0, isStageClear = false;
        let dyingTimer = 0;
        let enemiesKilled = 0;
        let isBossSpawned = false;

        const player = { x: 0, y: 0, vx: 0, vy: 0, angle: 0, satellites: [], shield: 100, weaponLevel: 1, invuln: 0, laserTimer: 0 };
        const input = { move: { x: 0, y: 0, active: false }, aim: { x: 0, y: 0, active: false }, keys: {} };
        let bullets = [], lasers = [], enemies = [], enemyBullets = [], particles = [], crystals = [], missiles = [], powerups = [], wormholes = [], scorePopups = [], gridPoints = [], rings = [], stars = [];

        // --- Audio System ---
        const BGM_FILES = {
            title: 'audio/Neo_Gravity_Title.mp3',
            clear: 'audio/Neo_Gravity_Clear.mp3',
            stages: ['audio/Neo_Gravity_00.mp3', 'audio/Neo_Gravity_01.mp3', 'audio/Neo_Gravity_02.mp3', 'audio/Neo_Gravity_03.mp3']
        };

        const AudioSys = {
            ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null,
            init() {
                if (!this.ctx) {
                    try { const AC = window.AudioContext || window.webkitAudioContext; if (AC) { this.ctx = new AC(); this.createNoise(); } } catch (e) { }
                }
                if (!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
            },
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => { }); },
            createNoise() {
                if (!this.ctx) return;
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                this.noiseBuffer = buf;
            },
            playSE(type) {
                if (!this.ctx) return;
                this.resume();
                const t = this.ctx.currentTime;
                const g = this.ctx.createGain(); g.connect(this.ctx.destination);

                if (type === 'shoot') {
                    const o = this.ctx.createOscillator(); o.type = 'triangle';
                    o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g); o.start(t); o.stop(t + 0.1);
                } else if (type === 'laser') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(120, t); o.frequency.linearRampToValueAtTime(80, t + 0.15);
                    const mod = this.ctx.createOscillator(); mod.type = 'square'; mod.frequency.value = 500;
                    const modGain = this.ctx.createGain(); modGain.gain.value = 500;
                    mod.connect(modGain); modGain.connect(o.frequency); mod.start(t); mod.stop(t + 0.15);
                    g.gain.setValueAtTime(0.15, t); g.gain.linearRampToValueAtTime(0, t + 0.15);
                    o.connect(g); o.start(t); o.stop(t + 0.15);
                } else if (type === 'explode' || type === 'dragon_explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        const startFreq = type === 'dragon_explode' ? 200 : 600;
                        const dur = type === 'dragon_explode' ? 1.5 : 0.5;
                        f.frequency.setValueAtTime(startFreq, t); f.frequency.exponentialRampToValueAtTime(20, t + dur);
                        g.gain.setValueAtTime(type === 'dragon_explode' ? 0.8 : 0.6, t); g.gain.exponentialRampToValueAtTime(0.01, t + dur);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + dur);
                    }
                } else if (type === 'launch') {
                    // --- ズゾゾッという重厚なノイズ混じり音 ---
                    if (this.noiseBuffer) {
                        // ノイズ源（ザラザラ感）
                        const n = this.ctx.createBufferSource();
                        n.buffer = this.noiseBuffer;

                        // 低音のうねり（サイン波）
                        const o = this.ctx.createOscillator();
                        o.type = 'sawtooth'; // 鋭い音

                        const filter = this.ctx.createBiquadFilter();
                        filter.type = 'lowpass';

                        // 音程とフィルターの動き（急激に下げることで射出感を出す）
                        o.frequency.setValueAtTime(400, t);
                        o.frequency.exponentialRampToValueAtTime(40, t + 0.3);
                        filter.frequency.setValueAtTime(1000, t);
                        filter.frequency.exponentialRampToValueAtTime(100, t + 0.3);

                        g.gain.setValueAtTime(0.4, t);
                        g.gain.linearRampToValueAtTime(0, t + 0.3);

                        n.connect(filter);
                        o.connect(filter);
                        filter.connect(g);

                        n.start(t); n.stop(t + 0.3);
                        o.start(t); o.stop(t + 0.3); RampToValueAtTime(0, t + 0.4);
                        o.connect(g); o.start(t); o.stop(t + 0.4);
                    }
                } else if (type === 'powerup') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1800, t + 0.2);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'damage') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(50, t + 0.2);
                    g.gain.setValueAtTime(0.4, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'invincible') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(800, t + 0.5);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.connect(g); o.start(t); o.stop(t + 0.5);
                }
            },
            playBGM(key, idx = 0) {
                if (!this.bgmEl) return;
                let src;
                if (key === 'title') src = BGM_FILES.title;
                else if (key === 'clear') src = BGM_FILES.clear;
                else {
                    // 曲リストの長さで割った余りを使うことで、ステージが進んでもループ再生される
                    const actualIdx = idx % BGM_FILES.stages.length;
                    src = BGM_FILES.stages[actualIdx];
                }

                if (this.currentSrc === src && !this.bgmEl.paused) return;
                this.bgmEl.src = src;
                this.bgmEl.currentTime = 0;
                this.bgmEl.play().catch(e => { });
                this.currentSrc = src;
            },
            stopBGM() { if (this.bgmEl) this.bgmEl.pause(); },
            pauseBGM() { if (this.bgmEl && !this.bgmEl.paused) this.bgmEl.pause(); },
            resumeBGM() { if (this.bgmEl && this.bgmEl.paused && this.currentSrc) this.bgmEl.play().catch(() => { }); }
        };
        // --- Menu Logic ---
        function openOST() {
            AudioSys.resume();
            gameState = 'OST';
            ui.overlay.style.display = 'none';
            ui.ost.style.display = 'flex';
            const list = document.getElementById('track-list');
            list.innerHTML = '';
            const tracks = [
                { n: 'Title Theme', k: 'title' },
                { n: 'Stage 1', k: 'stage', i: 0 },
                { n: 'Stage 2', k: 'stage', i: 1 },
                { n: 'Stage 3', k: 'stage', i: 2 },
                { n: 'Stage 4', k: 'stage', i: 3 },
                { n: 'Clear Theme', k: 'clear' }
            ];
            tracks.forEach(t => {
                const d = document.createElement('div'); d.className = 'track-item'; d.innerText = t.n;
                d.onclick = () => {
                    AudioSys.playBGM(t.k, t.i);
                    document.querySelectorAll('.track-item').forEach(e => e.classList.remove('playing'));
                    d.classList.add('playing');
                };
                list.appendChild(d);
            });
        }

        function closeOST() { returnToTitle(); }

        function launchSatellites() {
            if (player.satellites.length === 0) return;
            AudioSys.playSE('launch');
            player.satellites.forEach(s => {
                missiles.push({
                    x: s.x, y: s.y,
                    vx: Math.cos(s.angle) * 10 * SPEED_SCALE,
                    vy: Math.sin(s.angle) * 10 * SPEED_SCALE,
                    target: null, life: 200, speed: 12 * SPEED_SCALE
                });
            });
            player.satellites = [];
            distortGrid(player.x, player.y, 300, 400);
        }

        // --- Layout & Init ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const size = Math.max(width, height) * 1.5;
            worldSize = size;

            // Controls Layout
            const isPortrait = height > width;
            if (isPortrait) {
                ui.stickL.style.left = '40px'; ui.stickL.style.bottom = '50px'; ui.stickL.style.right = 'auto';
                ui.stickR.style.right = '40px'; ui.stickR.style.bottom = '50px'; ui.stickR.style.left = 'auto';
                ui.launchBtn.style.right = '40px'; ui.launchBtn.style.bottom = '180px';
            } else {
                ui.stickL.style.left = '20px'; ui.stickL.style.bottom = '40px';
                ui.stickR.style.right = '20px'; ui.stickR.style.bottom = '40px';
                ui.launchBtn.style.right = '20px'; ui.launchBtn.style.bottom = '170px';
            }
            initGrid();
            initStars();
        }

        function initGrid() {
            const cols = Math.ceil(worldSize / GRID_SPACING) + 2;
            const rows = Math.ceil(worldSize / GRID_SPACING) + 2;
            gridPoints = [];
            for (let x = 0; x <= cols; x++) {
                gridPoints[x] = [];
                for (let y = 0; y <= rows; y++) gridPoints[x][y] = { x: x * GRID_SPACING, y: y * GRID_SPACING, ox: x * GRID_SPACING, oy: y * GRID_SPACING, vx: 0, vy: 0 };
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({ x: Math.random() * worldSize, y: Math.random() * worldSize, size: Math.random() * 2, brightness: Math.random(), parallax: 0.2 + Math.random() * 0.3 });
            }
        }

        // --- Game Logic ---
        function startGame() {
            AudioSys.init(); AudioSys.resume(); AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            ui.overlay.style.display = 'none'; ui.ost.style.display = 'none';
            ui.controls.style.display = 'block';

            score = 0;
            stage = 1;
            frame = 0;

            player.x = worldSize / 2;
            player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 1;
            player.satellites = []; player.invuln = 0; player.laserTimer = 0;

            ui.score.innerText = "000000"; ui.stage.innerText = "1";
            // ★削除: ui.wLv.innerText = "2"; (wLvはもう存在しないため)

            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none';

            startStage();
        }

        function resetGame() {
            // Variable Reset
            score = 0; stage = 1; frame = 0;
            spawnedCount = 0; enemiesToSpawn = 0; isStageClear = false;
            bullets = []; lasers = []; enemies = []; enemyBullets = []; particles = []; crystals = []; missiles = []; powerups = []; wormholes = []; scorePopups = []; rings = [];

            player.x = worldSize / 2; player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = 100; player.weaponLevel = 1; player.invuln = 0; player.laserTimer = 0; player.satellites = [];

            // UI Reset
            ui.score.innerText = "000000"; ui.stage.innerText = "1";


            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none'; ui.msg.style.display = 'none';
            ui.overlay.style.display = 'none'; ui.controls.style.display = 'block';

            // Restart Logic
            AudioSys.playBGM('stage', 0);
            gameState = 'PLAYING';
            startStage();
        }

        function returnToTitle() {
            gameState = 'TITLE';
            ui.ost.style.display = 'none';
            ui.overlay.style.display = 'flex';
            ui.controls.style.display = 'none';
            ui.msg.style.display = 'none';

            ui.titleText.innerHTML = `NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>`;
            ui.titleText.style.color = '#0ff';
            ui.titleText.style.textShadow = '0 0 20px #0ff';

            ui.btnStart.innerText = 'START GAME';
            ui.btnStart.style.borderColor = '#0ff';
            ui.btnStart.style.color = '#0ff';
            ui.btnStart.onclick = startGame;

            ui.btnOst.style.display = 'block';
            ui.btnTitle.style.display = 'none';

            // ★タイトル画面なのでランキングボタンを再表示する
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) {
                btnRanking.style.display = 'block';
                btnRanking.style.borderColor = '#0ff';
                btnRanking.style.color = '#0ff';
            }
        }

        function startStage() {
            // ステージごとの敵総数を計算
            enemiesToSpawn = SPAWN_SETTINGS.BASE_ENEMIES + (stage * SPAWN_SETTINGS.ENEMIES_PER_STAGE);

            // --- 変数のリセット ---
            spawnedCount = 0;
            isStageClear = false;
            enemiesKilled = 0;
            isBossSpawned = false;
            // --------------------

            ui.msg.style.display = 'none';

            // 配列の初期化
            bullets = []; lasers = []; enemies = []; enemyBullets = [];
            crystals = []; missiles = []; powerups = []; wormholes = [];
            scorePopups = []; rings = [];

            // BGM変更ロジック
            if (gameState === 'PLAYING') {
                // ★修正: ステージ8まで対応するため、剰余(%)を使ってBGMを選択
                const bgmIndex = Math.floor((stage - 1) / 2) % BGM_FILES.stages.length;
                AudioSys.playBGM('stage', bgmIndex);
            }

            // ワームホールの生成
            const whCount = Math.max(1, Math.floor((stage + 1) / 2));
            for (let i = 0; i < whCount; i++) spawnWormhole();
        }

        function spawnWormhole() {
            wormholes.push({
                x: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                y: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                life: 400, maxLife: 400, active: true
            });
            distortGrid(wormholes[wormholes.length - 1].x, wormholes[wormholes.length - 1].y, 50, 150);
        }

        function spawnEnemy(x, y, type) {
            const spd = SPEED_SCALE;
            const angle = Math.random() * Math.PI * 2;
            const bSpd = 5.0 * spd;
            const vx = Math.cos(angle) * bSpd; const vy = Math.sin(angle) * bSpd;
            const rnd = Math.random();
            let dropType = rnd < 0.1 ? 'laser' : rnd < 0.3 ? 'level' : 'crystal';

            if (type === 'dragon') {
                let e = { x: x, y: y, vx: vx, vy: vy, hp: 8, speed: ENEMY_SPEEDS.DRAGON * spd, color: '#f00', type: 'dragon', angle: 0, segments: [], drop: 'none', scale: 0.9, fireTimer: 0 };
                for (let i = 0; i < 16; i++) e.segments.push({ x: x, y: y, angle: 0 });
                enemies.push(e); spawnedCount++;
            } else if (type === 'cube') {
                const r = Math.random();
                let cubeDrop;

                // シールドが30%以下なら無敵アイテムの確率を2倍(15%→30%)にする
                const invulnChance = player.shield <= 30 ? 0.30 : 0.05;

                if (r < invulnChance) cubeDrop = 'invincible';
                else if (r < 0.40) cubeDrop = 'laser';
                else if (r < 0.70) cubeDrop = 'level';
                else cubeDrop = 'crystal';

                enemies.push({ x, y, vx, vy, hp: 2, speed: ENEMY_SPEEDS.CUBE * spd, color: '#0f0', type: 'cube', angle: 0, drop: cubeDrop, scale: 0.8, rotX: 0, rotY: 0 });
                spawnedCount++;
            } else if (type === 'tadpole') {
                enemies.push({ x, y, vx, vy, hp: 1, speed: ENEMY_SPEEDS.TADPOLE * spd, color: '#fff', type: 'tadpole', angle: 0, drop: 'none', scale: 0.6, history: [] });
                spawnedCount++;
            } else if (type === 'triangle') {
                const forms = ['V', 'line', 'circle'];
                const form = forms[Math.floor(Math.random() * forms.length)];
                const initialAngle = Math.atan2(vy, vx);
                const leader = { x: x, y: y, vx: vx, vy: vy, hp: 1, speed: ENEMY_SPEEDS.TRIANGLE * spd, color: '#d0f', type: 'triangle', angle: initialAngle, drop: dropType, scale: 0.7, isLeader: true, followers: [], rotX: Math.random() * Math.PI, rotY: Math.random() * Math.PI, rotZ: Math.random() * Math.PI };
                enemies.push(leader); spawnedCount++;
                for (let i = 1; i <= 4; i++) {
                    if (spawnedCount >= enemiesToSpawn) break;
                    let offX = 0, offY = 0;
                    if (form === 'V') { offX = Math.ceil(i / 2) * -30; offY = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 20; }
                    else if (form === 'line') { offX = -Math.ceil(i / 2) * 45; }
                    else { const a = (Math.PI * 2 / 5) * i; offX = Math.cos(a) * 40; offY = Math.sin(a) * 40; }
                    const rx = offX * Math.cos(initialAngle) - offY * Math.sin(initialAngle);
                    const ry = offX * Math.sin(initialAngle) + offY * Math.cos(initialAngle);
                    let e = { x: x + rx, y: y + ry, vx, vy, hp: 1, speed: ENEMY_SPEEDS.TRIANGLE * spd, color: '#d0f', type: 'triangle', angle: initialAngle, drop: 'none', scale: 0.7, leader: leader, formOffset: { x: offX, y: offY }, rotX: Math.random() * Math.PI, rotY: Math.random() * Math.PI, rotZ: Math.random() * Math.PI };
                    enemies.push(e); leader.followers.push(e); spawnedCount++;
                }
            } else if (type === 'boss') {
                const variantIndex = (stage - 1) % BOSS_VARIANTS.length;
                const variant = BOSS_VARIANTS[variantIndex];

                enemies.push({
                    x: x, y: y,
                    vx: vx * 0.2, vy: vy * 0.2,
                    hp: variant.hp, // ここが variant.hp になっているか確認
                    maxHp: variant.hp, // HPバー計算用に保持しておくと便利
                    speed: 1.2 * variant.speedFactor * spd, // ベース速度を調整
                    color: variant.color,
                    type: 'boss',
                    variant: variant,
                    angle: 0,
                    drop: 'level',
                    scale: 1.5 + (variant.sides * 0.1), // 頂点数が多いほど巨大にする演出
                    fireTimer: 0,
                    flashTimer: 0
                });
                spawnedCount++;
            }
        }

        // --- Main Loop ---
        function loop() {
            requestAnimationFrame(loop);
            if (gameState === 'PAUSED') return;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);

            if (gameState === 'PLAYING') update();
            else if (gameState === 'DYING') updateDying();
            // ★ENDING中もパーティクルなどは動かし続ける
            else if (gameState === 'ENDING') {
                updateParticlesAndRings();
                updateGrid();
            }

            draw();
        }

        function updateDying() {
            dyingTimer--;
            camera.x += (Math.random() - 0.5) * 5; camera.y += (Math.random() - 0.5) * 5;
            updateGrid(); updateParticlesAndRings(); updateEnemyBullets(); updateEnemiesForDying();
            if (dyingTimer <= 0) showGameOver();
        }

        function updateEnemiesForDying() {
            enemies.forEach(e => {
                // 自機から敵機へのベクトル（逃げる方向）
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const d = Math.hypot(dx, dy) || 0.001;

                // 離脱ベクトルを計算（徐々に加速して去っていく）
                const escapeSpeed = e.speed * 1.5; // 離脱なので少し速めに
                e.vx += (dx / d) * 0.1;
                e.vy += (dy / d) * 0.1;

                // 速度制限をかけつつ更新
                const cv = Math.hypot(e.vx, e.vy);
                if (cv > escapeSpeed) {
                    e.vx = (e.vx / cv) * escapeSpeed;
                    e.vy = (e.vy / cv) * escapeSpeed;
                }

                e.x += e.vx;
                e.y += e.vy;

                // 進行方向を向かせる
                e.angle = Math.atan2(e.vy, e.vx);

                // 各種演出の更新（しっぽやパーツ回転）
                if (e.type === 'dragon') {
                    let lx = e.x, ly = e.y;
                    e.segments.forEach(s => {
                        const dd = Math.hypot(lx - s.x, ly - s.y);
                        if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; }
                        lx = s.x; ly = s.y;
                    });
                }
                if (e.type === 'tadpole') {
                    e.history.unshift({ x: e.x, y: e.y });
                    if (e.history.length > 60) e.history.pop();
                }
                if (e.type === 'triangle' || e.type === 'cube') {
                    e.rotX += 0.1; e.rotY += 0.1;
                }
            });
        }

        // ゲームオーバー（失敗）時
        function showGameOver() {
            if (gameState === 'GAMEOVER_UI') return;
            gameState = 'GAMEOVER_UI';

            AudioSys.stopBGM();
            ui.controls.style.display = 'none';

            // 10ms待機してメインスレッドを解放（フリーズ対策）
            setTimeout(() => {
                ui.overlay.style.display = 'none';
                document.getElementById('result-score-display').innerText = `SCORE: ${score.toLocaleString()}`;
                ui.nameInputArea.style.display = 'flex';

                // 送信ボタンの処理
                ui.submitBtn.onclick = async () => {
                    await window.submitScore(score, stage);
                };

                // スキップボタンの処理
                ui.skipScoreBtn.onclick = (e) => {
                    e.preventDefault();
                    proceedToNextMenu();
                };

                ui.nameInput.focus();
            }, 10);
        }

        // 送信またはスキップした後に呼ばれる「次の画面」
        function proceedToNextMenu() {
            ui.nameInputArea.style.display = 'none';
            ui.overlay.style.display = 'flex';

            // タイトルの設定
            let titleHTML = `GAME OVER<br><span style="font-size:20px;color:#f00;">SCORE: ${score.toLocaleString()}</span>`;
            let titleColor = '#f00';

            if (isStageClear) {
                titleHTML = `MISSION COMPLETE<br><span style="font-size:20px;color:#0ff;">SCORE: ${score.toLocaleString()}</span>`;
                titleColor = '#0ff';
            }

            ui.titleText.innerHTML = titleHTML;
            ui.titleText.style.color = titleColor;
            ui.titleText.style.textShadow = `0 0 20px ${titleColor}`;

            // ボタン類の設定
            ui.btnStart.innerText = 'RETRY';
            ui.btnStart.style.display = 'block';
            ui.btnStart.style.borderColor = titleColor;
            ui.btnStart.style.color = titleColor;
            ui.btnStart.onclick = () => resetGame();

            ui.btnTitle.style.display = 'block';
            ui.btnTitle.style.borderColor = titleColor;
            ui.btnTitle.style.color = titleColor;
            ui.btnTitle.onclick = () => returnToTitle();

            // ★修正ポイント：ランキングボタンとOSTボタンを非表示にする
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) btnRanking.style.display = 'none';
            if (ui.btnOst) ui.btnOst.style.display = 'none';
        }

        function update() {
            frame++;

            if (!Number.isFinite(player.x)) { player.x = worldSize / 2; player.y = worldSize / 2; player.vx = 0; player.vy = 0; }

            // Controls
            let mx = input.keys['ArrowLeft'] ? -1 : input.keys['ArrowRight'] ? 1 : input.move.x;
            let my = input.keys['ArrowUp'] ? -1 : input.keys['ArrowDown'] ? 1 : input.move.y;
            const mag = Math.hypot(mx, my); if (mag > 1) { mx /= mag; my /= mag; }
            player.vx = mx * 7.8 * SPEED_SCALE; player.vy = my * 7.8 * SPEED_SCALE;
            player.x += player.vx; player.y += player.vy;
            if (player.x < WALL_MARGIN) player.x = WALL_MARGIN; if (player.x > worldSize - WALL_MARGIN) player.x = worldSize - WALL_MARGIN;
            if (player.y < WALL_MARGIN) player.y = WALL_MARGIN; if (player.y > worldSize - WALL_MARGIN) player.y = worldSize - WALL_MARGIN;
            camera.x = player.x - width / 2; camera.y = player.y - height / 2;

            if (input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
            else if (Math.hypot(mx, my) > 0.1) player.angle = Math.atan2(my, mx);

            const fireInterval = player.laserTimer > 0 ? 4 : 6;
            if ((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % fireInterval === 0) fire();

            // 雑魚敵のスポーン
            const maxWormholes = SPAWN_SETTINGS.MAX_WORMHOLES_BASE + stage;
            if (spawnedCount < enemiesToSpawn && wormholes.filter(w => w.active).length < maxWormholes && Math.random() < SPAWN_SETTINGS.WORMHOLE_CHANCE) {
                spawnWormhole();
            }

            wormholes.forEach((w) => {
                w.life--;
                if (w.active) {
                    if (w.life > 60 && w.life % SPAWN_SETTINGS.SPAWN_INTERVAL === 0 && spawnedCount < enemiesToSpawn) {

                        // 残りの出現予定数を計算
                        const remaining = enemiesToSpawn - spawnedCount;
                        // 出現させるタイミング（全体の1/5以下になったら）
                        const threshold = Math.floor(enemiesToSpawn / 5);

                        // まだボスが出ておらず、残り数が閾値を切ったら確定で出現
                        if (!isBossSpawned && remaining <= threshold) {
                            spawnEnemy(w.x, w.y, 'boss'); // ★ここを 'boss' にすることでバリエーション機能が働きます
                            isBossSpawned = true;
                        } else {
                            // それ以外は通常の敵をランダム出現（確率は微調整）
                            const r = Math.random();
                            if (r < 0.20) spawnEnemy(w.x, w.y, 'dragon');
                            else if (r < 0.35) spawnEnemy(w.x, w.y, 'cube');
                            else if (r < 0.65) spawnEnemy(w.x, w.y, 'tadpole');
                            else spawnEnemy(w.x, w.y, 'triangle');
                        }
                    }
                    if (w.life <= 0) w.active = false;
                    const dx = player.x - w.x; const dy = player.y - w.y;
                    const d = Math.hypot(dx, dy) || 0.01;
                    if (d < 180) { const f = 500 / (d + 1); player.x += (dx / d) * f * 0.01; player.y += (dy / d) * f * 0.01; }
                }
            });
            wormholes = wormholes.filter(w => w.life > -60);

            player.satellites.forEach((s, i) => {
                s.angle = (s.angle || 0) + 0.15;
                const rad = 45 * G_SCALE;
                const off = (Math.PI * 2 / player.satellites.length) * i;
                s.x = player.x + Math.cos(s.angle + off) * rad; s.y = player.y + Math.sin(s.angle + off) * rad;
            });

            updateEntities();
            updateGrid();
            updateScorePopups();
            checkStageClear();

            // --- ボスHPバーの更新ロジック ---
            const currentBoss = enemies.find(e => e.type === 'boss');
            if (currentBoss) {
                ui.bossContainer.style.display = 'block';
                const hpPct = Math.max(0, (currentBoss.hp / currentBoss.variant.hp) * 100);
                const bColor = currentBoss.color; // ボスの色を取得

                // --- バーの色と光をボスに合わせる ---
                ui.bossHpBarInline.style.width = hpPct + "%";
                ui.bossHpBarInline.style.backgroundColor = bColor;
                ui.bossHpBarInline.style.boxShadow = `0 0 10px ${bColor}`;

                // 枠の色とラベルの色も合わせる
                ui.bossBarFrame.style.borderColor = bColor;
                ui.bossNameLabel.style.color = bColor;
                ui.bossNameLabel.innerText = "BOSS: " + currentBoss.variant.name;

                // ピンチ時の点滅演出（白く光らせる）
                if (hpPct < 25 && frame % 10 < 5) {
                    ui.bossHpBarInline.style.backgroundColor = '#fff';
                }
            } else {
                ui.bossContainer.style.display = 'none';
            }

            // 敵の総数 - 倒した数 = 残り数 (0未満にならないようにMath.maxを使用)
            const enemyRemains = Math.max(0, enemiesToSpawn - enemiesKilled);

            // 割合を計算してゲージ幅に適用
            ui.enemyBar.style.width = `${(enemyRemains / enemiesToSpawn) * 100}%`;

            // テキスト表示
            document.querySelector('.bar-label.enemy').innerText = `ENEMY SWARM: ${enemyRemains}`;

            if (player.shield < 30) ui.shieldBar.classList.add('shield-critical');
            else ui.shieldBar.classList.remove('shield-critical');

            // 武器表示の更新
            ui.weaponDisplay.innerHTML = '';
            if (player.laserTimer > 0) {
                const maxTime = 600;
                const pct = Math.max(0, (player.laserTimer / maxTime) * 100);
                const frameDiv = document.createElement('div');
                frameDiv.className = 'laser-bar-frame';
                const fillDiv = document.createElement('div');
                fillDiv.className = 'laser-bar-fill';
                fillDiv.style.width = pct + '%';
                if (player.laserTimer < 120 && Math.floor(frame / 4) % 2 === 0) fillDiv.style.opacity = 0.3;
                frameDiv.appendChild(fillDiv);
                ui.weaponDisplay.appendChild(frameDiv);
                player.laserTimer--;
            } else {
                for (let i = 1; i <= MAX_WEAPON_LEVEL; i++) {
                    const block = document.createElement('div');
                    block.className = 'w-block';
                    if (i <= player.weaponLevel) block.classList.add('active');
                    ui.weaponDisplay.appendChild(block);
                }
            }

            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            if (ui.shieldVal) ui.shieldVal.innerText = Math.floor(Math.max(0, player.shield));

            if (player.invuln > 20) {
                ui.invulnWrapper.style.display = 'block';
                const pct = Math.min(100, (player.invuln / 600) * 100);
                ui.invulnBar.style.width = pct + "%";
                if (player.invuln < 120 && Math.floor(frame / 4) % 2 === 0) ui.invulnBar.style.opacity = 0.3;
                else ui.invulnBar.style.opacity = 1.0;
            } else {
                ui.invulnWrapper.style.display = 'none';
            }
        }

        function fire() {
            if (player.laserTimer > 0) {
                lasers.push({ x: player.x, y: player.y, angle: player.angle, life: 5, width: 40 });
                AudioSys.playSE('laser'); distortGrid(player.x, player.y, 20, 60); return;
            }

            const s = BULLET_SETTINGS.PLAYER_SPEED * SPEED_SCALE;
            // レベルごとの発射角度オフセット設定（0 = 前方、Math.PI = 後方）
            const shotPatterns = {
                1: [0.08, -0.08], // 2way
                2: [0.15, 0, -0.15], // 3way(前のみ)
                3: [0.15, 0, -0.15, Math.PI], // 4way(前3 後1)
                4: [0.15, 0, -0.15, Math.PI - 0.15, Math.PI + 0.15], // 5way(前3 後2)
                5: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15], // 6way(前4 後2)
                6: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2], // 7way(前4 後2 左右1ずつ)
                7: [0.25, 0.12, 0, -0.12, -0.25, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2] // 8way(前5後2 左右1ずつ)
            };

            // 現在のレベルのパターンを取得（最大レベルを超えないように制限）
            const currentPattern = shotPatterns[player.weaponLevel] || shotPatterns[1];

            currentPattern.forEach(offset => {
                const a = player.angle + offset;
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: BULLET_SETTINGS.PLAYER_LIFE });
            });

            AudioSys.playSE('shoot'); distortGrid(player.x, player.y, 10, 40);
        }

        function updateEntities() {
            updatePlayerBullets();
            updateLasers();
            updateEnemies();
            updateEnemyBullets();
            updateCrystals();
            updatePowerups();
            updateMissiles();
            updateParticlesAndRings();
            updatePlayerStatus();
        }

        function updateLasers() {
            lasers.forEach(l => {
                l.life--;
                const len = 2000;
                const p1x = l.x;
                const p1y = l.y;
                const p2x = l.x + Math.cos(l.angle) * len;
                const p2y = l.y + Math.sin(l.angle) * len;

                // 1. 敵機（enemies）との判定
                enemies.forEach(e => {
                    const A = p1x - p2x; const B = p1y - p2y; const C = p2x * p1y - p1x * p2y;
                    const dist = Math.abs(A * e.y - B * e.x + C) / Math.hypot(A, B);
                    const dot = (e.x - p1x) * (p2x - p1x) + (e.y - p1y) * (p2y - p1y);
                    if (dist < (l.width / 2 + 15 * e.scale) && dot > 0) {
                        e.hp -= 0.5;
                        if (frame % 4 === 0) particles.push({ x: e.x, y: e.y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, color: '#0ff', life: 0.5 });
                    }
                });

                // 2. ★すべての敵弾（enemyBullets）との判定
                enemyBullets.forEach(eb => {
                    // 点と線分の距離を計算
                    const A = p1x - p2x; const B = p1y - p2y; const C = p2x * p1y - p1x * p2y;
                    const dist = Math.abs(A * eb.y - B * eb.x + C) / Math.hypot(A, B);
                    const dot = (eb.x - p1x) * (p2x - p1x) + (eb.y - p1y) * (p2y - p1y);

                    // レーザーの幅（l.width/2）に敵弾のサイズを考慮した範囲
                    if (dist < (l.width / 2 + 5) && dot > 0) {
                        eb.life = 0; // 弾を消滅させる

                        // ミサイルの場合は爆発、普通の弾は火花
                        if (eb.isMissile) {
                            score += 50;
                            createExplosion(eb.x, eb.y, eb.color, 15);
                            AudioSys.playSE('explode');
                        } else {
                            score += 10;
                            particles.push({
                                x: eb.x, y: eb.y,
                                vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                color: '#fff', life: 0.2
                            });
                        }
                    }
                });
            });
            lasers = lasers.filter(l => l.life > 0);
        }

        function updatePlayerBullets() {
            bullets.forEach(b => {
                b.x += b.vx; b.y += b.vy; b.life--;
                enemies.forEach(e => {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < 30 * e.scale) {
                        b.life = 0;
                        e.hp--;
                        // ボスへのダメージ演出
                        if (e.type === 'boss') {
                            e.flashTimer = 5;
                            AudioSys.playSE('damage');
                            for (let i = 0; i < 3; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    color: '#fff', life: 0.2, size: 2
                                });
                            }
                        }
                    }
                });
            });
            bullets = bullets.filter(b => b.life > 0);
        }

        function updateEnemies() {
            enemies.forEach(e => {
                if (e.leader && e.leader.hp > 0) { updateFormationMovement(e); if (e.type === 'triangle') { e.rotX += 0.08; e.rotY += 0.12; e.rotZ += 0.05; } }
                else {
                    switch (e.type) {
                        case 'dragon': updateDragonAI(e); break;
                        case 'tadpole': updateTadpoleAI(e); break;
                        case 'triangle': updateTriangleAI(e); break;
                        case 'cube': updateCubeAI(e); break;
                        case 'boss': updateBossAI(e); break;
                    }
                }
                applySeparation(e); applyWorldBoundary(e); checkPlayerCollision(e); checkSatelliteCollision(e);
                if (e.hp <= 0) destroyEnemy(e);
            });
            enemies = enemies.filter(e => e.hp > 0);
        }

        function updateDragonAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * DRAGON_ACCELERATION * SPEED_SCALE; e.vy += (dy / d) * DRAGON_ACCELERATION * SPEED_SCALE; e.vx *= 0.98; e.vy *= 0.98;
            const cv = Math.hypot(e.vx, e.vy); const lim = ENEMY_SPEEDS.DRAGON * SPEED_SCALE;
            if (cv > lim) { e.vx = (e.vx / cv) * lim; e.vy = (e.vy / cv) * lim; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(dy, dx);
            let lx = e.x, ly = e.y; e.segments.forEach(s => { const dd = Math.hypot(lx - s.x, ly - s.y); if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; } lx = s.x; ly = s.y; });
            e.fireTimer++;
            if (e.fireTimer > 100) { e.fireTimer = 0; const bSpd = BULLET_SETTINGS.ENEMY_SPEED * SPEED_SCALE; enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(e.angle) * bSpd, vy: Math.sin(e.angle) * bSpd, life: BULLET_SETTINGS.ENEMY_LIFE }); AudioSys.playSE('shoot'); }
        }

        function updateTadpoleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(dy, dx);
            e.history.unshift({ x: e.x, y: e.y }); if (e.history.length > 60) e.history.pop();
        }

        function updateTriangleAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.angle = Math.atan2(e.vy, e.vx); e.rotX += 0.08; e.rotY += 0.12; e.rotZ += 0.05;
        }

        function updateCubeAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE; e.vy += (dy / d) * 0.2 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy; e.rotX += 0.03; e.rotY += 0.04;
        }

        function updateBossAI(e) {
            // --- 1. 移動ロジック ---
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.02 * SPEED_SCALE;
            e.vy += (dy / d) * 0.02 * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx; e.y += e.vy;

            // --- 2. 高速回転・停止・発射・硬直ロジック ---
            e.fireTimer++;

            const maxCycle = 280;   // 全体のサイクルを少し長めに設定
            const brakeStart = 160; // 減速開始タイミング
            const fireTime = 220;   // 発射タイミング（ここで完全に止まる）
            const restartTime = 250; // 硬直が解けて再回転するタイミング

            let rotationSpeed = 0.08; // 通常時の高速回転

            if (e.fireTimer > brakeStart && e.fireTimer < fireTime) {
                // 【減速フェーズ】発射に向けてゆっくりに
                const ratio = 1.0 - (e.fireTimer - brakeStart) / (fireTime - brakeStart);
                rotationSpeed = Math.pow(ratio, 1.5) * 0.08;

                // エネルギー収束パーティクル
                if (frame % 3 === 0) {
                    const ang = Math.random() * Math.PI * 2;
                    particles.push({
                        x: e.x + Math.cos(ang) * 80, y: e.y + Math.sin(ang) * 80,
                        vx: -Math.cos(ang) * 4, vy: -Math.sin(ang) * 4,
                        color: '#fff', life: 0.2, size: 1.5
                    });
                }
            }
            else if (e.fireTimer >= fireTime && e.fireTimer < restartTime) {
                // 【発射＆硬直フェーズ】完全に停止
                rotationSpeed = 0;

                // 発射の瞬間（fireTime ぴったり）に弾を生成
                if (e.fireTimer === fireTime) {
                    const sides = e.variant.sides;
                    camera.x += (Math.random() - 0.5) * 30; // 強い衝撃
                    camera.y += (Math.random() - 0.5) * 30;

                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 60, y: e.y + Math.sin(a) * 60,
                            vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5,
                            life: 300, isMissile: true, color: e.color
                        });
                    }
                    AudioSys.playSE('launch');
                    rings.push({ x: e.x, y: e.y, r: 20, color: '#fff', life: 1.0 });
                    rings.push({ x: e.x, y: e.y, r: 100, color: e.color, life: 0.8 });
                }
            }
            else if (e.fireTimer >= restartTime) {
                // 【再始動フェーズ】徐々に元の回転速度に戻る
                const ratio = (e.fireTimer - restartTime) / (maxCycle - restartTime);
                rotationSpeed = Math.pow(ratio, 2) * 0.08;
            }

            e.angle += rotationSpeed;
            if (e.fireTimer >= maxCycle) e.fireTimer = 0;
        }

        // --- ボス描画 ---
        function drawBossEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            const color = (e.flashTimer > 0) ? '#ffffff' : e.color;
            if (e.flashTimer > 0) e.flashTimer--;

            ctx.strokeStyle = color;
            ctx.shadowBlur = (e.flashTimer > 0) ? 30 : 10;
            ctx.shadowColor = color;

            const sides = e.variant.sides;
            const radius = 45;

            // --- 1. 極細の内部回路（グリッド・サブフレーム） ---
            ctx.lineWidth = 0.4;
            ctx.globalAlpha = 0.4;
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                const nextA = (Math.PI * 2 / sides) * (i + 1);

                // 放射状トラスの描き込み
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(a) * radius, Math.sin(a) * radius);
                ctx.stroke();

                // 頂点間を結ぶサブ・ブリッジ（三角形の補強材）
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * radius * 0.6, Math.sin(a) * radius * 0.6);
                ctx.lineTo(Math.cos(nextA) * radius * 0.6, Math.sin(nextA) * radius * 0.6);
                ctx.lineTo(0, 0);
                ctx.stroke();
            }

            // --- 2. 多層レイヤー装甲 (0.6px〜1.2pxの多重線) ---
            ctx.globalAlpha = 1.0;
            const layers = [
                { r: radius, w: 1.5 },       // 最外郭
                { r: radius - 2, w: 0.5 },   // 溝
                { r: radius - 5, w: 0.8 },   // 第2装甲
                { r: radius - 15, w: 0.5 },  // 内部放熱環
                { r: radius - 18, w: 0.5 }   // 内部放熱環2
            ];

            layers.forEach(layer => {
                ctx.lineWidth = layer.w;
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const a = (Math.PI * 2 / sides) * i;
                    ctx.lineTo(Math.cos(a) * layer.r, Math.sin(a) * layer.r);
                }
                ctx.stroke();
            });

            // --- 3. メカニカル・スリット (装甲の継ぎ目) ---
            ctx.lineWidth = 0.5;
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i + (Math.PI / sides); // 辺の中点
                ctx.save();
                ctx.rotate(a);
                // 辺の上に冷却スリットを描画
                for (let k = 0; k < 4; k++) {
                    const lineX = 40 - k * 3;
                    ctx.beginPath();
                    ctx.moveTo(lineX, -5); ctx.lineTo(lineX, 5);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // --- 4. クアッド・コア・リアクター (中心部) ---
            ctx.save();
            ctx.rotate(-e.angle * 3); // 高速逆回転
            ctx.lineWidth = 0.6;
            for (let m = 0; m < 4; m++) {
                ctx.rotate(Math.PI / 2);
                ctx.strokeRect(4, 4, 8, 8); // 四隅のサブコア
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.lineTo(4, 4);
                ctx.stroke();
            }
            // センターサークル
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.lineWidth = 1.2;
            ctx.stroke();
            // コア発光
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.3 + Math.abs(Math.sin(frame * 0.1)) * 0.4;
            ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // --- 5. 高密度・連装砲塔ユニット ---
            ctx.globalAlpha = 1.0;
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                ctx.save();
                ctx.translate(Math.cos(a) * radius, Math.sin(a) * radius);
                ctx.rotate(a);

                // 基部の多段構造
                ctx.lineWidth = 0.8;
                ctx.strokeRect(-10, -12, 12, 24); // 大型基部
                ctx.lineWidth = 0.5;
                ctx.strokeRect(-14, -8, 4, 16);  // 後部冷却ユニット

                // 複雑な砲身系 (三連装風)
                ctx.lineWidth = 1.0;
                ctx.beginPath();
                // 上段
                ctx.moveTo(2, -6); ctx.lineTo(24, -6); ctx.lineTo(24, -3); ctx.lineTo(2, -3);
                // 中段（少し短く）
                ctx.moveTo(2, -1.5); ctx.lineTo(18, -1.5); ctx.lineTo(18, 1.5); ctx.lineTo(2, 1.5);
                // 下段
                ctx.moveTo(2, 3); ctx.lineTo(24, 3); ctx.lineTo(24, 6); ctx.lineTo(2, 6);
                ctx.stroke();

                // 砲身の接続ボルト
                ctx.strokeRect(10, -7, 2, 14);

                ctx.restore();
            }

            ctx.restore();
        }

        // --- ミサイル描画 ---
        function drawHomingMissile(ctx, eb) {
            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);
            const mSize = 12 * G_SCALE;
            ctx.strokeStyle = eb.color || '#f00';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 12;
            ctx.shadowColor = ctx.strokeStyle;
            ctx.beginPath();
            ctx.moveTo(mSize, 0);
            ctx.lineTo(-mSize, mSize * 0.6);
            ctx.lineTo(-mSize * 0.4, 0);
            ctx.lineTo(-mSize, -mSize * 0.6);
            ctx.closePath(); ctx.stroke();
            if (frame % 2 === 0) {
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-mSize * 0.5, 0, 2 * G_SCALE, 0, Math.PI * 2); ctx.fill();
            }
        }



        function updateFormationMovement(e) {
            if (!e.leader || e.leader.hp <= 0) return;
            const la = e.leader.angle;
            const rotatedOffX = e.formOffset.x * Math.cos(la) - e.formOffset.y * Math.sin(la);
            const rotatedOffY = e.formOffset.x * Math.sin(la) + e.formOffset.y * Math.cos(la);
            const targetX = e.leader.x + rotatedOffX; const targetY = e.leader.y + rotatedOffY;
            e.x += (targetX - e.x) * 0.3; e.y += (targetY - e.y) * 0.3;
            e.vx = e.leader.vx; e.vy = e.leader.vy; e.angle = la;
        }

        function applySeparation(e) {
            enemies.forEach(other => {
                if (e === other) return;
                const odx = e.x - other.x, ody = e.y - other.y; const od = Math.hypot(odx, ody);
                if (od < 30) { const push = (30 - od) * 0.05; e.x += (odx / od) * push; e.y += (ody / od) * push; }
            });
        }

        function applyWorldBoundary(e) {
            if (e.x < WALL_MARGIN || e.x > worldSize - WALL_MARGIN) e.vx *= -1.2;
            if (e.y < WALL_MARGIN || e.y > worldSize - WALL_MARGIN) e.vy *= -1.2;
            e.x = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.x));
            e.y = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.y));
        }

        function checkPlayerCollision(e) {
            if (gameState === 'DYING' || gameState === 'GAMEOVER') return;

            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            let radius = 15;
            if (e.type === 'triangle') radius = ENEMY_HITBOX.TRIANGLE;
            else if (e.type === 'cube') radius = ENEMY_HITBOX.CUBE;
            else if (e.type === 'tadpole') radius = ENEMY_HITBOX.TADPOLE;
            else if (e.type === 'dragon') radius = ENEMY_HITBOX.DRAGON;
            else if (e.type === 'boss') radius = 45; // ボスの判定サイズ

            const collisionDist = radius * (e.scale / 0.7) + (player.invuln > 0 ? 20 : 0);

            if (dist < collisionDist) {
                // --- ★無敵バリア展開中の体当たり処理 ---
                if (player.invuln > 0) {
                    if (e.type === 'boss' || e.type === 'dragon') {
                        // ボスやドラゴンの場合はHPを削る（多段ヒット）
                        e.hp -= 0.5;
                        if (e.type === 'boss') e.flashTimer = 5;
                        // 火花エフェクト
                        if (frame % 3 === 0) {
                            createExplosion(e.x, e.y, '#ff0', 3);
                            AudioSys.playSE('damage');
                        }
                    } else {
                        // 雑魚敵は即死
                        e.hp = 0;
                        score += 100;
                        createExplosion(e.x, e.y, e.color, 15);
                        AudioSys.playSE('explode');
                        distortGrid(e.x, e.y, 30, 60);
                    }
                    return; // 自分がダメージを受ける処理をスキップ
                }

                // --- 通常時のダメージ処理 ---
                player.shield -= 0.5;
                if (player.invuln <= 0) {
                    player.shield -= 10;
                    player.invuln = 10;
                    createExplosion(player.x, player.y, '#f00', 5);
                    AudioSys.playSE('damage');
                }
                ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                if (player.shield <= 0) damage(0);
            }
        }

        function checkSatelliteCollision(e) {
            for (let i = player.satellites.length - 1; i >= 0; i--) {
                const s = player.satellites[i];
                if (Math.hypot(s.x - e.x, s.y - e.y) < 25) { e.hp = 0; player.satellites.splice(i, 1); e.noDrop = true; break; }
            }
        }

        function updateEnemyBullets() {
            enemyBullets.forEach(eb => {
                // --- ミサイルの挙動制御 ---
                if (eb.isMissile) {
                    // 1. 初速の減衰（慣性による減速）
                    // 発射直後は vx, vy が大きいので、徐々に空気抵抗のように減速させる
                    eb.vx *= 0.96;
                    eb.vy *= 0.96;

                    const dx = player.x - eb.x;
                    const dy = player.y - eb.y;
                    const dist = Math.hypot(dx, dy) || 0.001;

                    // 2. 追尾力の適用
                    // 減速してきたところで、徐々に自機に向かう加速を加える
                    eb.vx += (dx / dist) * 0.25 * SPEED_SCALE;
                    eb.vy += (dy / dist) * 0.25 * SPEED_SCALE;

                    // 3. 巡航速度の制限
                    // 現在のスピードに合わせて、最終的な巡航速度に抑える
                    const v = Math.hypot(eb.vx, eb.vy);
                    const cruiseSpeed = 5 * SPEED_SCALE; // 今までのスピードに近い安定速度
                    if (v > cruiseSpeed) {
                        // 急激に落とさず、滑らかに巡航速度へ近づける
                        eb.vx = (eb.vx / v) * (v * 0.9 + cruiseSpeed * 0.1);
                        eb.vy = (eb.vy / v) * (v * 0.9 + cruiseSpeed * 0.1);
                    }

                    // 煙演出（色味のある城/ボスの色）
                    if (frame % 2 === 0) {
                        particles.push({
                            x: eb.x, y: eb.y,
                            vx: -eb.vx * 0.2, vy: -eb.vy * 0.2,
                            color: eb.color, life: 0.3, size: 1.5
                        });
                    }

                    // プレイヤーの弾との当たり判定（変更なし）
                    bullets.forEach(b => {
                        if (b.life > 0 && Math.hypot(b.x - eb.x, b.y - eb.y) < 20) {
                            eb.life = 0; b.life = 0;
                            score += 50;
                            createExplosion(eb.x, eb.y, eb.color, 15);
                            AudioSys.playSE('explode');
                        }
                    });
                }

                // --- 移動と判定の共通処理 ---
                const oldX = eb.x;
                const oldY = eb.y;
                eb.x += eb.vx;
                eb.y += eb.vy;
                eb.life--;


                if (gameState !== 'DYING' && player.invuln <= 0) {
                    const dx = eb.x - oldX;
                    const dy = eb.y - oldY;
                    const t = ((player.x - oldX) * dx + (player.y - oldY) * dy) / (dx * dx + dy * dy);
                    const closestT = Math.max(0, Math.min(1, t));
                    const closestX = oldX + closestT * dx;
                    const closestY = oldY + closestT * dy;

                    const dist = Math.hypot(player.x - closestX, player.y - closestY);
                    const hitboxSize = eb.isMissile ? ENEMY_HITBOX.BULLET * 1.5 : ENEMY_HITBOX.BULLET;

                    if (dist < hitboxSize) {
                        eb.life = 0;
                        createExplosion(player.x, player.y, eb.color || '#f00', 10);
                        damage(15);
                    }
                }
            });
            enemyBullets = enemyBullets.filter(eb => eb.life > 0);
        }

        function updateCrystals() {
            crystals.forEach(c => {
                c.life--;
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const d = Math.hypot(dx, dy) || 0.0001;

                const speed = 2.5 + (d * 0.02);
                const moveAmount = Math.min(d, speed);

                c.x += (dx / d) * moveAmount;
                c.y += (dy / d) * moveAmount;

                if (d < 20) {
                    c.life = 0;
                    if (player.satellites.length < 12) player.satellites.push({});
                }
            });
            crystals = crystals.filter(c => c.life > 0);
        }

        function updatePowerups() {
            powerups.forEach(p => {
                p.life--;
                const d = Math.hypot(player.x - p.x, player.y - p.y);
                if (d < 30) {
                    p.life = 0; AudioSys.playSE('powerup');
                    if (p.type === 'laser') { player.laserTimer = LASER_DURATION; rings.push({ x: player.x, y: player.y, r: 10, color: '#0ff', life: 1 }); rings.push({ x: player.x, y: player.y, r: 50, color: '#0ff', life: 1 }); }
                    else if (p.type === 'invincible') { player.invuln = 600; AudioSys.playSE('invincible'); }
                    else if (p.type === 'level') {
                        player.weaponLevel = Math.min(MAX_WEAPON_LEVEL, player.weaponLevel + 1);
                    }
                }
            });
            powerups = powerups.filter(p => p.life > 0);
        }

        function updateMissiles() {
            missiles.forEach(m => {
                if (!m.target || !enemies.includes(m.target)) { let min = 9999; enemies.forEach(e => { const d = Math.hypot(e.x - m.x, e.y - m.y); if (d < min) { min = d; m.target = e; } }); }
                if (m.target) { const ta = Math.atan2(m.target.y - m.y, m.target.x - m.x); m.vx += Math.cos(ta) * 0.5; m.vy += Math.sin(ta) * 0.5; }
                const s = Math.hypot(m.vx, m.vy); if (s > 0.001) { m.vx = (m.vx / s) * m.speed; m.vy = (m.vy / s) * m.speed; }
                m.x += m.vx; m.y += m.vy; m.life--;
                enemies.forEach(e => { if (Math.hypot(e.x - m.x, e.y - m.y) < 30) { e.hp -= 10; m.life = 0; } });
                particles.push({ x: m.x, y: m.y, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), color: '#fd0', life: 0.3 });
            });
            missiles = missiles.filter(m => m.life > 0);
        }

        function updateParticlesAndRings() {
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.vy += 0.005; p.life -= 0.02; });
            particles = particles.filter(p => p.life > 0);
            rings.forEach(r => { r.r += 2; r.life -= 0.02; });
            rings = rings.filter(r => r.life > 0);
        }

        function updatePlayerStatus() { if (player.invuln > 0) player.invuln--; }

        function updateScorePopups() { scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; }); scorePopups = scorePopups.filter(s => s.life > 0); }

        function destroyEnemy(e) {
            enemiesKilled++;
            createExplosion(e.x, e.y, e.color, 40);

            // 効果音と特殊演出
            if (e.type === 'dragon') {
                rings.push({ x: e.x, y: e.y, r: 10, color: '#f00', life: 1 });
                AudioSys.playSE('dragon_explode');
            } else {
                AudioSys.playSE('explode');
            }

            const pts = (e.type === 'dragon' || e.type === 'boss') ? 1000 : 100;
            score += pts;
            ui.score.innerText = score.toString().padStart(6, '0');
            scorePopups.push({ x: e.x, y: e.y, text: pts, life: 40, alpha: 1, vy: -1 });
            distortGrid(e.x, e.y, 40, 80);

            if (e.noDrop || e.drop === 'none') return;

            // --- ★ここからドロップ調整ロジック ---
            let finalDrop = e.drop;

            // シールドが30%以下なら、通常のクリスタル（衛星）ドロップを低確率で「無敵」に上書き
            if (player.shield <= 30 && finalDrop === 'crystal') {
                if (Math.random() < 0.05) { // 15%の確率で救済措置発動
                    finalDrop = 'invincible';
                }
            }

            // ドロップ実行
            if (finalDrop === 'laser') powerups.push({ x: e.x, y: e.y, type: 'laser', life: ITEM_LIFE });
            else if (finalDrop === 'invincible') powerups.push({ x: e.x, y: e.y, type: 'invincible', life: ITEM_LIFE });
            else if (finalDrop === 'level' || Math.random() < 0.05) powerups.push({ x: e.x, y: e.y, type: 'level', life: ITEM_LIFE });
            else crystals.push({ x: e.x, y: e.y, life: ITEM_LIFE });
        }

        function damage(v) {
            player.shield -= v;
            player.invuln = 5;
            ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
            AudioSys.playSE('damage');
            distortGrid(player.x, player.y, 50, 100);

            if (player.shield <= 0) {
                gameState = 'DYING';

                dyingTimer = 120;
                bullets = []; lasers = []; missiles = [];
                createExplosion(player.x, player.y, '#0f8', 100);
                AudioSys.playSE('dragon_explode');
                distortGrid(player.x, player.y, 100, 200);
            }
        }

        function checkStageClear() {
            if (!isStageClear && enemiesKilled >= enemiesToSpawn && enemies.length === 0) {
                isStageClear = true;

                // --- ★8ステージクリア判定 ---
                if (stage === MAX_STAGE) {
                    showEnding();
                } else {
                    // 通常のステージクリア
                    ui.msg.style.display = 'block';
                    AudioSys.playBGM('clear');
                    setTimeout(() => {
                        stage++;
                        ui.stage.innerText = stage;
                        startStage();
                    }, 4000);
                }
            }
        }

        // ミッションクリア（勝利）時
        function showEnding() {
            gameState = 'ENDING';
            AudioSys.stopBGM();
            AudioSys.playBGM('clear');

            bullets = []; enemyBullets = []; enemies = [];
            createExplosion(player.x, player.y, '#fff', 200);

            ui.controls.style.display = 'none';

            // エンディング画面を表示
            ui.endingHud.style.display = 'flex';
            if (ui.finalScore) ui.finalScore.innerText = "TOTAL SCORE: " + score.toLocaleString();

            // NEXTボタンのクリックイベント
            if (ui.btnNextResult) {
                ui.btnNextResult.onclick = () => {
                    // エンディング画面を消して
                    ui.endingHud.style.display = 'none';
                    // 通常のゲームオーバー（名前入力→リザルト）フローへ合流
                    showGameOver();
                };
            }
        }

        // --- Draw ---
        function draw() {
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const sx = (s.x - camera.x * s.parallax) % worldSize; const sy = (s.y - camera.y * s.parallax) % worldSize;
                const dx = (sx + worldSize) % worldSize; const dy = (sy + worldSize) % worldSize;
                ctx.globalAlpha = s.brightness; ctx.beginPath(); ctx.arc(dx, dy, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            ctx.save(); ctx.beginPath(); ctx.rect(0, 0, worldSize, worldSize); ctx.clip();

            ctx.strokeStyle = 'rgba(0, 150, 255, 0.3)'; // 水色(0,150,255)で透明度0.15。かなり薄くなります。
            ctx.lineWidth = 1; // 線自体も少し細くすると繊細になります
            ctx.shadowBlur = 5;  // 光彩を抑える（以前は15）
            ctx.shadowColor = '#08f';

            ctx.beginPath();
            const viewX = camera.x; const viewY = camera.y; const viewW = width; const viewH = height;
            for (let i = 0; i < gridPoints.length; i++) for (let j = 0; j < gridPoints[i].length; j++) {
                const p = gridPoints[i][j]; if (!p) continue;
                if (p.x < viewX - 50 || p.x > viewX + viewW + 50 || p.y < viewY - 50 || p.y > viewY + viewH + 50) continue;
                if (i > 0 && gridPoints[i - 1] && gridPoints[i - 1][j]) { ctx.moveTo(gridPoints[i - 1][j].x, gridPoints[i - 1][j].y); ctx.lineTo(p.x, p.y); }
                if (j > 0 && gridPoints[i][j - 1]) { ctx.moveTo(gridPoints[i][j - 1].x, gridPoints[i][j - 1].y); ctx.lineTo(p.x, p.y); }
            }
            ctx.stroke(); ctx.shadowBlur = 0; ctx.restore();

            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, worldSize - WALL_MARGIN * 2, worldSize - WALL_MARGIN * 2);

            wormholes.forEach(w => {
                if (w.active || w.life > -60) {
                    let scale = 1; if (w.life > 300) scale = (400 - w.life) / 100; else if (w.life <= 0) scale = Math.max(0, (60 + w.life) / 60);
                    ctx.save(); ctx.translate(w.x, w.y); ctx.scale(scale, scale);
                    ctx.shadowBlur = 30; ctx.shadowColor = '#20f';
                    const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.2, '#000'); grad.addColorStop(0.8, '#000'); grad.addColorStop(1, '#0ff');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 20 + Math.sin(frame * 0.1) * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, 35 + Math.cos(frame * 0.05) * 5, 0, Math.PI * 2); ctx.stroke();
                    ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(5, 5); ctx.stroke();
                    ctx.restore();
                }
            });

            enemies.forEach(e => {
                if (e.type === 'dragon') drawDragonEnemy(ctx, e);
                else if (e.type === 'triangle') drawTriangleEnemy(ctx, e);
                else if (e.type === 'cube') drawCubeEnemy(ctx, e);
                else if (e.type === 'tadpole') drawTadpoleEnemy(ctx, e);
                else if (e.type === 'boss') drawBossEnemy(ctx, e);
            });

            // 敵の弾の描画ループ
            enemyBullets.forEach(eb => {
                ctx.save();
                ctx.translate(eb.x, eb.y);

                // ミサイルか通常の弾かで描画関数を切り替える
                if (eb.isMissile) {
                    drawHomingMissile(ctx, eb);
                } else {
                    drawNormalBullet(ctx, eb);
                }

                ctx.restore();
            });

            ctx.shadowBlur = 0;

            if (gameState === 'PLAYING') {
                // --- ★レベル最大時のオーラエフェクト ---
                if (player.weaponLevel >= MAX_WEAPON_LEVEL) {
                    ctx.save();
                    ctx.translate(player.x, player.y);

                    // 回転する三角形のオーラ（2枚重ねて逆回転させる）
                    const auraSize = 35 * G_SCALE;
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0f8';

                    for (let i = 0; i < 2; i++) {
                        ctx.save();
                        ctx.rotate(frame * (i === 0 ? 0.05 : -0.03)); // 2枚を別々の速さで回す
                        ctx.strokeStyle = i === 0 ? 'rgba(0, 255, 136, 0.5)' : 'rgba(0, 255, 255, 0.3)';
                        ctx.beginPath();
                        // 六角形のオーラを描画
                        for (let j = 0; j < 6; j++) {
                            const ang = (Math.PI * 2 / 6) * j;
                            const rx = Math.cos(ang) * (auraSize + Math.sin(frame * 0.1) * 3);
                            const ry = Math.sin(ang) * (auraSize + Math.sin(frame * 0.1) * 3);
                            if (j === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.restore();

                    // 自機の後ろに時々火花を散らす
                    if (frame % 3 === 0) {
                        const ra = Math.random() * Math.PI * 2;
                        particles.push({
                            x: player.x + Math.cos(ra) * 15,
                            y: player.y + Math.sin(ra) * 15,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#0f8', life: 0.4, size: 1.5
                        });
                    }
                }

                // --- ★追加：無敵状態のバリアエフェクト ---
                if (player.invuln > 0) {
                    ctx.save();
                    ctx.translate(player.x, player.y);

                    const bRadius = 40 * G_SCALE;
                    const pulse = Math.sin(frame * 0.2) * 5;

                    // バリアの外光（黄色いグロー）
                    ctx.strokeStyle = '#ff0';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0';
                    ctx.lineWidth = 2;

                    // 1. メインの円形バリア
                    ctx.beginPath();
                    ctx.arc(0, 0, bRadius + pulse, 0, Math.PI * 2);
                    ctx.stroke();

                    // 2. 高速回転する「ガードリング」
                    ctx.rotate(frame * 0.1);
                    ctx.setLineDash([15, 15]); // 点線にして回転させる
                    ctx.beginPath();
                    ctx.arc(0, 0, bRadius + pulse + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]); // 元に戻す

                    // 3. バリア表面を走る火花（ランダムな稲妻のような線）
                    if (frame % 2 === 0) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        const ang1 = Math.random() * Math.PI * 2;
                        const ang2 = ang1 + 0.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, bRadius + pulse, ang1, ang2);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // バリアから漏れ出るエネルギー粒子
                    if (frame % 2 === 0) {
                        particles.push({
                            x: player.x + (Math.random() - 0.5) * 60,
                            y: player.y + (Math.random() - 0.5) * 60,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#ff0', life: 0.3, size: 1
                        });
                    }
                }


                // 以下、既存の自機本体の描画
                ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.scale(G_SCALE, G_SCALE);
                let shipColor = '#0f8'; if (player.invuln > 0) shipColor = '#ff0'; else if (player.laserTimer > 0) shipColor = '#0ff';
                ctx.strokeStyle = shipColor; ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
                ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath(); ctx.moveTo(-5, 0); ctx.lineTo(-15, 15); ctx.moveTo(-5, 0); ctx.lineTo(-15, -15); ctx.stroke();
                ctx.restore(); ctx.shadowBlur = 0;
                player.satellites.forEach(s => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill(); });
            }

            drawLasers();
            ctx.fillStyle = '#0f8'; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI * 2); ctx.fill(); });

            ctx.fillStyle = '#0f0';
            crystals.forEach(c => {
                ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(frame * 0.1);
                const scale = c.life > 60 ? 1 : c.life / 60; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill(); ctx.restore();
            });

            powerups.forEach(p => {
                if (p.type === 'laser') ctx.strokeStyle = '#0ff'; else if (p.type === 'level') ctx.strokeStyle = '#0f0'; else ctx.strokeStyle = '#fd0';
                ctx.save(); ctx.translate(p.x, p.y);
                const scale = p.life > 60 ? 1 : p.life / 60; ctx.scale(scale, scale);
                ctx.lineWidth = 2; ctx.strokeRect(-8, -8, 16, 16);
                ctx.fillStyle = ctx.strokeStyle; ctx.font = 'bold 12px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                let char = 'S'; if (p.type === 'level') char = 'L'; else if (p.type === 'laser') char = 'B';
                ctx.fillText(char, 0, 0); ctx.restore();
            });

            ctx.fillStyle = '#fd0'; missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });

            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = Math.min(1, p.life);
                ctx.beginPath(); const length = 4.0; ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * length, p.y - p.vy * length);
                ctx.lineWidth = p.size || 2; ctx.strokeStyle = p.color; ctx.lineCap = 'round'; ctx.stroke();
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;

            rings.forEach(r => { ctx.strokeStyle = r.color; ctx.lineWidth = 3; ctx.globalAlpha = r.life; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1.0; });
            drawScorePopups(); ctx.restore();
        }

        function drawLasers() {
            lasers.forEach(l => {
                ctx.save(); ctx.translate(l.x, l.y); ctx.rotate(l.angle);
                ctx.globalCompositeOperation = 'lighter'; ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1.5;
                const len = 2000; const segments = 20; const segLen = len / segments; const jitter = 15 * (l.life / 5);
                ctx.beginPath(); ctx.moveTo(0, 0); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = (Math.random() - 0.5) * jitter * 2; ctx.lineTo(px, py); } ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -l.width / 4); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = -l.width / 4 + (Math.random() - 0.5) * (jitter / 2); ctx.lineTo(px, py); } ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, l.width / 4); for (let i = 1; i <= segments; i++) { const px = i * segLen; const py = l.width / 4 + (Math.random() - 0.5) * (jitter / 2); ctx.lineTo(px, py); } ctx.stroke();
                if (Math.random() > 0.2) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, (Math.random() - 0.5) * 5); ctx.stroke(); }
                ctx.restore();
            });
            ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur = 0;
        }

        function drawTriangleEnemy(ctx, e) {
            ctx.save(); ctx.translate(e.x, e.y); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
            ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = e.color; ctx.lineWidth = 2.5; ctx.shadowBlur = 25; ctx.shadowColor = e.color;
            const size = 15; const pts = [{ x: 1, y: 1, z: 1 }, { x: -1, y: -1, z: 1 }, { x: -1, y: 1, z: -1 }, { x: 1, y: -1, z: -1 }];
            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX); const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY); const cosZ = Math.cos(e.rotZ), sinZ = Math.sin(e.rotZ);
            const proj = pts.map(p => { let y1 = p.y * cosX - p.z * sinX; let z1 = p.y * sinX + p.z * cosX; let x2 = p.x * cosY + z1 * sinY; let z2 = -p.x * sinY + z1 * cosY; let x3 = x2 * cosZ - y1 * sinZ; let y3 = x2 * sinZ + y1 * cosZ; return { x: x3 * size, y: y3 * size }; });
            const lines = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]];
            ctx.beginPath(); lines.forEach(l => { ctx.moveTo(proj[l[0]].x, proj[l[0]].y); ctx.lineTo(proj[l[1]].x, proj[l[1]].y); }); ctx.stroke();
            ctx.shadowBlur = 35; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function drawCubeEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // --- 1. アイテムの種類に応じたコアの色設定 ---
            let coreColor = '#ff0'; // デフォルト（クリスタル/なし）：黄
            if (e.drop === 'laser') coreColor = '#0ff';      // レーザー：シアン
            if (e.drop === 'level') coreColor = '#0f0';      // レベルアップ：緑
            if (e.drop === 'invincible') coreColor = '#fff'; // 無敵：白

            // 点滅演出
            const pulse = (Math.sin(frame * 0.15) * 0.5) + 0.5;
            const coreSize = 6 + pulse * 4;

            ctx.shadowBlur = 15 + pulse * 10;
            ctx.shadowColor = coreColor;

            // コアの外光（パルスに合わせて透明度変化）
            const rgb = coreColor === '#ff0' ? '255, 255, 0' :
                coreColor === '#0ff' ? '0, 255, 255' :
                    coreColor === '#0f0' ? '0, 255, 0' : '255, 255, 255';

            ctx.fillStyle = `rgba(${rgb}, ${0.4 + pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();

            // コアの中心（高輝度）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. 外殻のワイヤーフレーム (緑色で固定) ---
            ctx.shadowBlur = 5;
            ctx.shadowColor = e.color;
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 1.5;

            const size = 16;
            const pts = [
                { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 },
                { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
                { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
            ];

            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX);
            const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY);

            const proj = pts.map(p => {
                let y = p.y * cosX - p.z * sinX;
                let z = p.y * sinX + p.z * cosX;
                let x = p.x * cosY + z * sinY;
                return { x: x * size, y: y * size };
            });

            const lines = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            ctx.beginPath();
            lines.forEach(l => {
                ctx.moveTo(proj[l[0]].x, proj[l[0]].y);
                ctx.lineTo(proj[l[1]].x, proj[l[1]].y);
            });
            ctx.stroke();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawBossEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // --- 1. カラー・設定の構築 ---
            const isDmg = e.flashTimer > 0;
            if (isDmg) e.flashTimer--;

            // 基本の色
            const baseColor = e.color;
            // 「色味のある白（城）」: HSLを使って明度(L)だけを90%まで引き上げた色を作る
            // ※既存の色（#f0fなど）から自動で高輝度版を生成するロジック
            const brightColor = `hsl(${getHue(baseColor)}, 100%, 70%)`;

            // 描画に使用するメイン/サブカラー（ダメージ時は全体が明るくなる）
            const mainStroke = isDmg ? brightColor : baseColor;
            const subStroke = isDmg ? '#fff' : brightColor;

            const sides = e.variant.sides;
            const radius = 45;

            // --- 2. 内部精密構造（淡い高輝度カラー） ---
            ctx.strokeStyle = subStroke;
            ctx.lineWidth = 0.4;
            ctx.globalAlpha = isDmg ? 1.0 : 0.6;
            ctx.shadowBlur = isDmg ? 20 : 0;
            ctx.shadowColor = subStroke;

            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                const nextA = (Math.PI * 2 / sides) * (i + 1);
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a) * radius, Math.sin(a) * radius); ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * radius * 0.6, Math.sin(a) * radius * 0.6);
                ctx.lineTo(Math.cos(nextA) * radius * 0.6, Math.sin(nextA) * radius * 0.6);
                ctx.stroke();
            }

            // --- 3. 装甲フレーム（メインカラー） ---
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = isDmg ? 30 : 12;
            ctx.shadowColor = mainStroke;

            [radius, radius - 4, radius - 15].forEach((r, idx) => {
                ctx.strokeStyle = (idx === 1) ? subStroke : mainStroke;
                ctx.lineWidth = (idx === 0) ? 1.8 : 0.8;
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const a = (Math.PI * 2 / sides) * i;
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.stroke();
            });

            // --- 4. コアユニット（同系色グラデーション風） ---
            ctx.save();
            ctx.rotate(-e.angle * 4);
            ctx.strokeStyle = subStroke;
            ctx.strokeRect(-8, -8, 16, 16);
            ctx.fillStyle = mainStroke;
            ctx.globalAlpha = isDmg ? 1.0 : 0.5;
            ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // --- 5. 砲塔ユニット ---
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                ctx.save();
                ctx.translate(Math.cos(a) * radius, Math.sin(a) * radius);
                ctx.rotate(a);
                ctx.strokeStyle = subStroke; ctx.lineWidth = 0.6; ctx.strokeRect(-8, -10, 10, 20);
                ctx.strokeStyle = mainStroke; ctx.lineWidth = 1.2;
                [-4, 4].forEach(y => { ctx.beginPath(); ctx.moveTo(2, y); ctx.lineTo(24, y); ctx.stroke(); });
                ctx.restore();
            }

            // --- 6. 強化ダメージエフェクト（火花とリング） ---
            if (isDmg) {
                // 【火花】
                for (let i = 0; i < 4; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const spd = 4 + Math.random() * 10;
                    particles.push({
                        x: e.x + (Math.random() - 0.5) * 40,
                        y: e.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
                        color: Math.random() > 0.4 ? brightColor : baseColor,
                        life: 0.5, size: 2 + Math.random() * 2
                    });
                }

                // 【リング爆風】
                // flashTimerが最大値の瞬間（＝当たった直後の1フレームだけ）にリングを出す
                if (e.flashTimer === 4) { // flashTimerの初期値に合わせて調整
                    rings.push({
                        x: e.x,
                        y: e.y,
                        r: 10,           // 開始サイズ
                        color: brightColor, // 「色味のある城」で光の輪を作る
                        life: 0.5        // 消えるまでの時間
                    });
                }
            }
            ctx.restore();
        }

        // 補助関数：色から色相(Hue)を取り出す（コードの最後の方に追加してください）
        function getHue(color) {
            if (color.startsWith('#')) {
                // 簡易的な16進数→Hue変換（ボスの主要色に対応）
                if (color === '#f0f') return 300; // マゼンタ
                if (color === '#ffff00') return 60; // 黄
                if (color === '#0f8') return 150; // エメラルド
                if (color === '#0cc') return 180; // シアン
                if (color === '#44f') return 240; // 青
                if (color === '#f40') return 20;  // オレンジ赤
                if (color === '#f08') return 330; // ローズ
                if (color === '#fff') return 0;   // 白
            }
            return 0;
        }

        function drawTadpoleEnemy(ctx, e) {
            ctx.save();

            // --- カラー設定：明るい水色（シアンネオン） ---
            const neonCyan = "#0ff";      // 鮮やかなシアン
            const lightCyan = "#ccffff";  // ハイライト用の白に近い青

            // --- 1. テイル（高速流動フラグメント）の描画 ---
            if (e.history.length > 1) {
                ctx.setLineDash([12, 18]);
                for (let i = 0; i < e.history.length - 1; i += 3) {
                    const p1 = e.history[i];
                    const p2 = e.history[i + 1];
                    if (!p2) break;

                    const ratio = i / e.history.length;
                    const alpha = (1 - ratio) * 0.6;

                    // 尾も水色のグラデーションに
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = (14 - ratio * 14) * G_SCALE;

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }

            // --- 2. 幾何学メカニカル・ヘッド（頭部）の描画 ---
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // 背景の遮蔽（より深い紺色で水色を引き立てる）
            ctx.fillStyle = 'rgba(0, 10, 20, 0.9)';
            ctx.beginPath();
            ctx.rect(-10, -15, 45, 30);
            ctx.fill();

            // ワイヤーフレームの設定
            ctx.strokeStyle = neonCyan;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = neonCyan;

            // --- メインボディ「＝＝＝」部分 ---
            for (let j = 0; j < 3; j++) {
                const xPos = j * 12;
                // シリンダーリング
                ctx.beginPath();
                ctx.ellipse(xPos, 0, 8, 15, 0, 0, Math.PI * 2);
                ctx.stroke();

                // 水平支柱（ハイライト色を混ぜる）
                ctx.save();
                ctx.strokeStyle = lightCyan;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(xPos, -15); ctx.lineTo(xPos + 12, -15);
                ctx.moveTo(xPos, 15); ctx.lineTo(xPos + 12, 15);
                ctx.stroke();
                ctx.restore();
            }

            // --- 先端ユニット「＜＜」部分 ---
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.moveTo(35, -14); ctx.lineTo(52, 0); ctx.lineTo(35, 14); // 外側の ＜
            ctx.stroke();

            ctx.save();
            ctx.strokeStyle = lightCyan;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(25, -9); ctx.lineTo(42, 0); ctx.lineTo(25, 9);   // 内側の ＜
            ctx.stroke();
            ctx.restore();

            // --- コア・ユニット ---
            // 中心部で強く輝く水色のエネルギー体
            ctx.fillStyle = lightCyan;
            ctx.shadowBlur = 20;
            ctx.shadowColor = neonCyan;
            ctx.beginPath();
            ctx.rect(5, -4, 8, 8);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawDragonEnemy(ctx, e) {
            ctx.save(); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE); ctx.strokeStyle = e.color; ctx.lineWidth = 2;
            e.segments.forEach((s, i) => {
                ctx.save(); ctx.translate(s.x / (e.scale * G_SCALE), s.y / (e.scale * G_SCALE)); ctx.rotate(s.angle);
                ctx.beginPath(); ctx.arc(0, 0, (12 - i * 0.5) * 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); const wingSize = (15 - i * 0.5); ctx.moveTo(0, 0); ctx.lineTo(-5, wingSize); ctx.moveTo(0, 0); ctx.lineTo(-5, -wingSize); ctx.stroke();
                ctx.restore();
            });
            ctx.save(); ctx.translate(e.x / (e.scale * G_SCALE), e.y / (e.scale * G_SCALE)); ctx.rotate(e.angle);
            ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(5, 12); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.lineTo(5, -12); ctx.closePath(); ctx.stroke();
            ctx.restore(); ctx.restore();
        }

        // 通常の敵弾を描画する関数
        function drawNormalBullet(ctx, eb) {
            ctx.rotate(frame * 0.15);
            const bulletColor = (Math.floor(frame / 5) % 2 === 0) ? '#ff0000' : '#ff8800';
            ctx.fillStyle = bulletColor;
            ctx.shadowBlur = 8;
            ctx.shadowColor = bulletColor;

            const size = 6 * G_SCALE;
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.7, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size * 0.7, 0);
            ctx.closePath();
            ctx.fill();
        }

        // ホーミングミサイルを描画する関数
        function drawHomingMissile(ctx, eb) {
            // ミサイルを進行方向（速度ベクトル）に向ける
            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);

            const mSize = 12 * G_SCALE; // ミサイルは少し大きめに
            const color = eb.color || '#f00';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 12;
            ctx.shadowColor = color;

            // ミサイルの形状（鋭い矢印型）
            ctx.beginPath();
            ctx.moveTo(mSize, 0);            // 先端
            ctx.lineTo(-mSize, mSize * 0.6);   // 右後ろ
            ctx.lineTo(-mSize * 0.4, 0);     // 中央のくぼみ
            ctx.lineTo(-mSize, -mSize * 0.6);  // 左後ろ
            ctx.closePath();
            ctx.stroke();

            // 推進エンジンの中心点
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-mSize * 0.5, 0, 2 * G_SCALE, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawScorePopups() {
            ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
            scorePopups.forEach(s => { ctx.globalAlpha = s.alpha; ctx.fillText(s.text, s.x, s.y); });
            ctx.globalAlpha = 1.0;
        }

        function updateGrid() {
            // スクロール時の乱れを防ぐため、計算バッファ（10）を追加
            const buffer = 10;
            const startX = Math.max(0, Math.floor(camera.x / GRID_SPACING) - buffer);
            const endX = Math.min(gridPoints.length - 1, Math.ceil((camera.x + width) / GRID_SPACING) + buffer);
            const startY = Math.max(0, Math.floor(camera.y / GRID_SPACING) - buffer);
            const endY = Math.min(gridPoints[0].length - 1, Math.ceil((camera.y + height) / GRID_SPACING) + buffer);

            for (let i = startX; i <= endX; i++) {
                for (let j = startY; j <= endY; j++) {
                    const p = gridPoints[i][j];
                    const dx = p.x - p.ox, dy = p.y - p.oy;

                    // バネの復元力
                    const dist = Math.hypot(dx, dy);
                    if (dist > 0.1) {
                        const f = -0.12 * dist;
                        const ang = Math.atan2(dy, dx);
                        p.vx += Math.cos(ang) * f;
                        p.vy += Math.sin(ang) * f;
                    }

                    p.vx *= 0.85;
                    p.vy *= 0.85;

                    // 停止判定
                    if (Math.abs(p.vx) < 0.01 && Math.abs(p.vy) < 0.01 && dist < 0.1) {
                        p.x = p.ox; p.y = p.oy;
                        p.vx = 0; p.vy = 0;
                    } else {
                        p.x += p.vx;
                        p.y += p.vy;
                    }
                }
            }
        }

        function distortGrid(x, y, force, radius) {
            const cx = Math.floor(x / GRID_SPACING), cy = Math.floor(y / GRID_SPACING), r = Math.ceil(radius / GRID_SPACING);
            for (let i = Math.max(0, cx - r); i < Math.min(gridPoints.length, cx + r); i++) for (let j = Math.max(0, cy - r); j < Math.min(gridPoints[0].length, cy + r); j++) {
                const p = gridPoints[i][j], d = Math.hypot(p.x - x, p.y - y);
                if (d < radius) { const f = force * (1 - d / radius), a = Math.atan2(p.y - y, p.x - x); p.vx += Math.cos(a) * f; p.vy += Math.sin(a) * f; }
            }
        }

        function createExplosion(x, y, baseColor, n) {
            const count = Math.floor(n * EXPLOSION_COUNT_MAG);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 8 + 2) * EXPLOSION_SPEED_MAG;
                let color; const rnd = Math.random();
                if (rnd < 0.7) color = baseColor; else if (rnd < 0.8) color = '#fff'; else if (rnd < 0.90) color = rnd < 0.77 ? '#ff8800' : '#ffff00';
                else { const colors = ['#0ff', '#f0f', '#0f0', '#ff0']; color = colors[Math.floor(Math.random() * colors.length)]; }
                particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color: color, size: (Math.random() * 2 + 1) * G_SCALE, life: 1.0 + Math.random() * 0.5 });
            }
            distortGrid(x, y, 60, 120);
        }

        // --- PAUSE Control ---
        function setPaused(paused) {
            if (paused) {
                if (gameState === 'PLAYING') {
                    previousGameState = gameState;
                    gameState = 'PAUSED';
                    ui.pauseOverlay.style.display = 'flex';
                }
                AudioSys.pauseBGM();
            } else {
                if (gameState === 'PAUSED') {
                    // Do nothing, wait for user interaction
                } else {
                    AudioSys.resumeBGM();
                }
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) setPaused(true); else setPaused(false);
        });

        window.addEventListener('blur', () => setPaused(true));
        window.addEventListener('focus', () => setPaused(false));

        const resumeAction = (e) => {
            if (e) e.preventDefault();
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                ui.pauseOverlay.style.display = 'none';
                AudioSys.resumeBGM();
            }
        };

        ui.pauseOverlay.addEventListener('click', resumeAction);
        ui.pauseOverlay.addEventListener('touchstart', resumeAction, { passive: false });

        function handleTouch(e) {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.move.active = false; input.aim.active = false;

            const lR = ui.stickL.getBoundingClientRect(); const rR = ui.stickR.getBoundingClientRect();
            const lC = { x: lR.left + lR.width / 2, y: lR.top + lR.height / 2 };
            const rC = { x: rR.left + rR.width / 2, y: rR.top + rR.height / 2 };

            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                const dL = Math.hypot(t.clientX - lC.x, t.clientY - lC.y);
                const dR = Math.hypot(t.clientX - rC.x, t.clientY - rC.y);

                if (dL < 100) {
                    input.move.active = true; const a = Math.atan2(t.clientY - lC.y, t.clientX - lC.x); const d = Math.min(dL, 40);
                    input.move.x = Math.cos(a) * (d / 40); input.move.y = Math.sin(a) * (d / 40);
                    ui.knobL.style.transform = `translate(${input.move.x * 40}px,${input.move.y * 40}px)`;
                } else if (dR < 100) {
                    input.aim.active = true; const a = Math.atan2(t.clientY - rC.y, t.clientX - rC.x); const d = Math.min(dR, 40);
                    input.aim.x = Math.cos(a) * (d / 40); input.aim.y = Math.sin(a) * (d / 40);
                    ui.knobR.style.transform = `translate(${input.aim.x * 40}px,${input.aim.y * 40}px)`;
                }
            }
            if (!input.move.active) { input.move.x = 0; input.move.y = 0; ui.knobL.style.transform = 'translate(0,0)'; }
            if (!input.aim.active) { input.aim.x = 0; input.aim.y = 0; ui.knobR.style.transform = 'translate(0,0)'; }
        }

        ui.launchBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            launchSatellites();
            ui.launchBtn.classList.add('active');
            setTimeout(() => ui.launchBtn.classList.remove('active'), 100);
        });
        ui.controls.addEventListener('touchstart', handleTouch, { passive: false });
        ui.controls.addEventListener('touchmove', handleTouch, { passive: false });
        ui.controls.addEventListener('touchend', handleTouch, { passive: false });

        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-ost').onclick = openOST;
        document.getElementById('btn-back').onclick = closeOST;


        window.addEventListener('keydown', e => {
            if (document.activeElement === document.getElementById('player-name-input')) return;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyZ', 'KeyX'].includes(e.code)) e.preventDefault();
            input.keys[e.code] = true;
            if (gameState === 'TITLE' && e.code === 'Space') startGame();
            if (gameState === 'PLAYING' && e.code === 'KeyX') launchSatellites();
        });
        window.addEventListener('keyup', e => input.keys[e.code] = false);
        window.addEventListener('resize', resize);

        let isInit = false;
        const handleInteraction = () => {
            if (isInit) return;
            isInit = true;
            AudioSys.resume();
            if (gameState === 'TITLE' && !AudioSys.currentSrc) AudioSys.playBGM('title');
            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('touchstart', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };
        document.addEventListener('click', handleInteraction);
        document.addEventListener('touchstart', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        function init() { resize(); AudioSys.init(); }
        init(); loop();
    </script>
</body>

</html>
