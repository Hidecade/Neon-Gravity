
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>NEON GRAVITY</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        /* =========================================================
            1. グローバル基本設定
            ========================================================= */
        body {
            margin: 0; /* 余白を完全に除去 */
            background: #050505; /* ネオン表現に最適な暗い背景 */
            overflow: hidden; /* スクロールバーを非表示 */
            font-family: 'Orbitron', monospace; /* 近未来風フォント */
            color: #fff; /* 文字色の基本は白 */

            user-select: none; /* テキスト選択を禁止 */
            -webkit-user-select: none; /* iOS Safari向け */
            touch-action: none; /* スマホの標準ジェスチャ無効化 */
            -webkit-tap-highlight-color: transparent; /* タップ時の青枠を消す */
        }

        /* =========================================================
                2. キャンバスとメインUIコンテナ
                ========================================================= */
        canvas {
            display: block; /* 余計な隙間を防ぐ */
            position: absolute; /* 画面全体に固定 */
            top: 0;
            left: 0;
            z-index: 1; /* UIより背面に配置 */
        }

        #ui {
            position: absolute; /* ゲーム画面に重ねる */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 操作を下の要素へ通す */
            z-index: 20; /* キャンバスより前面 */

            display: flex;
            flex-direction: column; /* 縦方向に要素配置 */
            padding: 10px; /* 画面端からの余白 */
            box-sizing: border-box; /* パディング込みサイズ */
        }


        /* =========================================================
                3. HUDレイアウト（スコア・ステージ・武器）
                ========================================================= */
        .hud-row {
            display: flex; /* 左右に要素を配置 */
            justify-content: space-between; /* 両端に寄せる */
            width: 100%;
            max-width: 800px; /* 大画面での最大幅 */
            margin: 0 auto; /* 中央寄せ */
        }

        #score-display {
            font-size: 24px; /* 大きめに表示 */
            color: #0ff; /* ネオン水色 */
            text-shadow: 0 0 10px #0ff; /* 発光エフェクト */
            letter-spacing: 0px; /* 数字の間隔 */
            margin-bottom: 5px;
        }

        .sub-text {
            font-size: 12px; /* 補助ラベル用の小文字 */
            color: #aaa; /* 控えめな灰色 */
            font-weight: bold;
        }

        .hud-label {
            font-size: 10px; /* ゲージ等の見出し */
            color: #aaa;
            display: block;
            margin-bottom: -2px;
        }

        #stage-num {
            font-size: 28px; /* ステージ番号を強調 */
            color: #fff;
            font-weight: bold;
            line-height: 1.0;
            text-shadow: 0 0 10px rgba(255,255,255,0.5); /* 白の発光 */
        }

        /* =========================================================
        4. ゲージ・バーコンポーネント (整理済み)
        ========================================================= */

        /* 左右のゲージコンテナ共通設定 */
        #gauge-box, #info-box > div {
            pointer-events: auto;
        }

        #gauge-box {
            width: 120px; /* スリムな幅に統一 */
            text-align: right;
        }

        /* 共通ラベル設定 */
        .bar-label {
            font-size: 10px;
            letter-spacing: 1px;
            margin-bottom: 2px;
            display: block;
            color: #0ff; /* 基本は水色 */
        }

            /* 敵・ボス用のラベル色 */
            .bar-label.enemy, #boss-name-label {
                color: #f44;
            }

        /* 共通ゲージ枠：すべての枠（左WEAPON/右SHIELD等）に適用 */
        .bar-frame, .laser-bar-frame {
            width: 100%;
            height: 8px;
            border: 1.5px solid rgba(0, 255, 255, 0.5); /* 1.5pxに統一 */
            background: rgba(0, 20, 40, 0.8);
            margin-bottom: 6px;
            overflow: hidden;
            box-sizing: border-box; /* 枠線の太さを内側に含める */
        }

        /* 左側WEAPON用の特殊幅調整（もし必要なら） */
        .laser-bar-frame {
            width: 80px;
        }

        /* 敵・ボス用の枠色上書き */
        .bar-frame.enemy, .bar-frame.boss {
            border-color: rgba(255, 68, 68, 0.5);
        }

        /* ボス用の特殊枠色（さらに強調する場合） */
        .bar-frame.boss {
            border-color: #f00;
        }

        /* --- バー本体（中身）の共通・個別設定 --- */

        /* シールドバー */
        #shield-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: width 0.1s;
            box-shadow: 0 0 10px #0ff;
        }

        /* 危険時のシールド点滅 */
        .shield-critical {
            animation: blink 0.2s infinite;
            background: #f00 !important;
        }

        /* 敵カウントバー */
        #enemy-bar {
            width: 100%;
            height: 100%;
            background: #f44;
            transition: width 0.5s;
        }

        /* ボスHPバー */
        #boss-hp-bar-inline {
            width: 100%;
            height: 100%;
            background: #f00;
            box-shadow: 0 0 10px #f00;
            transition: width 0.2s, background-color 0.3s;
        }

        /* レーザー持続時間バー */
        .laser-bar-fill {
            height: 100%;
            background: #0ff;
            box-shadow: 0 0 8px #0ff;
        }

        /* 武器レベル表示用ブロック（ショットモード時） */
        .w-block {
            width: 12px;
            height: 8px;
            margin-right: 3px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            display: inline-block;
        }

            .w-block.active {
                background: #0f0;
                border-color: #0f0;
                box-shadow: 0 0 5px #0f0;
            }

        /* ボスUIコンテナ表示制御 */
        #boss-ui-container {
            display: none;
            margin-top: 10px;
        }

        /* =========================================================
                5. ゲーム中メッセージ
                ========================================================= */
        #warning-msg {
            display: none; /* 初期は非表示 */
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #f00;
            font-size: 24px;
            animation: blink 0.2s infinite; /* 点滅警告 */
        }

        #stage-msg {
            display: none;
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 32px;
            font-weight: 900;
            /* 静止した状態での強力な発光 */
            text-shadow: 0 0 15px #0ff, 0 0 30px #0ff, 0 0 60px #0ff;
            letter-spacing: 12px;
            z-index: 100;
            pointer-events: none;
            font-family: 'Orbitron', sans-serif;
            /* 揺れを削除し、透明度と輝度の変化のみ適用 */
            animation: clear-glow 2.5s ease-in-out infinite;
            white-space: pre-wrap;
            transition: opacity 0.2s;
        }

        @keyframes clear-glow {
            0%, 100% {
                opacity: 0.8;
                filter: brightness(1);
            }

            50% {
                opacity: 1;
                filter: brightness(1.8) scale(1.02);
            }
        }

        /* =========================================================
                6. オーバーレイ（タイトル・ポーズ）
                ========================================================= */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85); /* 半透明の暗幕 */

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto; /* 操作を受け付ける */

            transition: opacity 0.3s ease; /* 0.3秒でふわっと消える */
            opacity: 1;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none; /* ポーズ時のみ表示 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 105;
            pointer-events: auto;
            backdrop-filter: blur(5px); /* 背景ぼかし */
        }


        /* =========================================================
                7. 共通メニューボタン
                ========================================================= */
        .menu-btn {
            background: rgba(0,255,255,0.1); /* 半透明ネオン背景 */
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 30px;
            margin: 8px;
            font-size: 22px;
            font-family: 'Orbitron';
            cursor: pointer;
            min-width: 240px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

            .menu-btn:active {
                background: #0ff; /* 押下時に反転 */
                color: #000;
                transform: scale(0.95);
            }


        /* =========================================================
                8. OST（サウンドトラック画面）
                ========================================================= */
        #ost-ui {
            display: none; /* 初期は非表示 */

            position: fixed; /* 全画面固定 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 110;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
            pointer-events: auto;
            transition: opacity 0.3s ease; /* 0.3秒でふわっと消える */
            opacity: 1;
        }

        #ost-scroll-container {
            width: 90%;
            max-width: 500px;
            max-height: 60vh; /* 画面高さの60% */

            overflow-y: auto; /* スクロール可能 */
            margin: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        .track-item {
            padding: 15px 20px;
            width: 100%;
            border-bottom: 1px solid #333;
            color: #888;
            text-align: center;
            font-size: 16px;
            box-sizing: border-box;
            cursor: pointer;
        }

            .track-item.playing {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 10px #0ff;
                background: rgba(0,255,255,0.05);
            }

        /* =========================================================
                9. 操作コントローラー（ジョイスティック）
                見た目のデザインと配置設定
                ========================================================= */

        /* 全体コンテナ */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            touch-action: none;
            pointer-events: auto;
        }

        /* --- ジョイスティック：外枠（ベース） --- */
        .joystick-area {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: radial-gradient(circle, rgba(0, 255, 255, 0.05) 0%, rgba(0, 0, 0, 0.2) 70%);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1), inset 0 0 10px rgba(0, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

            /* 外枠内の十字目盛り（装飾） */
            .joystick-area::before, .joystick-area::after {
                content: '';
                position: absolute;
                background: rgba(0, 255, 255, 0.2);
            }

            .joystick-area::before {
                width: 100%;
                height: 1px;
                background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            }

            .joystick-area::after {
                width: 1px;
                height: 100%;
                background: linear-gradient(180deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            }

        /* --- ジョイスティック：つまみ（Knob） --- */
        .knob {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.15);
            border: 2px solid #0ff;
            position: absolute;
            transform: translate(0,0);
            transition: transform 0.05s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            z-index: 2;
        }

            /* つまみ中心のドット */
            .knob::after {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 12px;
                height: 12px;
                background: #fff;
                border-radius: 50%;
                transform: translate(-50%, -50%);
                box-shadow: 0 0 10px #fff;
            }

        /* --- 特殊攻撃（BOMB/LAUNCH）ボタン --- */
        #launch-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.1);
            border: 2px solid #ff0;
            color: #ff0;
            font-family: 'Orbitron';
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.2);
            pointer-events: auto;
            text-shadow: 0 0 5px #ff0;
        }

            /* ボタン周りの回転リング */
            #launch-btn::before {
                content: '';
                position: absolute;
                width: 90px;
                height: 90px;
                border: 1px dashed rgba(255, 255, 0, 0.4);
                border-radius: 50%;
                animation: rotate 4s linear infinite;
            }

            /* 押下時のフィードバック */
            #launch-btn.active {
                background: #ff0;
                color: #000;
                transform: scale(0.85);
                box-shadow: 0 0 30px #ff0;
                text-shadow: none;
            }

        /* =========================================================
                9.2. デバイス別レイアウト（レスポンシブ）
                ========================================================= */

        /* --- デフォルト設定（横向き：Landscape） --- */
        #stick-left {
            left: 20px;
            bottom: 30px;
        }

        #stick-right {
            right: 20px;
            bottom: 30px;
        }

        #launch-btn {
            right: 20px;
            bottom: 200px;
        }

        /* --- 縦向き設定（Portrait） --- */
        @media (orientation: portrait) {
            #stick-left {
                left: 20px;
                bottom: 50px;
            }

            #stick-right {
                right: 20px;
                bottom: 50px;
            }

            #launch-btn {
                right: 0px;
                bottom: 220px;
            }
        }

        /* 回転アニメーション */
        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
        /* =========================================================
                10. ランキング画面
                ========================================================= */
        #ranking-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
        }

        #ranking-scroll-container {
            width: 95%;
            max-width: 600px;
            max-height: 60vh;
            overflow-y: auto;
            margin: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        #ranking-table {
            width: 100%;
            border-collapse: collapse;
            color: #fff;
            font-family: 'Orbitron';
            font-size: 14px;
        }

            #ranking-table th {
                border-bottom: 1px solid #0ff;
                color: #0ff;
                padding: 10px;
            }

            #ranking-table td {
                border-bottom: 1px solid #333;
                padding: 8px 10px;
            }

        .rank-1 {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            font-weight: bold;
            font-size: 1.2em;
        }

        .rank-2 {
            color: #c0c0c0;
            text-shadow: 0 0 10px #c0c0c0;
            font-weight: bold;
        }

        .rank-3 {
            color: #cd7f32;
            text-shadow: 0 0 10px #cd7f32;
            font-weight: bold;
        }


        /* =========================================================
                11. 名前入力画面
                ========================================================= */
        #name-input-area {
            display: none;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 55%;
            width: 100%;
            background: #000 !important; /* 強制的に黒 */
            z-index: 200;
        }

        #player-name-input {
            background: rgba(0,0,0,0.8);
            border: 2px solid #0ff;
            color: #fff;
            font-family: 'Orbitron';
            font-size: 24px;
            padding: 10px;
            text-align: center;
            width: 250px;
            outline: none;
            margin-bottom: 10px;
            box-shadow: 0 0 10px #0ff;
        }

            #player-name-input::placeholder {
                color: #055;
            }


        /* =========================================================
                12. エンディング画面
                ========================================================= */
        #ending-msg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
        }

        #final-score-val {
            background: rgba(0,255,255,0.1);
            padding: 10px 30px;
            border-top: 1px solid rgba(0,255,255,0.3);
            border-bottom: 1px solid rgba(0,255,255,0.3);
            margin-bottom: 30px;
        }


        /* =========================================================
                13. アニメーション定義
                ========================================================= */
        @keyframes blink {
            50% {
                opacity: 0.5; /* 半透明にして点滅 */
            }
        }

        /* =========================================================
           14. ミニマップ (配置変更版)
           ========================================================= */
        #minimap-container {
            /* --- デフォルト（横画面）設定 --- */
            /* 絶対配置をやめ、info-boxの流れに従って下に配置 */
            position: relative;
            top: auto;
            left: auto;
            transform: none;
            margin-top: 15px; /* 上の要素との間隔 */

            width: 100px;
            height: 100px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            background: rgba(0, 10, 20, 0.6);
            backdrop-filter: blur(2px);
            z-index: 30;
            /* タッチ操作を邪魔しないように */
            pointer-events: none;
        }

        #minimap-canvas {
            width: 100px;
            height: 100px;
            display: block;
        }

        /* --- 縦画面（スマホ縦持ち）設定 --- */
        /* 縦画面の時はスペースが狭いので、元通り上部中央に浮かせる */
        @media (orientation: portrait) {
            #minimap-container {
                position: absolute; /* 親のui基準で配置 */
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                margin-top: 0;
            }
        }

    </style>

</head>

<body>

    <canvas id="game"></canvas>

    <div id="ui">


        <div class="hud-row">
            <div id="info-box" style="display:flex; flex-direction:column; gap:8px;">
                <div id="score-display">000000</div>
                <div><span class="hud-label">STAGE</span><span id="stage-num">1</span></div>
                <div>
                    <span class="hud-label">WEAPON</span>
                    <div id="weapon-display" style="height:12px; display:flex; align-items:center;"></div>
                </div>
                <div id="invuln-wrapper" style="display:none; margin-top: 2px;">
                    <span class="bar-label" style="color:#ff0; font-size:10px;">INVINCIBLE</span>
                    <div class="bar-frame"
                         style="border-color:#ff0; background:rgba(40,40,0,0.5); width:80px; height:6px;">
                        <div id="invuln-bar" style="width:0%; height:100%; background:#ff0; box-shadow:0 0 5px #ff0;">
                        </div>
                    </div>
                </div>
                <div id="minimap-container">
                    <canvas id="minimap-canvas" width="100" height="100"></canvas>
                </div>
            </div>
            <div id="gauge-box">
                <span class="bar-label">SHIELD</span>
                <div class="bar-frame">
                    <div id="shield-bar"></div>
                </div>

                <span class="bar-label enemy">ENEMY SWARM</span>
                <div class="bar-frame enemy">
                    <div id="enemy-bar"></div>
                </div>

                <div id="boss-ui-container">
                    <span class="bar-label" id="boss-name-label">BOSS: NAME</span>
                    <div id="boss-bar-frame" class="bar-frame boss">
                        <div id="boss-hp-bar-inline"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="warning-msg">GRAVITY CRITICAL</div>
        <div id="stage-msg">STAGE CLEAR</div>





        <div id="ending-msg">
            <h1 style="color:#fff; font-size:30px; text-shadow:0 0 30px #0ff; margin-bottom:5px;">MISSION COMPLETE</h1>
            <p style="color:#0ff; font-size:14px; letter-spacing:3px; margin-bottom:15px;">ALL SECTORS LIBERATED</p>
            <div id="final-score-val" style="color:#fff; font-size:24px; margin-bottom:20px; font-family:'Orbitron';">TOTAL SCORE: 0</div>
            <div class="menu-btn" id="btn-next-result" style="margin-top:10px;">NEXT</div>
        </div>
    </div>

    <div id="name-input-area" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:#000; z-index:300; flex-direction:column; align-items:center; justify-content:center;">
        <h2 id="clear-congrats-msg" style="display:none; color:#ffd700; font-size:36px; text-shadow:0 0 20px #ffd700; margin-bottom:10px;">CONGRATULATIONS!</h2>

        <h2 id="result-score-display" style="color:#fff; font-size:32px; margin-bottom:20px;">SCORE: 0</h2>
        <p style="color:#0ff; margin-bottom:10px; text-align:center; width:100%;">REGISTER TO WORLD RANKING?</p>
        <input type="text" id="player-name-input" placeholder="ENTER NAME" maxlength="10">

        <div style="display:flex; gap:20px; margin-top:10px;">
            <div class="menu-btn" id="submit-score-btn" style="min-width: 140px; padding: 10px;">SUBMIT</div>
            <div class="menu-btn" id="skip-score-btn" style="min-width: 140px; padding: 10px; border-color:#555; color:#aaa;">SKIP</div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="menu-title"
            style="color:#0ff; font-size:36px; margin-bottom:10px; text-shadow:0 0 20px #0ff; text-align:center;">
            NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>
        </h1>

        <div id="menu-buttons-container" style="display:flex; flex-direction:column; align-items:center;">
            <div class="menu-btn" id="btn-start">START GAME</div>
            <div class="menu-btn" id="btn-ranking">WORLD RANKING</div>
            <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
            <div class="menu-btn" id="btn-title" style="display:none;">TITLE</div>
        </div>

        <div id="menu-footer" style="font-size:12px;color:#888;margin-top:20px;">
            PC: [X] Bomb | MOBILE: Small Button to Bomb
        </div>
    </div>


    <div id="ranking-overlay">
        <h1 style="color:#0ff; text-shadow:0 0 20px #0ff; margin-bottom: 2px;">TOP COMMANDERS</h1>
        <div id="loading-ranking" style="color:#0ff; animation: blink 0.5s infinite;">CONNECTING...</div>

        <div id="ranking-scroll-container">
            <table id="ranking-table">
                <thead>
                    <tr>
                        <th style="width:50px;">RANK</th>
                        <th style="text-align:left;">NAME</th>
                        <th>STAGE</th>
                        <th style="text-align:right;">SCORE</th>
                    </tr>
                </thead>
                <tbody id="ranking-list-body"></tbody>
            </table>
        </div>

        <div class="menu-btn" id="close-ranking-btn">CLOSE</div>
    </div>

    <div id="pause-overlay">
        <h1 style="color:#fff; font-size:40px; text-shadow:0 0 10px #fff;">PAUSED</h1>
        <p style="color:#aaa; margin-top:20px;">TAP TO RESUME</p>
    </div>

    <div id="ost-ui">
        <h2 style="color:#0ff; text-shadow:0 0 20px #0ff; margin-bottom: 5px;">SOUNDTRACK</h2>

        <div id="ost-scroll-container">
            <div id="track-list"></div>
        </div>

        <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
    </div>

    <div id="controls">
        <div id="stick-left" class="joystick-area">
            <div class="knob" id="knob-left"></div>
        </div>
        <div id="stick-right" class="joystick-area">
            <div class="knob" id="knob-right"></div>
        </div>
        <div id="launch-btn">BOMB</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCRjHe893FZopPErdjtgX8KJ8KPT_rmgnI",
            authDomain: "stellar-gravity.firebaseapp.com",
            projectId: "stellar-gravity",
            storageBucket: "stellar-gravity.firebasestorage.app",
            messagingSenderId: "936422140891",
            appId: "1:936422140891:web:d4e55c30507570602515fe",
            measurementId: "G-0FWP5X8T2T"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const SCORES_COLLECTION = "neon_gravity_scores";

        // HTML要素の取得
        const rankingOverlay = document.getElementById("ranking-overlay");
        const rankingBody = document.getElementById("ranking-list-body");
        const loadingEl = document.getElementById("loading-ranking");
        const tableEl = document.getElementById("ranking-table");
        const closeRankingBtn = document.getElementById("close-ranking-btn");

        // 閉じた後の動作を保存する変数
        let onRankingCloseAction = null;

        function escapeHtml(str) {
            if (!str) return "";
            return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        }

        // --- ゲーム側から呼び出すための「窓口」オブジェクト ---
        window.firebaseOps = {
            isReady: true, // 準備完了フラグ

            // ランキング取得（表示用）
            getRanking: async () => {
                const q = query(collection(db, SCORES_COLLECTION), orderBy("score", "desc"), limit(10));
                return await getDocs(q);
            },

            // 10位以内かどうかの判定用
            checkRankIn: async (currentScore) => {
                const q = query(collection(db, SCORES_COLLECTION), orderBy("score", "desc"), limit(10));
                const snapshot = await getDocs(q);

                // データが10件未満なら無条件でランクイン
                if (snapshot.size < 10) return true;

                // 10位（リストの最後）のスコアを取得
                const tenthData = snapshot.docs[snapshot.size - 1].data();
                const tenthScore = tenthData.score;

                // 現在のスコアが10位より大きければランクイン
                return currentScore > tenthScore;
            },

            // 送信 ＆ 11位以下の削除処理
            submitAndCleanup: async (score, stage, name) => {
                // 1. 追加
                await addDoc(collection(db, SCORES_COLLECTION), {
                    name: name,
                    score: score,
                    stage: stage,
                    timestamp: serverTimestamp()
                });

                // 2. 全件取得して整列
                const qAll = query(collection(db, SCORES_COLLECTION), orderBy("score", "desc"));
                const snapshot = await getDocs(qAll);

                // 3. 11件目以降があれば削除
                if (snapshot.size > 10) {
                    const deletePromises = [];
                    // 10番目(インデックス10)以降を全て削除対象にする
                    for (let i = 10; i < snapshot.size; i++) {
                        deletePromises.push(deleteDoc(snapshot.docs[i].ref));
                    }
                    await Promise.all(deletePromises);
                }
            }
        };

        // --- ランキング表示関数 (引数 onClose で閉じた後の処理を受け取る) ---
        window.showRanking = async function (onClose = null) {
            rankingOverlay.style.display = "flex";
            loadingEl.style.display = "block";
            tableEl.style.display = "none";
            rankingBody.innerHTML = "";

            // 閉じた後のアクションを保存
            onRankingCloseAction = onClose;

            try {
                const snapshot = await window.firebaseOps.getRanking();

                if (snapshot.empty) {
                    rankingBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">NO DATA</td></tr>';
                } else {
                    let rank = 1;
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const tr = document.createElement("tr");
                        let rankClass = "";
                        let rankText = "#" + rank;
                        if (rank === 1) { rankClass = "rank-1"; rankText = "1ST"; }
                        else if (rank === 2) { rankClass = "rank-2"; rankText = "2ND"; }
                        else if (rank === 3) { rankClass = "rank-3"; rankText = "3RD"; }

                        const stageVal = data.stage ? "ST." + data.stage : "-";

                        tr.innerHTML = `
                                                <td class="${rankClass}" style="text-align:center;">${rankText}</td>
                                                <td style="text-align:left;">${escapeHtml(data.name)}</td>
                                                <td style="color:#aaa; text-align:center;">${stageVal}</td>
                                                <td style="text-align:right; color:#0ff;">${data.score.toLocaleString()}</td>
                                            `;
                        rankingBody.appendChild(tr);
                        rank++;
                    });
                }
                loadingEl.style.display = "none";
                tableEl.style.display = "table";
            } catch (e) {
                console.error("Ranking Error:", e);
                loadingEl.innerText = "CONNECTION ERROR";
            }
        };

        // 初期化完了時、名前の読み込み
        const saved = localStorage.getItem("neonGravity_last_name");
        const nameInput = document.getElementById("player-name-input");
        if (saved && nameInput) nameInput.value = saved;

        // タイトル画面のランキングボタン（閉じた後は何もしない）
        const btnRanking = document.getElementById("btn-ranking");
        if (btnRanking) btnRanking.onclick = () => window.showRanking(null);

        // CLOSEボタンの動作設定
        if (closeRankingBtn) {
            closeRankingBtn.onclick = () => {
                rankingOverlay.style.display = "none";
                // 閉じた後の処理があれば実行（ここでゲームオーバー画面への移行などを行う）
                if (onRankingCloseAction) {
                    onRankingCloseAction();
                    onRankingCloseAction = null; // 一度実行したらリセット
                }
            };
        }

        // 準備完了イベント発火
        window.dispatchEvent(new Event('firebase-ready'));
    </script>

    <script>
        // =========================================================
        // 1. システム・グローバル基本設定
        // =========================================================
        const G_SCALE = 0.7;          // 全体の描画スケール（標準の70%）
        const SPEED_SCALE = 0.25;     // ゲーム全体の速度倍率（全ての移動に適用）
        const WALL_MARGIN = 5;        // 画面端の見えない壁の余白
        const GRID_SPACING = 32;      // 背景グリッド線の間隔（小さいほど網目が細かい）

        let gameSpeed = 1.0;          // ゲーム速度係数（動的なスロー演出用）
        let cameraScale = 1.0;        // カメラのズーム倍率（1.0=通常、0.75=縮小）
        let frame = 0;                // 経過フレームカウント
        let width, height;            // 画面サイズ（resize関数で設定）
        let worldSize = 0;            // ワールドサイズ（resize関数で設定）

        let gameState = 'TITLE';      // 現在のゲーム状態 ('TITLE', 'PLAYING', 'PAUSED', 'DYING', 'GAMEOVER_UI', 'ENDING', 'OST')
        let previousGameState = '';   // ポーズ前の状態保存用

        // =========================================================
        // 2. ステージ・難易度・進行管理
        // =========================================================
        const START_STAGE = 1;        // 開始ステージ番号

        const MAX_STAGE = 10;          // 最大ステージ数
        let currentStage = 1;         // 現在のステージ番号
        let stage = 1;                // 表示上のステージ番号
        let score = 0;                // 現在のスコア

        let spawnedCount = 0;         // 現在のステージで生成済みの敵数
        let enemiesToSpawn = 0;       // 現在のステージの総出現ノルマ
        let enemiesKilled = 0;        // 現在のステージで倒した敵数
        let isStageClear = false;     // ステージクリアフラグ
        let dyingTimer = 0;           // 死亡演出用タイマー

        let rushBossIndex = 0;          // ボスラッシュモード:現在戦っているボスの番号 (0~7)
        let rushIntervalTimer = 0;      // ボスラッシュモード:ボス撃破後のインターバルタイマー

        // ステージごとの敵総出現数
        const STAGE_ENEMY_COUNTS = [
            60,  // Stage 1
            80,  // Stage 2
            50,  // Stage 3
            150, // Stage 4
            180, // Stage 5
            220, // Stage 6
            280, // Stage 7
            400  // Stage 8 (Final)
        ];

        // 画面内に同時に存在できる敵の最大数（ステージ別）
        const STAGE_MAX_ON_SCREEN = [
            15, 20, 25, 30, 35, 40, 45, 60
        ];

        // 難易度上昇パラメータ
        const DIFFICULTY_CONFIG = {
            SPEED_INC: 0.08,       // 1ステージごとの敵速度上昇率 (8%)
            HP_INC: 0.5,           // 1ステージごとの敵HP上昇補正
            SPAWN_INC: 15,         // 1ステージごとに増える敵の数
            BULLET_SPEED_INC: 0.06 // 1ステージごとの敵弾速上昇率 (6%)
        };

        // 各ステージの出現エネミープール
        const STAGE_ENEMIES = {
            1: ['triangle', 'triangle', 'triangle', 'dragon'],
            2: ['triangle', 'triangle', 'tadpole', 'dragon'],
            3: ['asteroid', 'asteroid', 'asteroid', 'tadpole'],
            4: ['triangle', 'triangle', 'tadpole', 'tadpole', 'dragon', 'dragon', 'asteroid'],
            5: ['triangle', 'tadpole', 'dragon', 'triangle', 'hunter', 'asteroid'],
            6: ['triangle', 'tadpole', 'dragon', 'triangle', 'hunter', 'hunter', 'asteroid'],
            7: ['triangle', 'tadpole', 'dragon', 'dragon', 'hunter', 'hunter', 'asteroid'],
            8: ['triangle', 'hunter', 'tadpole', 'dragon', 'asteroid']
        };

        // Stage 9 (ボスラッシュ) 専用の雑魚スポーン設定
        const BOSS_RUSH_SPAWN_CONFIG = {
            INTERVAL: 40,      // 出現間隔 (フレーム数)。小さいほど高頻度
            MAX_ENEMIES: 15,    // 画面内に存在できる雑魚の最大数
            SPAWN_COUNT: 2,     // 1回のスポーンで出現する敵の数
            WARP_DELAY: 400     // ワームホール出現から敵が出るまでの待ち時間(ms)
        };

        // Stage 9 (ボスラッシュ) 専用のボス弾速設定
        const BOSS_RUSH_BULLET_CONFIG = {
            PHASE1_LASER_SPD: 2,  // フェーズ1：拡散レーザーの速度倍率
            PHASE2_SNIPE_SPD: 15,   // フェーズ2：狙撃弾の基本速度
            PHASE3_MISSILE_SPD: 1.5 // フェーズ3：誘導ミサイルの速度倍率
        };

        // =========================================================
        // 3. プレイヤー（自機）設定・データ
        // =========================================================
        const PLAYER_BASE_SPEED = 10; // 自機の基本移動速度
        const PLAYER_BASE_SHIELD = 100; // 100
        const MAX_WEAPON_LEVEL = 7;    // 通常ショットの最大強化レベル
        const DEFAULT_WEAPON_LEVEL = 1;    // 初期武器レベル

        // プレイヤーオブジェクト初期化
        const player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            satellites: [],
            shield: PLAYER_BASE_SHIELD,
            weaponLevel: 1,
            invuln: 0,
            laserTimer: 0,
            history: []
        };

        // 入力状態管理オブジェクト
        const input = {
            move: { x: 0, y: 0, active: false },
            aim: { x: 0, y: 0, active: false },
            keys: {}
        };

        // カメラ座標
        let camera = { x: 0, y: 0 };


        // =========================================================
        // 4. 敵（エネミー）設定・データ
        // =========================================================

        // 敵の移動速度設定 (SPEED_SCALE適用前のベース値)
        const ENEMY_SPEEDS = {
            TRIANGLE: 8,     // 紫：高速で直線的な動き
            CUBE: 2.5,         // 緑：アイテムキャリア、動きは遅め
            TADPOLE: 12,       // 白：精子型、非常に素早い
            DRAGON: 5,         // 赤：中ボス級、最高速度が高い
            HUNTER: 7,         // 橙：特殊攻撃型
            HUNTER_ROT: 3,     // 接近時の回転速度
            ASTEROID: 3.5,      // 白：分裂する岩、慣性移動
            PHANTOM: 2.0,   // ★追加: ステルス時の基本速度。突進時は別計算
            ECLIPSE: 1.5    // ★追加: 中ボス。超鈍足でジワジワ迫る
        };

        const DRAGON_ACCELERATION = 0.2; // ドラゴンのプレイヤー追尾加速力

        // 当たり判定（半径）設定
        const ENEMY_HITBOX = {
            TRIANGLE: 12,
            CUBE: 15,
            TADPOLE: 18,
            DRAGON: 25,
            HUNTER: 20,        // 星型のため少し大きめ
            PHANTOM: 16,    // ★追加
            ECLIPSE: 40,    // ★追加: 巨大な当たり判定
            BULLET: 8          // 赤い敵弾の判定サイズ
        };

        // エンティティ配列の初期化
        let enemies = [];
        let enemyBullets = [];



        // =========================================================
        // 5. ボス（BOSS）設定・データ
        // =========================================================
        let isBossSpawned = false;   // ボス出現済みフラグ
        let isBossWarning = false;   // 警告演出中フラグ
        let warningTimer = 0;        // 警告演出用タイマー
        let nextBossSpawnX = 0;      // ボス出現予定座標X
        let nextBossSpawnY = 0;      // ボス出現予定座標Y

        // ボスのバリエーション設定
        const BOSS_VARIANTS = [
            { name: 'TRI-FORTRESS', sides: 3, color: '#f0f', hp: 100, bulletCount: 3, speedFactor: 1.5 },
            { name: 'DIAMOND-CORE', sides: 4, color: '#ffff00', hp: 140, bulletCount: 4, speedFactor: 1.3 },
            { name: 'PENTA-BASE', sides: 5, color: '#0f8', hp: 140, bulletCount: 5, speedFactor: 1.1 },
            { name: 'HEXAGON-NEST', sides: 6, color: '#0cc', hp: 160, bulletCount: 6, speedFactor: 1.0 },
            { name: 'HEPTA-GATE', sides: 7, color: '#44f', hp: 180, bulletCount: 7, speedFactor: 0.9 },
            { name: 'OCTAGON-COMMAND', sides: 8, color: '#f40', hp: 200, bulletCount: 8, speedFactor: 0.8 },
            { name: 'NONA-REVEALER', sides: 9, color: '#f08', hp: 220, bulletCount: 9, speedFactor: 0.7 },
            { name: 'DECA-DECIMATOR', sides: 10, color: '#fff', hp: 300, bulletCount: 10, speedFactor: 0.6 }
        ];

        const WARNING_SOUND_INTERVAL = 48;


        // =========================================================
        // 6. 弾丸（ショット・プロジェクトタイル）設定
        // =========================================================
        const BULLET_CONFIG = {
            PLAYER: {
                SPEED: 32.0,   // 自機の弾の速さ
                LIFE: 120      // 自機の弾の射程（寿命）
            },
            ENEMY_NORMAL: {
                SPEED: 10.0,   // 雑魚敵の弾の速さ
                LIFE: 300      // 敵弾の射程
            },
            BOSS_LASER: {
                SPEED: 9.0,    // ボスのバラ撒きレーザーの速さ
                LIFE: 300
            },
            BOSS_HOMING: {
                SPEED: 10.0,    // ボスのホーミングミサイルの速さ
                LIFE: 300
            }
        };

        let bullets = [];      // プレイヤーの弾
        let lasers = [];       // プレイヤーのレーザー
        let missiles = [];     // プレイヤーのホーミングミサイル（サテライト発射）


        // =========================================================
        // 7. 出現（スポーン）・アイテム・演出・環境
        // =========================================================

        // スポーンロジック設定
        const SPAWN_SETTINGS = {
            MAX_WORMHOLES_BASE: 3,  // 同時に存在できるワームホールの基本数
            SPAWN_INTERVAL: 180,    // 敵が出る間隔（180フレーム = 3秒）
            WORMHOLE_CHANCE: 0.02   // 毎フレームの新ワームホール発生確率
        };

        // アイテム持続時間設定
        const INVULN_DURATION = 400;  // 無敵状態の持続時間
        const LASER_DURATION = 400;   // 特殊レーザーの持続時間
        const ITEM_LIFE = 300;        // アイテムが消滅するまでの時間

        // アイテムドロップ率設定
        const DROP_RATES = {
            LEVEL: 0.30,       // レベルアップ (30%)
            LASER: 0.10,       // レーザー (10%)
            INVINCIBLE: 0.05,  // 無敵 (5%)
            SHIELD_LOW: 0.20,  // ピンチ時シールド回復 (20%)
            SHIELD_NORM: 0.05  // 通常時シールド回復 (5%)
        };

        let levelItemsDroppedInStage = 0; // ステージ内でドロップしたレベルアップアイテム数

        // エフェクト設定
        const EXPLOSION_SPEED_MAG = 2.0; // 撃破火花の散る速さ
        const EXPLOSION_COUNT_MAG = 1.5; // 撃破火花の量

        // その他のエンティティ配列
        let particles = [];    // パーティクル
        let crystals = [];     // スコアアイテム（クリスタル）
        let powerups = [];     // パワーアップアイテム
        let wormholes = [];    // 出現口
        let scorePopups = [];  // スコア表示
        let rings = [];        // 衝撃波リング
        let gridPoints = [];   // 背景グリッド点
        let stars = [];        // 背景の星


        // =========================================================
        // 8. UI要素・DOM参照
        // =========================================================
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const miniMapCanvas = document.getElementById('minimap-canvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');

        const ui = {
            overlay: document.getElementById('overlay'),
            pauseOverlay: document.getElementById('pause-overlay'),
            ost: document.getElementById('ost-ui'),
            controls: document.getElementById('controls'),
            score: document.getElementById('score-display'),
            stage: document.getElementById('stage-num'),

            weaponDisplay: document.getElementById('weapon-display'),

            shieldBar: document.getElementById('shield-bar'),
            shieldVal: document.getElementById('shield-val'),
            enemyBar: document.getElementById('enemy-bar'),
            invulnWrapper: document.getElementById('invuln-wrapper'),
            invulnBar: document.getElementById('invuln-bar'),
            msg: document.getElementById('stage-msg'),
            warn: document.getElementById('warning-msg'),

            // コントローラー・ボタン
            launchBtn: document.getElementById('launch-btn'),
            knobL: document.getElementById('knob-left'),
            knobR: document.getElementById('knob-right'),
            stickL: document.getElementById('stick-left'),
            stickR: document.getElementById('stick-right'),

            // メニューボタン
            btnStart: document.getElementById('btn-start'),
            btnOst: document.getElementById('btn-ost'),
            btnTitle: document.getElementById('btn-title'),
            titleText: document.querySelector('#overlay h1'),

            // ボスUI
            bossContainer: document.getElementById('boss-ui-container'),
            bossNameLabel: document.getElementById('boss-name-label'),
            bossBarFrame: document.getElementById('boss-bar-frame'),
            bossHpBarInline: document.getElementById('boss-hp-bar-inline'),

            // リザルト・エンディング
            endingHud: document.getElementById('ending-msg'),
            finalScore: document.getElementById('final-score-val'),
            btnBackTitle: document.getElementById('btn-back-to-title'),
            btnNextResult: document.getElementById('btn-next-result'),

            // ランキング・名前入力
            submitBtn: document.getElementById("submit-score-btn"),
            skipScoreBtn: document.getElementById("skip-score-btn"),
            nameInput: document.getElementById("player-name-input"),
            nameInputArea: document.getElementById("name-input-area"),
        };


      

        // =========================================================
        // 2. オーディオシステム (Audio System)
        // =========================================================

        const BGM_FILES = {
            title: 'audio/Neon_Gravity_Title.mp3',
            clear: 'audio/Neon_Gravity_Clear.mp3',
            boss: 'audio/Neon_Gravity_Boss.mp3',
            last: 'audio/Neon_Gravity_Last.mp3',
            story: 'audio/Neon_Gravity_Story.mp3',
            stages: ['audio/Neon_Gravity_00.mp3', 'audio/Neon_Gravity_01.mp3', 'audio/Neon_Gravity_02.mp3', 'audio/Neon_Gravity_03.mp3']
        };

        const AudioSys = {
            ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null, activeNodes: [],
            init() {
                if (!this.ctx) {
                    try { const AC = window.AudioContext || window.webkitAudioContext; if (AC) { this.ctx = new AC(); this.createNoise(); } } catch (e) { }
                }
                if (!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
            },
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => { }); },
            createNoise() {
                if (!this.ctx) return;
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                this.noiseBuffer = buf;
            },
            playSE(type) {
                if (!this.ctx) return;
                this.resume();
                const t = this.ctx.currentTime;

                // 親となるGainNode
                const g = this.ctx.createGain();
                g.connect(this.ctx.destination);

                // 管理リストに追加
                const nodeRef = { type: type, node: g };
                this.activeNodes.push(nodeRef);

                // ★重要：削除までの時間を管理する変数（初期値2000ms）
                let cleanupTime = 2000;

                if (type === 'shoot') {
                    // ... (shootの処理はそのまま) ...
                    const o = this.ctx.createOscillator();
                    o.type = 'triangle';
                    o.frequency.setValueAtTime(800, t);
                    o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.08, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g);
                    o.start(t);
                    o.stop(t + 0.1);

                } else if (type === 'warning') {
                    const repeatCount = 6;
                    const interval = (typeof WARNING_SOUND_INTERVAL !== 'undefined' ? WARNING_SOUND_INTERVAL : 60) / 60;
                    const frequencies = [400, 195, 100];
                    const duration = 0.6;

                    // ★重要：WARNING音の総時間を計算して、削除時間を延長する
                    // (間隔 × 回数 + 音の余韻) * 1000ms + 余裕を持たせて500ms
                    const totalDuration = (repeatCount * interval) + duration;
                    cleanupTime = (totalDuration * 1000) + 500;

                    for (let i = 0; i < repeatCount; i++) {
                        const startTime = t + (i * interval);
                        frequencies.forEach((freq) => {
                            const o = this.ctx.createOscillator();
                            const subG = this.ctx.createGain();

                            o.type = 'sawtooth';
                            o.frequency.setValueAtTime(freq, startTime);
                            o.frequency.linearRampToValueAtTime(freq * 1.8, startTime + duration);

                            const volume = 0.10;
                            subG.gain.setValueAtTime(volume, startTime);
                            subG.gain.linearRampToValueAtTime(volume, startTime + duration - 0.1);
                            subG.gain.linearRampToValueAtTime(0, startTime + duration);

                            o.connect(subG);
                            subG.connect(g); // 親ノードに接続

                            o.start(startTime);
                            o.stop(startTime + duration);
                        });
                    }
                } else if (type === 'laser') {
                    // ... (以下変更なし) ...
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(120, t); o.frequency.linearRampToValueAtTime(80, t + 0.15);
                    const mod = this.ctx.createOscillator(); mod.type = 'square'; mod.frequency.value = 500;
                    const modGain = this.ctx.createGain(); modGain.gain.value = 500;
                    mod.connect(modGain); modGain.connect(o.frequency); mod.start(t); mod.stop(t + 0.15);
                    g.gain.setValueAtTime(0.10, t); g.gain.linearRampToValueAtTime(0, t + 0.15);
                    o.connect(g); o.start(t); o.stop(t + 0.15);
                } else if (type === 'explode' || type === 'dragon_explode') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const f = this.ctx.createBiquadFilter(); f.type = 'lowpass';
                        const startFreq = type === 'dragon_explode' ? 200 : 600;
                        const dur = type === 'dragon_explode' ? 1.5 : 0.5;
                        f.frequency.setValueAtTime(startFreq, t); f.frequency.exponentialRampToValueAtTime(20, t + dur);
                        g.gain.setValueAtTime(type === 'dragon_explode' ? 0.9 : 0.7, t); g.gain.exponentialRampToValueAtTime(0.01, t + dur);
                        n.connect(f); f.connect(g); n.start(t); n.stop(t + dur);
                    }
                } else if (type === 'launch') {
                    if (this.noiseBuffer) {
                        const n = this.ctx.createBufferSource(); n.buffer = this.noiseBuffer;
                        const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';
                        o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(40, t + 0.3);
                        filter.frequency.setValueAtTime(1000, t); filter.frequency.exponentialRampToValueAtTime(100, t + 0.3);
                        g.gain.setValueAtTime(0.4, t); g.gain.linearRampToValueAtTime(0, t + 0.3);
                        n.connect(filter); o.connect(filter); filter.connect(g);
                        n.start(t); n.stop(t + 0.3);
                        o.start(t); o.stop(t + 0.3);
                    }
                } else if (type === 'powerup') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1800, t + 0.2);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'damage') {
                    const o = this.ctx.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(50, t + 0.2);
                    g.gain.setValueAtTime(0.16, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                    o.connect(g); o.start(t); o.stop(t + 0.2);
                } else if (type === 'invincible') {
                    const o = this.ctx.createOscillator(); o.type = 'sine';
                    o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(800, t + 0.5);
                    g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t + 0.5);
                    o.connect(g); o.start(t); o.stop(t + 0.5);
                } else if (type === 'boss_hit') {
                    const o = this.ctx.createOscillator(); o.type = 'square';
                    const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.Q.value = 8;
                    o.frequency.setValueAtTime(350, t); o.frequency.exponentialRampToValueAtTime(50, t + 0.15);
                    f.frequency.setValueAtTime(3000, t); f.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    o.connect(f); f.connect(g);
                    o.start(t); o.stop(t + 0.15);
                }

                setTimeout(() => {
                    const index = this.activeNodes.indexOf(nodeRef);
                    if (index > -1) this.activeNodes.splice(index, 1);
                }, cleanupTime);
            },

            stopSE(targetType = null) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                for (let i = this.activeNodes.length - 1; i >= 0; i--) {
                    const item = this.activeNodes[i];
                    if (!targetType || item.type === targetType) {
                        try {
                            const g = item.node;
                            // 1. まず音量を0へ急降下
                            g.gain.cancelScheduledValues(t);
                            g.gain.setValueAtTime(g.gain.value, t);
                            g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

                            // 2. ★追加：0.1秒後にスピーカーから物理的に切断する
                            // (setTimeoutを使うことで、上記のフェードアウトを一瞬効かせてから切る)
                            setTimeout(() => {
                                try { g.disconnect(); } catch (e) { }
                            }, 100);

                        } catch (e) { }

                        this.activeNodes.splice(i, 1);
                    }
                }
            },

            playBGM(key, idx = 0) {
                if (!this.bgmEl) return;

                let src;
                if (key === 'title') src = BGM_FILES.title;
                else if (key === 'clear') src = BGM_FILES.clear;
                else if (key === 'boss') src = BGM_FILES.boss;
                else if (key === 'story') src = BGM_FILES.story; // ★追加
                else if (key === 'last') src = BGM_FILES.last; // ★追加
                else {
                    const actualIdx = idx % BGM_FILES.stages.length;
                    src = BGM_FILES.stages[actualIdx];
                }

                if (this.currentSrc === src && !this.bgmEl.paused) return;

                // ★追加：進行中のフェード処理があればキャンセルする
                clearInterval(this.bgmFadeInterval);

                this.bgmEl.src = src;
                this.bgmEl.currentTime = 0;

                this.bgmEl.volume = 0.4; // 通常のゲーム中BGMの音量
                this.bgmEl.play().catch(e => { });
                
                this.currentSrc = src;
            },

            fadeOutBGM() {
                if (!this.bgmEl || this.bgmEl.paused) return;

                clearInterval(this.bgmFadeInterval);
                this.bgmFadeInterval = setInterval(() => {
                    if (this.bgmEl.volume > 0.05) {
                        this.bgmEl.volume -= 0.05;
                    } else {
                        this.bgmEl.volume = 0;
                        this.bgmEl.pause();
                        clearInterval(this.bgmFadeInterval);
                    }
                }, 100);
            },

            stopBGM() {
                clearInterval(this.bgmFadeInterval); // フェード中でも即座に止める
                if (this.bgmEl) this.bgmEl.pause();
            },
            pauseBGM() { if (this.bgmEl && !this.bgmEl.paused) this.bgmEl.pause(); },
            resumeBGM() { if (this.bgmEl && this.bgmEl.paused && this.currentSrc) this.bgmEl.play().catch(() => { }); }
        };

        // --- Menu Logic ---
        function openOST() {
            AudioSys.resume();
            ui.overlay.style.display = 'none';


            gameState = 'OST';
            ui.ost.style.display = 'flex';
            const list = document.getElementById('track-list');
            list.innerHTML = '';

            // ★ここに 'Boss Theme' を追加します
            const tracks = [
                { n: 'Title Theme', k: 'title' },
                { n: 'Stage 1', k: 'stage', i: 0 },
                { n: 'Stage 2', k: 'stage', i: 1 },
                { n: 'Stage 3', k: 'stage', i: 2 },
                { n: 'Stage 4', k: 'stage', i: 3 },
                { n: 'Boss Theme', k: 'boss' },
                { n: 'Last Boss Theme', k: 'last' },
                { n: 'Story', k: 'story' },  
                { n: 'Clear Theme', k: 'clear' }
            ];

            tracks.forEach(t => {
                const d = document.createElement('div'); d.className = 'track-item'; d.innerText = t.n;
                d.onclick = () => {
                    AudioSys.playBGM(t.k, t.i);
                    document.querySelectorAll('.track-item').forEach(e => e.classList.remove('playing'));
                    d.classList.add('playing');
                };
                list.appendChild(d);
            });
        }

        function closeOST() {
            AudioSys.stopBGM();
            returnToTitle();
        }


        // =========================================================
        // 3. 初期化・システム制御 (Core Logic)
        // =========================================================
        function init() { resize(); AudioSys.init();  }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const size = Math.max(width, height) * 1.5;
            worldSize = size;

            initGrid();
            initStars();
        }

        function initGrid() {
            const cols = Math.ceil(worldSize / GRID_SPACING) + 2;
            const rows = Math.ceil(worldSize / GRID_SPACING) + 2;
            gridPoints = [];
            for (let x = 0; x <= cols; x++) {
                gridPoints[x] = [];
                for (let y = 0; y <= rows; y++) gridPoints[x][y] = { x: x * GRID_SPACING, y: y * GRID_SPACING, ox: x * GRID_SPACING, oy: y * GRID_SPACING, vx: 0, vy: 0 };
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({ x: Math.random() * worldSize, y: Math.random() * worldSize, size: Math.random() * 2, brightness: Math.random(), parallax: 0.2 + Math.random() * 0.3 });
            }
        }

        function setPaused(paused) {
            if (paused) {
                if (gameState === 'PLAYING') {
                    previousGameState = gameState;
                    gameState = 'PAUSED';
                    ui.pauseOverlay.style.display = 'flex';
                }
                AudioSys.pauseBGM();
            } else {
                if (gameState === 'PAUSED') {
                    // Do nothing, wait for user interaction
                } else {
                    AudioSys.resumeBGM();
                }
            }
        }


        // =========================================================
        // 4. シーン・ステージ管理 (Scene & Stage Management)
        // =========================================================
        function startGame() {
            // 1. オーディオシステムの初期化
            AudioSys.init();
            AudioSys.resume();

            // 2. ゲーム状態の設定
            gameState = 'PLAYING';
            ui.overlay.style.display = 'none';
            ui.ost.style.display = 'none';

            // 3. パラメータの初期化
            score = 0;
            stage = START_STAGE;  // 開始ステージを適用
            frame = 0;
            currentStage = START_STAGE;

            player.x = worldSize / 2;
            player.y = worldSize / 2;
            player.vx = 0;
            player.vy = 0;
            player.shield = PLAYER_BASE_SHIELD;
            player.weaponLevel = DEFAULT_WEAPON_LEVEL;
            player.satellites = [];
            player.invuln = 0;
            player.laserTimer = 0;
            player.history = [];

            // 4. 入力デバイスに応じたUI表示
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const isConnected = Array.from(gamepads).some(gp => gp !== null);
            ui.controls.style.display = isConnected ? 'none' : 'block';

            // 5. カメラの瞬間リセット
            cameraScale = 1.0;
            const viewW = width / cameraScale;
            const viewH = height / cameraScale;
            camera.x = player.x - viewW / 2;
            camera.y = player.y - viewH / 2;

            // スムージングのラグを消すため、強制的にカメラ座標を確定
            updateCamera();

            // 6. HUD表示の更新
            ui.score.innerText = "000000";
            ui.stage.innerText = stage; // "1" ではなく変数 stage を入れる
            ui.shieldBar.style.width = "100%";
            ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none';
            ui.msg.style.display = 'none'; // メッセージ類を隠す

            // 7. ステージ開始
            startStage();
        }

        // --- startStage関数の修正 ---
        function startStage() {
            const hud = document.querySelector('.hud-row');
            if (hud) hud.style.display = 'flex';

            spawnedCount = 0;
            enemiesKilled = 0;
            isStageClear = false;
            isBossSpawned = false;
            isBossWarning = false;
            warningTimer = 0;
            levelItemsDroppedInStage = 0;

            ui.msg.style.display = 'none';
            ui.warn.style.display = 'none';
            if (ui.bossContainer) ui.bossContainer.style.display = 'none';

            bullets = []; lasers = []; enemies = []; enemyBullets = [];
            missiles = []; wormholes = [];
            scorePopups = []; rings = [];

            // ★Stage 10 (Battleship Boss) の初期化
            if (stage === 10) {
                ui.msg.innerText = "WARNING\nTHE COLOSSUS APPROACHING";
                ui.msg.style.color = "#f00";
                ui.msg.style.textShadow = "0 0 20px #f00";
                ui.msg.style.display = 'block';

                AudioSys.playBGM('last');

                setTimeout(() => {
                    ui.msg.style.display = 'none';
                    // ラスボス生成
                    spawnEnemy(worldSize / 2, worldSize / 2, 'battleship');
                    isBossSpawned = true;
                    
                }, 4000);

                enemiesToSpawn = 1;
                gameSpeed = 1.0;

                // Stage 9 (Boss Rush)
            } else if (stage === 9) {
                rushBossIndex = 0;
                rushIntervalTimer = 0;
                enemiesToSpawn = 9999;
                ui.msg.innerText = "FINAL MISSION\nBOSS RUSH";
                ui.msg.style.color = "#f00";
                ui.msg.style.display = 'block';
                AudioSys.playBGM('boss');
                setTimeout(() => { ui.msg.style.display = 'none'; }, 4000);
                gameSpeed = 1.0;

                // 通常ステージ
            } else {
                if (stage <= STAGE_ENEMY_COUNTS.length) enemiesToSpawn = STAGE_ENEMY_COUNTS[stage - 1];
                else enemiesToSpawn = STAGE_ENEMY_COUNTS[STAGE_ENEMY_COUNTS.length - 1] + 50;

                if (gameState === 'PLAYING') {
                    const bgmIndex = Math.floor((stage - 1) / 2) % BGM_FILES.stages.length;
                    AudioSys.playBGM('stage', bgmIndex);
                }
                const whCount = Math.max(1, Math.floor((stage + 1) / 2));
                for (let i = 0; i < whCount; i++) spawnWormhole();
                gameSpeed = 1.0;
            }

            distortGrid(worldSize / 2, worldSize / 2, -200, worldSize);
        }

        function resetGame() {
            // 変数リセット
            score = 0;
            stage = currentStage;
            frame = 0;
            spawnedCount = 0;
            enemiesKilled = 0;
            isStageClear = false;
            isBossSpawned = false;
            isBossWarning = false;
            warningTimer = 0;
            levelItemsDroppedInStage = 0;

            bullets = []; lasers = []; enemies = []; enemyBullets = [];
            particles = []; crystals = []; missiles = []; powerups = [];
            wormholes = []; scorePopups = []; rings = [];

            player.x = worldSize / 2; player.y = worldSize / 2;
            player.vx = 0; player.vy = 0;
            player.shield = PLAYER_BASE_SHIELD;
            player.weaponLevel = 1;
            player.invuln = 0; player.laserTimer = 0;
            player.satellites = [];
            player.history = [];

            // --- ★カメラの瞬間リセット ---
            cameraScale = 1.0;
            const viewW = width / cameraScale;
            const viewH = height / cameraScale;
            camera.x = player.x - viewW / 2;
            camera.y = player.y - viewH / 2;

            // これにより、スムージングの計算（ Lerp ）をリセット
            updateCamera();
            // ---------------------------

            ui.score.innerText = "000000"; ui.stage.innerText = stage;
            ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
            ui.shieldBar.style.backgroundColor = '#0ff';
            ui.enemyBar.style.width = "100%";
            ui.warn.style.display = 'none'; ui.msg.style.display = 'none';
            ui.bossContainer.style.display = 'none';
            ui.overlay.style.display = 'none'; ui.controls.style.display = 'block';

            const bgmIndex = Math.floor((stage - 1) / 2) % BGM_FILES.stages.length;
            AudioSys.playBGM('stage', bgmIndex);
            gameState = 'PLAYING';
            startStage();
        }

        // --- checkStageClear関数の修正 ---
        function checkStageClear() {
            let isClearCondition = false;

            if (stage === 9) {
                if (rushBossIndex >= 8) isClearCondition = true;
            } else if (stage === 10) {
                // ラスボス撃破チェック
                if (enemies.length === 0 && isBossSpawned) isClearCondition = true;
            } else {
                const noEnemies = enemies.length === 0;
                const noWormholes = wormholes.filter(w => w.active).length === 0;
                if (noEnemies && noWormholes && isBossSpawned) isClearCondition = true;
            }

            if (!isStageClear && isClearCondition) {
                isStageClear = true;

                // ★Stage 10 クリア時はエンディングへ
                if (stage === MAX_STAGE) {
                    setTimeout(() => showEnding(), 3000);
                    return;
                }

                gameSpeed = 0.25;
                distortGrid(worldSize / 2, worldSize / 2, 1000, worldSize);
                AudioSys.playBGM('clear');

                ui.msg.innerText = "STAGE " + stage + " CLEAR";
                ui.msg.style.display = 'block';

                setTimeout(() => {
                    ui.msg.style.display = 'none';
                    stage++;
                    ui.stage.innerText = stage;
                    startStage();
                }, 4000);
            }
        }




        async function waitForFirebase() {
            return new Promise((resolve) => {
                if (window.firebaseOps && window.firebaseOps.isReady) return resolve();
                const timer = setInterval(() => {
                    if (window.firebaseOps && window.firebaseOps.isReady) {
                        clearInterval(timer);
                        resolve();
                    }
                }, 100);
            });
        }

        async function showGameOver() {
            // すでにゲームオーバー処理中なら何もしない
            if (gameState === 'GAMEOVER_UI') return;

            // ★最重要：即座にステートを変更し、draw関数で黒塗りさせる
            gameState = 'GAMEOVER_UI';

            // 音の停止
            AudioSys.stopBGM();
            AudioSys.stopSE('warning');
            AudioSys.stopSE('boss_engine'); // ボス音なども念のため停止

            ui.controls.style.display = 'none';

            // --- ★追加修正：画面上のあらゆる浮遊テキスト・UIを確実に消す ---
            const hud = document.querySelector('.hud-row');
            if (hud) hud.style.display = 'none';

            ui.endingHud.style.display = 'none'; // MISSION COMPLETE画面
            ui.overlay.style.display = 'none';   // タイトル画面

            // ★これらも消さないと黒画面の上に残ることがある
            ui.msg.style.display = 'none';       // "ALL MISSION CLEAR" 等のメッセージ
            ui.warn.style.display = 'none';      // "WARNING" 等の警告
            if (ui.bossContainer) ui.bossContainer.style.display = 'none'; // ボスHPバー

            // スコア表示の更新（まだ画面には出さない）
            document.getElementById('result-score-display').innerText = `SCORE: ${score.toLocaleString()}`;

            try {
                // 通信待機（この間、画面は真っ黒になります）
                await waitForFirebase();

                // 10位以内かチェック
                let canRegister = false;
                try {
                    canRegister = await window.firebaseOps.checkRankIn(score);
                } catch (e) {
                    console.error("Rank check failed:", e);
                    canRegister = true;
                }

                // --- 通信が終わったら名前入力画面を出す ---
                // 背景が黒(#000)であることをCSSで確認済み
                ui.nameInputArea.style.display = 'flex';

                const msgPara = document.querySelector("#name-input-area p");
                const nameInp = document.getElementById("player-name-input");
                msgPara.style.textAlign = "center";

                if (canRegister) {
                    msgPara.innerText = "NEW RECORD! REGISTER TO WORLD RANKING?";
                    msgPara.style.color = "#0ff";

                    nameInp.style.display = "block";
                    ui.submitBtn.style.display = "block";
                    ui.submitBtn.innerText = "SUBMIT";
                    ui.submitBtn.style.pointerEvents = "auto";

                    ui.skipScoreBtn.innerText = "SKIP";
                    nameInp.focus();
                } else {
                    msgPara.innerText = "RANKING OUT (TOP 10 ONLY)";
                    msgPara.style.color = "#f44";

                    nameInp.style.display = "none";
                    ui.submitBtn.style.display = "none";

                    ui.skipScoreBtn.innerText = "NEXT";
                }

                // --- ボタン処理 ---
                // ★追加: 二重送信を完全に防ぐためのフラグ
                let isSubmitting = false;

                ui.submitBtn.onclick = async () => {
                    // ★追加: すでに送信処理中なら、その後のクリックは全て無視する
                    if (isSubmitting) return;
                    isSubmitting = true;

                    ui.submitBtn.style.pointerEvents = "none";
                    ui.submitBtn.innerText = "SENDING...";
                    const name = nameInp.value.trim() || "PILOT";

                    try {
                        await window.firebaseOps.submitAndCleanup(score, stage, name);
                        localStorage.setItem("neonGravity_last_name", name);
                        ui.nameInputArea.style.display = "none";

                        if (window.showRanking) {
                            window.showRanking(() => {
                                proceedToNextMenu();
                            });
                        } else {
                            proceedToNextMenu();
                        }
                    } catch (e) {
                        console.error(e);
                        alert("Connection error. Please try again.");
                        ui.submitBtn.style.pointerEvents = "auto";
                        ui.submitBtn.innerText = "SUBMIT";

                        // ★エラーが起きて再試行させるときだけフラグを解除する
                        isSubmitting = false;
                    }
                };

                ui.skipScoreBtn.onclick = (e) => {
                    e.preventDefault();
                    proceedToNextMenu();
                };

            } catch (e) {
                console.error("Critical error in showGameOver:", e);
                proceedToNextMenu();
            }
        }

        function proceedToNextMenu() {
            ui.nameInputArea.style.display = 'none';
            ui.overlay.style.display = 'flex';

            // タイトル設定
            let titleHTML = `GAME OVER<br><span style="font-size:20px;color:#f00;">SCORE: ${score.toLocaleString()}</span>`;
            let titleColor = '#f00';

            if (isStageClear) {
                titleHTML = `MISSION COMPLETE<br><span style="font-size:20px;color:#0ff;">SCORE: ${score.toLocaleString()}</span>`;
                titleColor = '#0ff';
            }

            ui.titleText.innerHTML = titleHTML;
            ui.titleText.style.color = titleColor;
            ui.titleText.style.textShadow = `0 0 20px ${titleColor}`;

            // ボタン設定
            ui.btnStart.innerText = 'RETRY';
            ui.btnStart.style.display = 'block';
            ui.btnStart.style.borderColor = titleColor;
            ui.btnStart.style.color = titleColor;
            ui.btnStart.onclick = () => resetGame();

            ui.btnTitle.style.display = 'block';
            ui.btnTitle.style.borderColor = titleColor;
            ui.btnTitle.style.color = titleColor;
            ui.btnTitle.onclick = () => returnToTitle();

            // リザルト画面ではランキングとOSTボタンは隠す
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) btnRanking.style.display = 'none';
            if (ui.btnOst) ui.btnOst.style.display = 'none';
        }

        function returnToTitle() {
            gameState = 'TITLE';

            AudioSys.stopBGM();

            ui.ost.style.display = 'none';
            ui.overlay.style.display = 'flex';
            ui.controls.style.display = 'none';
            ui.msg.style.display = 'none';

            ui.titleText.innerHTML = `NEON GRAVITY<br><span style="font-size:20px;color:#fff;">ORBITAL</span>`;
            ui.titleText.style.color = '#0ff';
            ui.titleText.style.textShadow = '0 0 20px #0ff';

            ui.btnStart.innerText = 'START GAME';
            ui.btnStart.style.display = 'block';
            ui.btnStart.style.borderColor = '#0ff';
            ui.btnStart.style.color = '#0ff';
            ui.btnStart.onclick = startGame;

            ui.btnOst.style.display = 'block';
            ui.btnTitle.style.display = 'none';

            // ★タイトルに戻ったのでランキングボタンを復活させる
            const btnRanking = document.getElementById('btn-ranking');
            if (btnRanking) {
                btnRanking.style.display = 'block';
                btnRanking.style.borderColor = '#0ff';
                btnRanking.style.color = '#0ff';
                // タイトルからの呼び出しは閉じた後何もしない(null)
                btnRanking.onclick = () => window.showRanking(null);
            }

        }






        function showEnding() {
            gameState = 'ENDING';
            //AudioSys.stopBGM();
            //AudioSys.playBGM('clear');

            bullets = []; enemyBullets = []; enemies = [];
            createExplosion(player.x, player.y, '#fff', 200);

            ui.controls.style.display = 'none';

            // ★追加：ここでもHUDを隠す
            const hud = document.querySelector('.hud-row');
            if (hud) hud.style.display = 'none';

            // エンディング画面を表示
            ui.endingHud.style.display = 'flex';

            // HTMLの id="final-score-val" に合わせる
            const finalScoreElement = document.getElementById('final-score-val');
            if (finalScoreElement) {
                finalScoreElement.innerText = "TOTAL SCORE: " + score.toLocaleString();
            }

            // NEXTボタンのクリックイベント
            if (ui.btnNextResult) {
                ui.btnNextResult.onclick = () => {
                    // ★ポイント1: 先に名前入力を「準備」してからエンディング画面を消す
                    // これにより、画面が切り替わる瞬間にゲーム画面が露出するのを防ぎます
                    showGameOver();
                    ui.endingHud.style.display = 'none';
                };
            }
        }

        function triggerBossEncounter() {
            if (isBossWarning) return; // 二重発動防止

            isBossWarning = true;
            AudioSys.playSE('warning');

            // エリア中央へのベクトルを使って出現位置を決める（NaN防止）
            const centerX = worldSize / 2;
            const centerY = worldSize / 2;
            const dx = centerX - player.x;
            const dy = centerY - player.y;
            const distToCenter = Math.hypot(dx, dy) || 1;

            // プレイヤーから300px中央に寄った位置
            const spawnDist = 300;
            let tx = player.x + (dx / distToCenter) * spawnDist;
            let ty = player.y + (dy / distToCenter) * spawnDist;

            // 厳格なクランプ（マージンを多めにとる）
            const margin = 300;
            nextBossSpawnX = Math.max(margin, Math.min(worldSize - margin, tx));
            nextBossSpawnY = Math.max(margin, Math.min(worldSize - margin, ty));

            gameSpeed = 1;
            warningTimer = 180;
        }


        // =========================================================
        // 5. メインループ (Main Loop)
        // =========================================================
        function loop() {
            requestAnimationFrame(loop);
            if (gameState === 'PAUSED') return;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);

            if (gameState === 'PLAYING') {
                update();
            } else if (gameState === 'DYING') {
                updateDying();

            } else if (gameState === 'GAMEOVER_UI' || gameState === 'ENDING') {
                updateParticlesAndRings(); // 爆発やリング
                updateGrid();              // グリッドのゆらぎ
                updateCrystals();           // スコアククリスタルの動き
                updateScorePopups();       // "+100" などの数字
            }

            draw();
        }

        function update() {
            // --- ゲームパッド入力の処理 ---
            handleGamepadInput();

            // --- 警告演出の管理 ---
            if (isBossWarning) {
                warningTimer--;
                if (warningTimer <= 0) {
                    isBossWarning = false;
                    gameSpeed = 1.0;

                    // 通常ステージのボス出現処理（Stage 9, 10以外）
                    // ★修正: stage !== 10 を追加
                    if (stage !== 9 && stage !== 10) {
                        wormholes.unshift({ x: nextBossSpawnX, y: nextBossSpawnY, life: 300, maxLife: 300, active: true });
                        spawnEnemy(nextBossSpawnX, nextBossSpawnY, 'boss');
                        distortGrid(nextBossSpawnX, nextBossSpawnY, 250, 400);
                    }
                }
            }

            frame++;

            // --- プレイヤー座標の安全装置 ---
            if (!Number.isFinite(player.x)) { player.x = worldSize / 2; player.y = worldSize / 2; player.vx = 0; player.vy = 0; }

            // --- コントロール入力と移動 ---
            let mx = input.keys['ArrowLeft'] ? -1 : input.keys['ArrowRight'] ? 1 : input.move.x;
            let my = input.keys['ArrowUp'] ? -1 : input.keys['ArrowDown'] ? 1 : input.move.y;
            const mag = Math.hypot(mx, my); if (mag > 1) { mx /= mag; my /= mag; }
            player.vx = mx * PLAYER_BASE_SPEED * SPEED_SCALE * gameSpeed;
            player.vy = my * PLAYER_BASE_SPEED * SPEED_SCALE * gameSpeed;
            player.x += player.vx;
            player.y += player.vy;

            // 履歴（飛行機雲用）の更新：位置と「その時の角度」を保存
            player.history.unshift({
                x: player.x,
                y: player.y,
                angle: player.angle
            });
            if (player.history.length > 10) player.history.pop();

            // 壁の衝突判定（自機）
            if (player.x < WALL_MARGIN) player.x = WALL_MARGIN; if (player.x > worldSize - WALL_MARGIN) player.x = worldSize - WALL_MARGIN;
            if (player.y < WALL_MARGIN) player.y = WALL_MARGIN; if (player.y > worldSize - WALL_MARGIN) player.y = worldSize - WALL_MARGIN;

            // カメラ更新
            updateCamera();

            // --- 向きと射撃 ---
            if (input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
            else if (Math.hypot(mx, my) > 0.1) player.angle = Math.atan2(my, mx);

            const fireInterval = player.laserTimer > 0 ? 4 : 6;
            if ((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % fireInterval === 0) fire();


            // =========================================================
            // ★変更: スポーン制御ロジック
            // =========================================================
            if (stage === 9) {
                // --- BOSS RUSH LOGIC ---
                const bossExists = enemies.some(e => e.type === 'boss');

                // 1. ボス出現管理
                if (!bossExists && rushBossIndex < 8) {
                    rushIntervalTimer++;
                    // 3秒(180F)待って次ボス出現
                    if (rushIntervalTimer > 180) {
                        rushIntervalTimer = 0;
                        const cx = worldSize / 2;
                        const cy = worldSize / 2;

                        // ワームホール演出
                        wormholes.push({ x: cx, y: cy, life: 300, maxLife: 300, active: true });
                        distortGrid(cx, cy, 300, 500);

                        // ボス生成
                        spawnEnemy(cx, cy, 'boss');
                        const newBoss = enemies[enemies.length - 1];
                        if (newBoss && newBoss.type === 'boss') {
                            const variant = BOSS_VARIANTS[rushBossIndex];
                            newBoss.variant = variant;
                            newBoss.color = variant.color;
                            newBoss.hp = variant.hp * 1.5; // ラッシュ用にHP強化
                            newBoss.maxHp = newBoss.hp;
                            newBoss.scale = 1.5 + (variant.sides * 0.1);
                            newBoss.spawnMax = 150;
                            newBoss.isSpawning = true;
                        }

                        isBossSpawned = true;
                        AudioSys.playSE('warning');
                    }
                }

                // 2. 援護雑魚のスポーン（定数を使用して制御）
                if (bossExists &&
                    enemies.length < BOSS_RUSH_SPAWN_CONFIG.MAX_ENEMIES &&
                    frame % BOSS_RUSH_SPAWN_CONFIG.INTERVAL === 0) {

                    const currentPool = STAGE_ENEMIES[rushBossIndex + 1] || STAGE_ENEMIES[1];
                    const randomType = currentPool[Math.floor(Math.random() * currentPool.length)];

                    const angle = Math.random() * Math.PI * 2;
                    const dist = 600;
                    const sx = Math.max(100, Math.min(worldSize - 100, player.x + Math.cos(angle) * dist));
                    const sy = Math.max(100, Math.min(worldSize - 100, player.y + Math.sin(angle) * dist));

                    // ワームホール生成
                    wormholes.push({ x: sx, y: sy, life: 100, maxLife: 100, active: true });

                    // 指定した数だけ敵を生成
                    setTimeout(() => {
                        if (gameState === 'PLAYING' && stage === 9) {
                            for (let i = 0; i < BOSS_RUSH_SPAWN_CONFIG.SPAWN_COUNT; i++) {
                                // 少し位置をずらして生成
                                const ox = (Math.random() - 0.5) * 20;
                                const oy = (Math.random() - 0.5) * 20;
                                spawnEnemy(sx + ox, sy + oy, randomType);
                            }
                        }
                    }, BOSS_RUSH_SPAWN_CONFIG.WARP_DELAY);
                }

            } else if (stage === 10) {
                // ★追加: Stage 10 はランダムスポーンを一切行わない
                // (ボスはstartStageで生成済み、雑魚召喚はupdateEternityCoreAIで行う)

            } else {
                // --- 通常ステージ (1-8) のスポーンロジック ---
                const maxWormholes = SPAWN_SETTINGS.MAX_WORMHOLES_BASE + stage * 1.5;
                const activeWormholes = wormholes.filter(w => w.active).length;
                const currentMaxOnScreen = STAGE_MAX_ON_SCREEN[stage - 1] || 40;

                let shouldSpawnWormhole = !isBossWarning && spawnedCount < enemiesToSpawn && activeWormholes < maxWormholes && enemies.length < currentMaxOnScreen && Math.random() < SPAWN_SETTINGS.WORMHOLE_CHANCE;
                if (enemies.length === 0 && activeWormholes === 0 && spawnedCount < enemiesToSpawn) shouldSpawnWormhole = true;
                if (shouldSpawnWormhole) spawnWormhole();
            }

            // --- ワームホールの更新 ---
            wormholes.forEach((w) => {
                w.life--;
                if (w.active) {
                    // ★修正: ステージ9と10以外の場合のみ、ワームホールから雑魚を出す
                    if (stage !== 9 && stage !== 10 && w.life > 60 && w.life % SPAWN_SETTINGS.SPAWN_INTERVAL === 0) {
                        const remaining = enemiesToSpawn - spawnedCount;
                        const threshold = enemiesToSpawn * 0.2;

                        // ボス出現判定
                        if (!isBossSpawned) {
                            if (remaining <= threshold || spawnedCount >= enemiesToSpawn) {
                                triggerBossEncounter();
                                isBossSpawned = true;
                                return;
                            }
                        }

                        if (spawnedCount < enemiesToSpawn) {
                            if (Math.random() < 0.15) {
                                spawnEnemy(w.x, w.y, 'cube');
                            } else {
                                const currentPool = STAGE_ENEMIES[stage] || STAGE_ENEMIES[7];
                                const randomType = currentPool[Math.floor(Math.random() * currentPool.length)];
                                spawnEnemy(w.x, w.y, randomType);
                            }
                        }
                    }
                    if (w.life <= 0) w.active = false;

                    // 吸い込み効果
                    const dx = player.x - w.x; const dy = player.y - w.y;
                    const d = Math.hypot(dx, dy) || 0.01;
                    if (d < 180) {
                        const f = 500 / (d + 1);
                        player.x += (dx / d) * f * 0.01 * SPEED_SCALE * gameSpeed;
                        player.y += (dy / d) * f * 0.01 * SPEED_SCALE * gameSpeed;
                    }
                }
            });
            wormholes = wormholes.filter(w => w.life > -60);

            // --- サテライトの更新 ---
            player.satellites.forEach((s, i) => {
                s.angle = (s.angle || 0) + 0.15;
                const rad = 45 * G_SCALE;
                const off = (Math.PI * 2 / player.satellites.length) * i;
                s.x = player.x + Math.cos(s.angle + off) * rad; s.y = player.y + Math.sin(s.angle + off) * rad;
            });

            // --- 各種エンティティ・システムの更新 ---
            updateEntities();
            updateGrid();
            updateScorePopups();
            checkStageClear();
            updateUI();
        }

        function updateCamera() {
            let targetScale = 1.0;
            let focusX = player.x;
            let focusY = player.y;

            // --- 修正箇所：通常のボス、またはラスボスを探す ---
            const boss = enemies.find(e => e.type === 'boss' || e.type === 'battleship');

            if (boss && Number.isFinite(boss.x)) {
                // 1. タイマーの進行
                const smoothMax = (boss.spawnMax || 100) + 20; // spawnMaxがない場合を考慮
                if (boss.cameraLerpTimer === undefined) boss.cameraLerpTimer = 0; // 初期化

                if (boss.cameraLerpTimer < smoothMax) {
                    boss.cameraLerpTimer++;
                }

                const t = boss.cameraLerpTimer / smoothMax;
                const camT = 1 - Math.pow(1 - t, 5);

                const dist = Math.hypot(player.x - boss.x, player.y - boss.y) || 0.1;
                const maxDist = 2200;
                const ratio = Math.min(dist / maxDist, 1.0);

                // 2. ズーム目標値の計算
                targetScale = 1.0 - (ratio * 0.8 * camT);

                // 3. フォーカス位置のブレンド
                const bias = ratio * 0.45 * camT;
                focusX = player.x + (boss.x - player.x) * bias;
                focusY = player.y + (boss.y - player.y) * bias;
            }

            // 4. スムージング
            cameraScale += (targetScale - cameraScale) * 0.04 * gameSpeed;

            // 5. ズームが進むほど強制的に中央へ寄せる補正
            let zoomFactor = Math.max(0, Math.min(1, (1.0 - cameraScale) / 0.8));
            const centerStrength = Math.pow(zoomFactor, 3);

            focusX = focusX * (1 - centerStrength) + (worldSize / 2) * centerStrength;
            focusY = focusY * (1 - centerStrength) + (worldSize / 2) * centerStrength;

            const viewW = width / cameraScale;
            const viewH = height / cameraScale;

            // 6. 最終座標の算出
            let tx = focusX - viewW / 2;
            let ty = focusY - viewH / 2;

            // 7. クランプ処理（境界チェック）
            let padX = 150;
            let padY = 125;
            if (height > width) { padX = 0; } else { padY = 0; }

            if (viewW < worldSize) {
                tx = Math.max(-padX, Math.min(worldSize - viewW + padX, tx));
            } else {
                tx = (worldSize - viewW) / 2;
            }

            if (viewH < worldSize) {
                ty = Math.max(-padY, Math.min(worldSize - viewH + padY, ty));
            } else {
                ty = (worldSize - viewH) / 2;
            }

            // 8. カメラ座標のスムージング
            camera.x += (tx - camera.x) * 0.1 * gameSpeed;
            camera.y += (ty - camera.y) * 0.1 * gameSpeed;
        }

        function updateDying() {
            dyingTimer--;

            // --- メッセージの切り替え演出 ---
            if (dyingTimer === 135) { // 120の少し前にフェードアウト開始
                ui.msg.style.opacity = "0";
            }
            if (dyingTimer === 120) {
                ui.msg.innerText = "GAME OVER";
                ui.msg.style.fontSize = "32px"; // GAME OVERは少し大きく
                ui.msg.style.opacity = "1";     // 再びフェードイン
            }

            // ゲームオーバー直前のフェードアウト
            if (dyingTimer === 20) {
                ui.msg.style.opacity = "0";
            }

            if (gameSpeed < 1.0) {
                gameSpeed += 0.005;
            }

            camera.x += (Math.random() - 0.5) * 10 * gameSpeed;
            camera.y += (Math.random() - 0.5) * 10 * gameSpeed;

            updateGrid();
            updateParticlesAndRings();
            updateEnemyBullets();
            updateEnemiesForDying();
            updateScorePopups();
            updateCrystals();

            if (dyingTimer <= 0) {
                gameSpeed = 1.0;
                ui.msg.style.display = 'none'; // ★次の画面に行く前にメッセージを隠す
                showGameOver();
            }
        }

        function updateEnemiesForDying() {
            enemies.forEach(e => {
                // 自機から敵機へのベクトル（逃げる方向）
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const d = Math.hypot(dx, dy) || 0.001;

                // 離脱ベクトルを計算（徐々に加速して去っていく）
                const escapeSpeed = e.speed * 1.5; // 離脱なので少し速めに
                e.vx += (dx / d) * 0.1;
                e.vy += (dy / d) * 0.1;

                // 速度制限をかけつつ更新
                const cv = Math.hypot(e.vx, e.vy);
                if (cv > escapeSpeed) {
                    e.vx = (e.vx / cv) * escapeSpeed;
                    e.vy = (e.vy / cv) * escapeSpeed;
                }

                e.x += e.vx;
                e.y += e.vy;

                // 進行方向を向かせる
                e.angle = Math.atan2(e.vy, e.vx);

                // 各種演出の更新（しっぽやパーツ回転）
                if (e.type === 'dragon') {
                    let lx = e.x, ly = e.y;
                    e.segments.forEach(s => {
                        const dd = Math.hypot(lx - s.x, ly - s.y);
                        if (dd > 10) { s.x += (lx - s.x) * 0.3; s.y += (ly - s.y) * 0.3; }
                        lx = s.x; ly = s.y;
                    });
                }
                if (e.type === 'tadpole') {
                    e.history.unshift({ x: e.x, y: e.y });
                    if (e.history.length > 60) e.history.pop();
                }
                if (e.type === 'triangle' || e.type === 'cube') {
                    e.rotX += 0.1; e.rotY += 0.1;
                }
            });
        }

        // =========================================================
        // 6. プレイヤー・武器制御 (Player & Weapon Systems)
        // =========================================================
        function fire() {
            if (player.laserTimer > 0) {
                lasers.push({ x: player.x, y: player.y, angle: player.angle, life: 5, width: 40 });
                AudioSys.playSE('laser'); distortGrid(player.x, player.y, 20, 60); return;
            }

            const s = BULLET_CONFIG.PLAYER.SPEED * SPEED_SCALE;
            // レベルごとの発射角度オフセット設定（0 = 前方、Math.PI = 後方）
            const shotPatterns = {
                1: [0.08, -0.08], // 2way
                2: [0.15, 0, -0.15], // 3way(前のみ)
                3: [0.15, 0, -0.15, Math.PI], // 4way(前3 後1)
                4: [0.15, 0, -0.15, Math.PI - 0.15, Math.PI + 0.15], // 5way(前3 後2)
                5: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15], // 6way(前4 後2)
                6: [0.2, 0.07, -0.07, -0.2, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2], // 7way(前4 後2 左右1ずつ)
                7: [0.25, 0.12, 0, -0.12, -0.25, Math.PI - 0.15, Math.PI + 0.15, Math.PI / 2, -Math.PI / 2] // 8way(前5後2 左右1ずつ)
            };

            // 現在のレベルのパターンを取得（最大レベルを超えないように制限）
            const currentPattern = shotPatterns[player.weaponLevel] || shotPatterns[1];

            currentPattern.forEach(offset => {
                const a = player.angle + offset;
                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(a) * s,
                    vy: Math.sin(a) * s,
                    life: BULLET_CONFIG.PLAYER.LIFE
                });
            });

            AudioSys.playSE('shoot'); distortGrid(player.x, player.y, 10, 40);
        }

        function launchSatellites() {
            // サテライトがなければ何もしない
            if (!player.satellites || player.satellites.length === 0) return;

            // 1. 音を鳴らす
            AudioSys.playSE('launch');

            // 2. ミサイルを発射（エラーが起きてもサテライト消去まで進むように try-catch で囲む手もありますが、まずは計算式を安全にします）
            player.satellites.forEach(s => {
                // ★修正: 「自機から見たサテライトの方向」を計算して、外側に飛ばす
                // s.angle (回転用) を使うと、変な方向に飛んだりNaNになったりします
                const angle = Math.atan2(s.y - player.y, s.x - player.x);

                // スピード計算（SPEED_SCALEが未定義の可能性も考慮して安全策をとる）
                const scale = (typeof SPEED_SCALE !== 'undefined') ? SPEED_SCALE : 0.25;
                const speed = 12 * scale;

                // ミサイル配列に安全に追加
                if (typeof missiles !== 'undefined') {
                    missiles.push({
                        x: s.x,
                        y: s.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        target: null, // 初期ターゲットなし
                        life: 200,    // 寿命
                        speed: speed  // 最高速度
                    });
                }
            });

            // 3. ★重要: ここでサテライトを空にしないと、自機の周りに残り続けます
            player.satellites = [];

            // 4. 画面歪み演出（関数がある場合のみ実行）
            if (typeof distortGrid === 'function') {
                distortGrid(player.x, player.y, 300, 400);
            }
        }

        function damage(v) {
            player.shield -= v;
            player.invuln = 60;

            const shieldPercent = Math.max(0, (player.shield / PLAYER_BASE_SHIELD) * 100);
            ui.shieldBar.style.width = shieldPercent + "%";

            AudioSys.playSE('damage');

            distortGrid(player.x, player.y, 50, 100);

            if (player.shield <= 0) {
                gameState = 'DYING';
                AudioSys.stopSE('warning');

                // --- メッセージ表示の初期化 ---
                ui.msg.style.fontSize = "24px";
                ui.msg.style.opacity = "0";
                ui.msg.innerText = "SHIELD LOST";
                ui.msg.style.color = "#f00"; // 文字自体を濃い赤に

                // 光を1層だけ、かつ距離を短く(5px〜8px程度)設定
                ui.msg.style.textShadow = "0 0 5px #f00";

                ui.msg.style.display = 'block';
                // 次のフレームで不透明にしてフェードインさせる
                setTimeout(() => { ui.msg.style.opacity = "1"; }, 10);

                // --- 死亡時の状態リセット ---
                player.invuln = 0;
                player.laserTimer = 0;
                gameSpeed = 0.1;
                dyingTimer = 300;

                bullets = []; lasers = []; missiles = [];
                createExplosion(player.x, player.y, '#0f8', 200);

                AudioSys.playSE('dragon_explode');
                distortGrid(player.x, player.y, 300, 500);
            }
        }

        function updatePlayerStatus() { if (player.invuln > 0) player.invuln--; }


        // =========================================================
        // 7. 敵機生成と共通AI (Enemy Spawning & Common AI)
        // =========================================================
        function spawnWormhole() {
            wormholes.push({
                x: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                y: WALL_MARGIN + 100 + Math.random() * (worldSize - WALL_MARGIN * 2 - 200),
                life: 400, maxLife: 400, active: true
            });
            distortGrid(wormholes[wormholes.length - 1].x, wormholes[wormholes.length - 1].y, 50, 150);
        }

        function spawnEnemy(x, y, type, size = 1) {
            const spd = SPEED_SCALE;
            const stageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.SPEED_INC;
            const hpMag = (stage - 1) * DIFFICULTY_CONFIG.HP_INC;

            const angle = Math.random() * Math.PI * 2;
            const bSpd = 5.0 * spd;
            const vx = Math.cos(angle) * bSpd;
            const vy = Math.sin(angle) * bSpd;

            // -----------------------------------------------------
            // ★修正：アイテムドロップ決定ロジック (整理版)
            // -----------------------------------------------------
            let dropType = 'crystal'; // デフォルト
            const rnd = Math.random();

            // 1. 【最優先】レベルアップアイテム (条件付き)
            if (levelItemsDroppedInStage < 2 && player.weaponLevel < MAX_WEAPON_LEVEL && rnd < DROP_RATES.LEVEL) {
                dropType = 'level';
                levelItemsDroppedInStage++; // ★出現したらカウントを増やす
            }
            // 2. その他のアイテム抽選 (レベルアップが出なかった場合)
            else {
                const subRnd = Math.random();
                // ピンチかどうかで回復率を変える
                const shieldChance = (player.shield < 30) ? DROP_RATES.SHIELD_LOW : DROP_RATES.SHIELD_NORM;

                // 確率の積み上げ判定
                if (subRnd < DROP_RATES.LASER) {
                    dropType = 'laser';
                }
                else if (subRnd < DROP_RATES.LASER + DROP_RATES.INVINCIBLE) {
                    dropType = 'invincible';
                }
                else if (subRnd < DROP_RATES.LASER + DROP_RATES.INVINCIBLE + shieldChance) {
                    dropType = 'shield';
                }
                // それ以外は 'crystal' のまま
            }

            if (type === 'dragon') {
                enemies.push({
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 8 + hpMag * 2,
                    speed: ENEMY_SPEEDS.DRAGON * spd * stageMag,
                    color: '#c00', type: 'dragon',
                    angle: Math.atan2(vy, vx), // 初速に合わせた角度を設定
                    segments: [],
                    drop: 'none',
                    scale: 0.9, fireTimer: 0
                });

                const segmentCount = 8;
                const initialAngle = Math.atan2(vy, vx);
                for (let i = 0; i < segmentCount; i++) {
                    // 全ての節に初期座標と進行方向の角度をセット
                    enemies[enemies.length - 1].segments.push({
                        x: x,
                        y: y,
                        angle: initialAngle
                    });
                }
                spawnedCount++;
            } else if (type === 'cube') {
                // アイテムキャリア（Cube）はドロップ確定
                enemies.push({
                    x, y, vx, vy,
                    hp: 2 + Math.floor(hpMag),
                    speed: ENEMY_SPEEDS.CUBE * spd * stageMag,
                    color: '#0f0', type: 'cube', angle: 0,
                    drop: dropType, // ここで決定したドロップを適用
                    scale: 0.8, rotX: 0, rotY: 0
                });
                spawnedCount++;
            } else if (type === 'tadpole') {
                enemies.push({
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 1,
                    speed: ENEMY_SPEEDS.TADPOLE * spd * stageMag,
                    color: '#0ff', type: 'tadpole', angle: 0,
                    drop: 'none',
                    scale: 0.6, history: []
                });
                spawnedCount++;
            } else if (type === 'triangle') {
                // フォーメーションパターンの定義
                const patterns = ['V', 'W', 'H'];
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                const initialAngle = Math.atan2(vy, vx);

                const formationTypes = ['blue', 'purple', 'yellow'];
                const currentFormationType = formationTypes[Math.floor(Math.random() * formationTypes.length)];

                const colorMap = {
                    blue: '#00f0ff',
                    purple: '#bf00ff',
                    yellow: '#ffdf00'
                };
                const selectedColor = colorMap[currentFormationType];

                // --- 1. リーダー（中心機）の生成 ---
                const leader = {
                    x: x, y: y, vx: vx, vy: vy,
                    hp: 1 + Math.floor(hpMag * 0.5),
                    speed: ENEMY_SPEEDS.TRIANGLE * spd * stageMag,
                    color: selectedColor,
                    type: 'triangle',
                    formationType: currentFormationType,
                    angle: initialAngle,
                    drop: dropType,
                    scale: 0.1,
                    isLeader: true,
                    followers: [],
                    isWarping: true,
                    warpPercent: 0,
                    rotX: Math.random() * Math.PI,
                    rotY: Math.random() * Math.PI,
                    rotZ: Math.random() * Math.PI
                };
                enemies.push(leader);
                spawnedCount++;

                // --- 2. 取り巻き（フォロワー）の生成 ---
                // リーダーを中心に左右2台ずつ、計4台を配置
                for (let i = 0; i < 4; i++) {
                    if (spawnedCount >= enemiesToSpawn) break;

                    let offX = 0, offY = 0;
                    const side = (i % 2 === 0) ? 1 : -1; // 左右交互 (1 or -1)
                    const step = Math.floor(i / 2) + 1; // 1段目 or 2段目

                    if (pattern === 'V') {
                        // V型: 後方に広がる (リーダーが先端)
                        offX = -step * 25;
                        offY = side * step * 25;
                    }
                    else if (pattern === 'W') {
                        // W型: リーダーを中心にジグザグ配置
                        offX = (step === 1) ? -25 : 0; // 1段目は後ろ、2段目は真横
                        offY = side * step * 25;
                    }
                    else if (pattern === 'H') {
                        // H型: 縦に並ぶ二列の中央にリーダー
                        offX = (step === 1) ? 25 : -25; // 前後に配置
                        offY = side * 25; // 左右幅は固定
                    }

                    enemies.push({
                        x: x, y: y, vx: vx, vy: vy,
                        hp: 1,
                        speed: ENEMY_SPEEDS.TRIANGLE * spd * stageMag,
                        color: selectedColor,
                        type: 'triangle',
                        formationType: currentFormationType,
                        angle: initialAngle,
                        drop: 'none',
                        scale: 0.1,
                        leader: leader,
                        formOffset: { x: offX, y: offY },
                        isWarping: true,
                        warpPercent: 0,
                        rotX: Math.random() * Math.PI,
                        rotY: Math.random() * Math.PI,
                        rotZ: Math.random() * Math.PI
                    });
                    leader.followers.push(enemies[enemies.length - 1]);
                    spawnedCount++;
                }
            } else if (type === 'boss') {
                const variantIndex = (stage - 1) % BOSS_VARIANTS.length;
                const variant = BOSS_VARIANTS[variantIndex];
                const bossHp = variant.hp + (stage - 1) * 10;

                const sX = Number(x);
                const sY = Number(y);

                enemies.push({
                    x: sX, y: sY,
                    spawnX: sX, spawnY: sY,
                    vx: 0, vy: 0,
                    hp: bossHp, maxHp: bossHp,
                    speed: 1.2 * variant.speedFactor * SPEED_SCALE * (1.0 + (stage - 1) * 0.08),
                    color: variant.color,
                    type: 'boss', variant: variant,
                    angle: 0,
                    drop: 'shield',
                    scale: 1.5 + (variant.sides * 0.1),
                    fireTimer: 0, flashTimer: 0,
                    spawnTimer: 0, spawnMax: 150,
                    isSpawning: true,
                    // ★追加：カメラ補間専用タイマー（isSpawningが消えても止まらない）
                    cameraLerpTimer: 0
                });
                spawnedCount++;
            } else if (type === 'asteroid') {
                // =========================================================
                // ★修正: アステロイドを通常仕様（速い・回転する）に戻す
                // =========================================================
                const sizeFactor = 1.0 + (stage - 1) * 0.1;
                const hp = (size === 1 ? 4 : size === 2 ? 2 : 1) + Math.floor((stage - 1) * 0.5);
                const baseScale = size === 1 ? 1.8 : size === 2 ? 1.1 : 0.6;
                const finalScale = baseScale * sizeFactor;

                // 通常の速度係数 (0.7) と回転速度 (0.1) に戻す
                const moveSpeed = (ENEMY_SPEEDS.ASTEROID * 0.7) * (1 + size * 0.4) * spd * stageMag;
                const ang = Math.random() * Math.PI * 2;

                enemies.push({
                    x, y,
                    vx: Math.cos(ang) * moveSpeed,
                    vy: Math.sin(ang) * moveSpeed,
                    hp: hp,
                    speed: moveSpeed,
                    color: '#fff',
                    type: 'asteroid',
                    size: size,
                    angle: Math.random() * Math.PI * 2,
                    rotSpd: (Math.random() - 0.5) * 0.1, // 速い回転
                    scale: finalScale,
                    drop: 'none',

                    // 追跡モード用パラメータ
                    spawnTimer: 0,
                    trackingStart: 300 + Math.random() * 200,
                    isTracking: false
                });

                // アステロイドは出現数には含めるが撃破ノルマには含めない（前回の仕様維持）
                // spawnedCount++; // ← 前回の修正で削除した場合はそのまま
            } else if (type === 'hunter') {
                enemies.push({
                    x: x, y: y, vx: vx * 0.5, vy: vy * 0.5,
                    hp: 3 + Math.floor(hpMag * 1.5),
                    speed: ENEMY_SPEEDS.HUNTER * spd * stageMag,
                    color: '#fa4',
                    type: 'hunter',
                    angle: 0,
                    drop: dropType,
                    scale: 1.2,
                    actionTimer: 0,
                    state: 'approach', // 初期状態を 'approach' (接近) に設定
                    burstCount: 0      // ★追加：連射数カウント用
                });
                spawnedCount++;
                // spawnEnemy関数内の最後の方に追加
            } else if (type === 'battleship') {
                enemies.push({
                    x: x, y: y,
                    spawnX: x, spawnY: y,
                    vx: 0, vy: 0,
                    hp: 3000, maxHp: 3000, // 通常ボスの10倍以上のHP
                    speed: 0.3 * SPEED_SCALE, // 超重厚な動き
                    color: '#ffffff',
                    type: 'battleship', // ★タイプ名
                    angle: 0,
                    drop: 'none',
                    scale: 1.0, // 描画時に1.5倍にするのでここは1.0でOK

                    fireTimer: 0,
                    flashTimer: 0,
                    spawnTimer: 0, spawnMax: 240,
                    isSpawning: true,

                    // 戦艦専用: 12門の砲台の状態などを持たせることも可能だが、今回はシンプルに
                    variant: { name: "X-BATTLESHIP", sides: 12 } // UI表示用
                });
                spawnedCount++;

                AudioSys.playSE('dragon_explode');
            } else if (type === 'phantom') {
                enemies.push({
                    x: x, y: y, vx: vx * 0.5, vy: vy * 0.5,
                    hp: 2 + Math.floor(hpMag),
                    speed: ENEMY_SPEEDS.PHANTOM * spd * stageMag,
                    color: '#b0f', // 紫系ネオン
                    type: 'phantom',
                    angle: 0,
                    drop: dropType,
                    scale: 1.0,
                    state: 'stealth', // 状態管理：stealth, appear, dash
                    timer: 0,
                    alpha: 0.1, // 初期はほぼ透明
                    trail: []
                });
                spawnedCount++;
            } else if (type === 'eclipse') {
                enemies.push({
                    x: x, y: y, vx: vx * 0.2, vy: vy * 0.2,
                    hp: 30 + hpMag * 5, // Dragonより高い耐久力
                    speed: ENEMY_SPEEDS.ECLIPSE * spd * stageMag,
                    color: '#f05', // ローズレッド
                    type: 'eclipse',
                    angle: 0,
                    rotSpeed: 0.02,
                    drop: 'level', // 倒すと確定でレベルアップドロップ
                    scale: 1.5,
                    actionTimer: 0
                });
                spawnedCount++;
            }

        }

        function updateEnemies() {
            enemies.forEach(e => {
                const isTriangle = (e.type === 'triangle');

                if (!isTriangle && e.leader && e.leader.hp > 0) {
                    updateFormationMovement(e);
                    if (e.type === 'cube') { e.rotX += 0.03; e.rotY += 0.04; }
                } else {
                    switch (e.type) {
                        case 'dragon': updateDragonAI(e); break;
                        case 'tadpole': updateTadpoleAI(e); break;
                        case 'triangle': updateTriangleAI(e); break;
                        case 'cube': updateCubeAI(e); break;
                        case 'asteroid': updateAsteroidAI(e); break;
                        case 'hunter': updateHunterAI(e); break;
                        case 'phantom': updatePhantomAI(e); break; // ★追加
                        case 'eclipse': updateEclipseAI(e); break; // ★追加

                        // 通常ボス
                        case 'boss':
                            if (stage === 9) updateBossSpecialAI(e);
                            else updateBossAI(e);
                            break;

                        // ★ラスボス (Battleship)
                        case 'battleship': updateBattleshipAI(e); break;
                    }
                }

                applySeparation(e);
                applyAsteroidCollisions(e);
                applyWorldBoundary(e);
                checkPlayerCollision(e);
                checkSatelliteCollision(e);

                // --- 撃破判定 ---
                if (e.hp <= 0) {
                    // ★追加: ラスボス撃破時の劇的演出
                    if (e.type === 'battleship') {
                        gameSpeed = 0.05; // 世界をスローモーションに
                        bullets = [];      // 画面の弾を消す
                        enemyBullets = [];
                        createExplosion(e.x, e.y, '#fff', 200); // 大爆発
                        if (typeof AudioSys !== 'undefined') AudioSys.playSE('dragon_explode');
                    }

                    // アステロイドの分裂処理
                    if (e.type === 'asteroid' && e.size < 3 && !e.noSplit) {
                        for (let i = 0; i < 2; i++) spawnEnemy(e.x, e.y, 'asteroid', e.size + 1);
                    }

                    destroyEnemy(e);
                }
            });
            enemies = enemies.filter(e => e.hp > 0);
        }

        function updateFormationMovement(e) {
            if (!e.leader || e.leader.hp <= 0) return;
            const la = e.leader.angle;
            const rotatedOffX = e.formOffset.x * Math.cos(la) - e.formOffset.y * Math.sin(la);
            const rotatedOffY = e.formOffset.x * Math.sin(la) + e.formOffset.y * Math.cos(la);
            const targetX = e.leader.x + rotatedOffX; const targetY = e.leader.y + rotatedOffY;
            e.x += (targetX - e.x) * 0.3 * gameSpeed;
            e.y += (targetY - e.y) * 0.3 * gameSpeed;
            e.vx = e.leader.vx; e.vy = e.leader.vy; e.angle = la;
        }

        function applySeparation(e) {
            enemies.forEach(other => {
                if (e === other) return;
                const odx = e.x - other.x, ody = e.y - other.y; const od = Math.hypot(odx, ody);
                if (od < 30) { const push = (30 - od) * 0.05; e.x += (odx / od) * push; e.y += (ody / od) * push; }
            });
        }

        function applyAsteroidCollisions(e) {
            if (e.type !== 'asteroid') return;

            enemies.forEach(other => {
                // 自分自身、または死んでいる敵、アステロイド以外の敵は無視
                if (e === other || other.hp <= 0 || other.type !== 'asteroid') return;

                const dx = other.x - e.x;
                const dy = other.y - e.y;
                const dist = Math.hypot(dx, dy) || 0.001;

                // --- 判定半径の動的な計算 ---
                // 基本半径20pxにそれぞれのscaleを掛け、さらに描画倍率G_SCALEを考慮
                const r1 = 20 * e.scale * G_SCALE;
                const r2 = 20 * other.scale * G_SCALE;
                const minDist = r1 + r2;

                if (dist < minDist) {
                    // --- 1. 重なり（めり込み）の解消 ---
                    const overlap = minDist - dist;
                    const nx = dx / dist; // 法線ベクトルx
                    const ny = dy / dist; // 法線ベクトルy

                    // サイズ（scale）を重みとして、小さい方がより大きく弾かれるように調整
                    // (質量 = scaleの2乗に比例すると仮定するとよりリアルですが、シンプルにscale比で計算)
                    const totalScale = e.scale + other.scale;
                    const ratioE = other.scale / totalScale;
                    const ratioOther = e.scale / totalScale;

                    e.x -= nx * overlap * ratioE;
                    e.y -= ny * overlap * ratioE;
                    other.x += nx * overlap * ratioOther;
                    other.y += ny * overlap * ratioOther;

                    // --- 2. 速度ベクトルの反射（弾性衝突） ---
                    // 相対速度
                    const rvx = other.vx - e.vx;
                    const rvy = other.vy - e.vy;

                    // 法線方向の速度成分（内積）
                    const velAlongNormal = rvx * nx + rvy * ny;

                    // 既に離れようとしている（ベクトルが外向き）場合は処理しない
                    if (velAlongNormal > 0) return;

                    // 反発係数 (0.6〜0.8くらいが岩らしくて自然です)
                    const restitution = 0.7;
                    const j = -(1 + restitution) * velAlongNormal;

                    // 質量比に基づいた速度変化（大きい岩ほど動きにくい）
                    e.vx -= j * nx * ratioE;
                    e.vy -= j * ny * ratioE;
                    other.vx += j * nx * ratioOther;
                    other.vy += j * ny * ratioOther;

                    // --- 3. 衝突時の火花演出 ---
                    // 激しくぶつかった時だけ火花を出す
                    if (Math.abs(velAlongNormal) > 1 && frame % 2 === 0) {
                        const midX = (e.x + other.x) / 2;
                        const midY = (e.y + other.y) / 2;
                        createExplosion(midX, midY, '#fff', 2);
                    }
                }
            });
        }

        function applyWorldBoundary(e) {
            if (e.x < WALL_MARGIN || e.x > worldSize - WALL_MARGIN) e.vx *= -1.2;
            if (e.y < WALL_MARGIN || e.y > worldSize - WALL_MARGIN) e.vy *= -1.2;
            e.x = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.x));
            e.y = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, e.y));
        }

        function checkPlayerCollision(e) {
            if (gameState === 'DYING' || gameState === 'GAMEOVER') return;

            const dist = Math.hypot(player.x - e.x, player.y - e.y);

            // --- 当たり判定半径の決定 ---
            let radius = 15 * G_SCALE;
            if (e.type === 'asteroid') {
                radius = 20 * e.scale * G_SCALE;
            } else if (e.type === 'triangle') {
                radius = ENEMY_HITBOX.TRIANGLE * G_SCALE;
            } else if (e.type === 'cube') {
                radius = ENEMY_HITBOX.CUBE * G_SCALE;
            } else if (e.type === 'tadpole') {
                radius = ENEMY_HITBOX.TADPOLE * G_SCALE;
            } else if (e.type === 'dragon') {
                radius = ENEMY_HITBOX.DRAGON * G_SCALE;
            } else if (e.type === 'hunter') {
                radius = ENEMY_HITBOX.HUNTER * G_SCALE;
            } else if (e.type === 'boss') {
                radius = 45 * G_SCALE; // 通常ボス
            } else if (e.type === 'battleship') {
                // ★追加: 巨大戦艦は判定を大きくする
                radius = 80 * G_SCALE;
            }

            // 衝突境界距離の計算
            const collisionDist = radius * (e.type === 'asteroid' ? 1 : (e.scale / 0.7)) + (player.invuln > 0 ? 20 : 0);

            if (dist < collisionDist) {
                // ★修正: 通常ボスまたは戦艦が出現中の場合は接触判定なし
                if ((e.type === 'boss' || e.type === 'battleship') && e.isSpawning) return;

                // checkPlayerCollision(e) 内の無敵処理部分
                if (player.invuln > 0) {
                    // ★修正: 戦艦も「即死しない」グループに追加
                    if (e.type === 'boss' || e.type === 'battleship' || e.type === 'dragon' || e.type === 'asteroid') {
                        // ボスや岩へのダメージ
                        e.hp -= 0.8;

                        // ヒットバック演出
                        if (e.type === 'boss' || e.type === 'battleship') e.flashTimer = 5;

                        if (frame % 2 === 0) {
                            createExplosion(e.x, e.y, '#ff0', 2);
                            if (typeof AudioSys !== 'undefined') AudioSys.playSE('boss_hit');
                        }
                    } else {
                        // 雑魚は即死
                        e.hp = 0;
                        score += 100;
                        createExplosion(e.x, e.y, e.color, 15);
                        if (typeof AudioSys !== 'undefined') AudioSys.playSE('explode');
                    }
                    return; // プレイヤーのダメージ処理をスキップ
                }

                // --- 通常時のダメージ処理 ---
                player.shield -= 0.5;
                if (player.invuln <= 0) {
                    player.shield -= 10;
                    player.invuln = 10;
                    createExplosion(player.x, player.y, '#f00', 5);
                    if (typeof AudioSys !== 'undefined') AudioSys.playSE('damage');
                }
                ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                if (player.shield <= 0) damage(0);
            }
        }

        function checkSatelliteCollision(e) {
            // 出現中のボスは当たり判定なし（すり抜ける）
            if (e.type === 'boss' && e.isSpawning) return;

            for (let i = player.satellites.length - 1; i >= 0; i--) {
                const s = player.satellites[i];

                // 当たり判定距離
                if (Math.hypot(s.x - e.x, s.y - e.y) < 25) {

                    // ★修正箇所：ボスや中ボス(Dragon)の場合は即死させず、ダメージを与える処理に変更
                    if (e.type === 'boss' || e.type === 'dragon') {
                        // 衛星特攻ダメージ（値はバランスに合わせて調整してください）
                        e.hp -= 20;

                        if (e.type === 'boss') e.flashTimer = 5; // 点滅演出
                        if (typeof AudioSys !== 'undefined') AudioSys.playSE('boss_hit'); // ヒット音

                        // ヒットエフェクト
                        if (typeof createExplosion === 'function') {
                            createExplosion(s.x, s.y, '#0f0', 5);
                        }
                    } else {
                        // 通常の雑魚敵は即死させる（既存の処理）
                        e.hp = 0;
                        e.noDrop = true;

                        if (typeof createExplosion === 'function') {
                            createExplosion(s.x, s.y, e.color, 10);
                        }
                    }

                    // 衛星（サテライト）を消滅させる
                    player.satellites.splice(i, 1);

                    // 1つの衛星は1回ヒットしたら消えるのでループを抜ける
                    break;
                }
            }
        }

        function destroyEnemy(e) {
            // --- ボス撃破時の処理 ---
            if (e.type === 'boss') {
                let shouldClearMinions = false;

                if (stage === 9) {
                    rushBossIndex++; // 現在のボス撃破数をカウントアップ
                    rushIntervalTimer = 0;

                    // Stage 9の場合：8体目のボス（Indexが8に到達した時）を倒した時だけ一掃
                    if (rushBossIndex >= 8) {
                        shouldClearMinions = true;
                    }
                } else {
                    // Stage 1-8の場合：ボスを倒せば常に一掃
                    shouldClearMinions = true;
                }

                // --- 雑魚一掃ロジックの実行 ---
                if (shouldClearMinions) {
                    enemies.forEach(other => {
                        if (other !== e && other.hp > 0) {
                            other.hp = 0;
                            other.noSplit = true; // ★アステロイドが分裂しないようにする
                            other.noDrop = true;  // 画面がアイテムで埋まるのを防ぐ
                        }
                    });
                    // 進行中のワームホールもすべて閉じる
                    wormholes.forEach(w => w.life = 0);

                    // 派手なグリッドの歪み
                    distortGrid(e.x, e.y, 200, 500);
                }

                // ボス撃破の報酬（シールド回復）を確定ドロップ
                powerups.push({ x: e.x, y: e.y, vx: 0, vy: 0, type: 'shield', life: 600 });
            }
            // --- ラスボス（Stage 10 / Battleship） ---
            else if (e.type === 'battleship') {
                // Battleship自体の撃破時は一掃ロジックを入れなくても
                // startStageのクリア判定で次の演出へ移行します
                gameSpeed = 0.05;
                bullets = [];
                enemyBullets = [];

                // ★追加：ラスボス撃破時も、アステロイドを含めた全ての敵を連鎖爆発させる
                enemies.forEach(other => {
                    if (other !== e && other.hp > 0) {
                        other.hp = 0;
                        other.noSplit = true; // ★アステロイド分裂防止
                        other.noDrop = true;  // アイテムドロップ防止
                    }
                });
                wormholes.forEach(w => w.life = 0);
            }
            // --- 通常の敵の撃破 ---
            else {
                if (e.type !== 'asteroid') enemiesKilled++;
            }

            // --- 爆発エフェクトの生成 ---
            const particleCount = (e.type === 'boss') ? 120 : (e.type === 'asteroid' ? 30 : 40);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 8 + 2) * EXPLOSION_SPEED_MAG;
                let color;
                if (e.type === 'asteroid') color = Math.random() < 0.85 ? '#ffffff' : '#ffaa00';
                else color = Math.random() < 0.85 ? e.color : '#ffff00';
                createExplosion(e.x, e.y, color, 1);
            }

            // --- 効果音と画面揺れ ---
            if (e.type === 'boss') {
                AudioSys.playSE('dragon_explode');
                distortGrid(e.x, e.y, 100, 200);
                // ミサイルも誘爆
                enemyBullets.forEach(b => {
                    if (b.isMissile) createExplosion(b.x, b.y, b.color, 5);
                });
                enemyBullets = enemyBullets.filter(b => !b.isMissile);
            } else if (e.type === 'dragon') {
                AudioSys.playSE('dragon_explode');
                distortGrid(e.x, e.y, 40, 80);
            } else {
                AudioSys.playSE('explode');
                distortGrid(e.x, e.y, 30, 60);
            }

            // スコア加算
            const pts = (e.type === 'dragon' || e.type === 'boss') ? 1000 : (e.type === 'asteroid' ? 150 : 100);
            score += pts;
            ui.score.innerText = score.toString().padStart(6, '0');
            scorePopups.push({ x: e.x, y: e.y, text: pts, life: 40, alpha: 1, vy: -1 });

            // ドロップ処理
            if (e.noDrop || e.drop === 'none') return;
            const itemProps = { x: e.x, y: e.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 };
            if (e.drop === 'level') powerups.push({ ...itemProps, type: 'level', life: 999999 });
            else if (e.drop === 'laser') powerups.push({ ...itemProps, type: 'laser', life: ITEM_LIFE });
            else if (e.drop === 'invincible') powerups.push({ ...itemProps, type: 'invincible', life: ITEM_LIFE });
            else if (e.drop === 'crystal') crystals.push({ ...itemProps, life: ITEM_LIFE });
            else if (e.drop === 'shield') powerups.push({ ...itemProps, type: 'shield', life: ITEM_LIFE });
        }


        // =========================================================
        // 8. 個別敵機AI (Specific Enemy AIs)
        // =========================================================
        function updateTriangleAI(e) {
            // --- 1. 出現・展開アニメーション (全員共通) ---
            if (e.isWarping) {
                e.warpPercent = (e.warpPercent || 0) + 0.015;
                if (e.warpPercent >= 1) {
                    e.warpPercent = 1;
                    e.isWarping = false;
                    e.scale = 0.7;
                } else {
                    e.scale = 0.1 + 0.6 * e.warpPercent;
                }
            }

            // --- 2. 座標と移動の計算 ---
            if (!e.isLeader && e.leader && e.leader.hp > 0) {
                // 【副機】
                // リーダーの角度がNaNなら0扱いにする（安全対策）
                const angle = Number.isFinite(e.leader.angle) ? e.leader.angle : 0;

                const targetRx = e.formOffset.x * Math.cos(angle) - e.formOffset.y * Math.sin(angle);
                const targetRy = e.formOffset.x * Math.sin(angle) + e.formOffset.y * Math.cos(angle);

                const ratio = e.isWarping ? e.warpPercent : 1.0;

                e.x = e.leader.x + targetRx * ratio;
                e.y = e.leader.y + targetRy * ratio;
                e.angle = angle;
                e.vx = e.leader.vx || 0;
                e.vy = e.leader.vy || 0;

            } else {
                // 【リーダー機】
                const dx = player.x - e.x;
                const dy = player.y - e.y;

                if (e.isWarping) {
                    // --- 出現中の挙動 ---

                    // 1. 移動にはブレーキをかけ、穴の中心付近に留める
                    e.vx *= 0.5;
                    e.vy *= 0.5;

                    // 2. ★追加：その場でプレイヤーの方へ旋回（ロックオン）する
                    const targetAngle = Math.atan2(dy, dx);

                    // 現在の角度との差分を計算してスムーズに回す
                    let diff = targetAngle - e.angle;
                    // -PI ~ PI の範囲に正規化（最短距離で回るため）
                    while (diff <= -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;

                    e.angle += diff * 0.1; // 0.1 は旋回速度（お好みで調整）

                } else {
                    // --- 通常時の挙動 ---
                    const d = Math.hypot(dx, dy) || 0.001;

                    // プレイヤーへ向かって加速
                    e.vx += (dx / d) * 0.2 * SPEED_SCALE * gameSpeed;
                    e.vy += (dy / d) * 0.2 * SPEED_SCALE * gameSpeed;

                    // 速度制限
                    const cv = Math.hypot(e.vx, e.vy);
                    if (cv > 0.0001 && cv > e.speed) {
                        e.vx = (e.vx / cv) * e.speed;
                        e.vy = (e.vy / cv) * e.speed;
                    }

                    // 通常時は「進行方向」を向く
                    e.angle = Math.atan2(e.vy, e.vx);
                }

                // 座標更新
                e.x += e.vx * gameSpeed;
                e.y += e.vy * gameSpeed;
            }

            // --- 3. 演出更新 ---
            e.rotX += 0.08;
            e.rotY += 0.12;
            e.rotZ += 0.05;
        }

        function updateTadpoleAI(e) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.001;

            // --- 1. 慣性と加速のロジック ---
            // ターゲットに向かってじわじわと加速を加える（ステアリング）
            const accel = 0.15 * SPEED_SCALE * gameSpeed;
            e.vx += (dx / d) * accel;
            e.vy += (dy / d) * accel;

            // 微弱な摩擦（これがないと加速し続けて制御不能になる）
            e.vx *= 0.985;
            e.vy *= 0.985;

            // --- 2. 速度制限 ---
            const currentV = Math.hypot(e.vx, e.vy);
            const maxSpd = e.speed; // 生成時に設定されたベーススピード
            if (currentV > maxSpd) {
                e.vx = (e.vx / currentV) * maxSpd;
                e.vy = (e.vy / currentV) * maxSpd;
            }

            // --- 3. 座標更新 ---
            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;

            // --- 4. 向きの決定（進行方向を向く） ---
            // 自機の方を向くのではなく、移動ベクトル(vx, vy)の方を向かせることで、
            // 「行き過ぎて戻る時」のドリフト感を表現します
            e.angle = Math.atan2(e.vy, e.vx);

            // --- 5. 軌跡の更新 ---
            e.history.unshift({ x: e.x, y: e.y });
            if (e.history.length > 60) e.history.pop();
        }

        function updateDragonAI(e) {
            // NaN防止のための初期ガード
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.001;
            const spd = SPEED_SCALE;

            // 1. 頭部の移動
            e.vx += (dx / d) * DRAGON_ACCELERATION * spd;
            e.vy += (dy / d) * DRAGON_ACCELERATION * spd;
            e.vx *= 0.98; e.vy *= 0.98;

            const stageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.SPEED_INC;
            const lim = ENEMY_SPEEDS.DRAGON * spd * stageMag;

            const currentV = Math.hypot(e.vx, e.vy) || 0.001;
            if (currentV > lim) {
                e.vx = (e.vx / currentV) * lim;
                e.vy = (e.vy / currentV) * lim;
            }

            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;
            e.angle = Math.atan2(e.vy, e.vx);

            // 2. ★体節の滑らかな連結追従ロジック（NaNガード強化版）
            let leaderX = e.x;
            let leaderY = e.y;
            const spacing = 18;

            e.segments.forEach((s, i) => {
                const sDx = leaderX - s.x;
                const sDy = leaderY - s.y;
                const distance = Math.hypot(sDx, sDy) || 0.001; // 0除算防止
                const targetAngle = Math.atan2(sDy, sDx);

                s.angle = targetAngle;

                if (distance > spacing) {
                    const moveDist = distance - spacing;
                    // 算出した座標が正常な数値(Finite)である場合のみ更新
                    const tx = s.x + Math.cos(targetAngle) * moveDist;
                    const ty = s.y + Math.sin(targetAngle) * moveDist;

                    if (Number.isFinite(tx) && Number.isFinite(ty)) {
                        s.x = tx;
                        s.y = ty;
                    }
                }

                leaderX = s.x;
                leaderY = s.y;
            });

            // 3. 弾速の変更（エラー修正：変数 a を e.angle に修正）
            e.fireTimer++;
            if (e.fireTimer > 100) {
                e.fireTimer = 0;

                const currentEnemyBulletSpd = BULLET_CONFIG.ENEMY_NORMAL.SPEED * SPEED_SCALE * (1 + (stage - 1) * DIFFICULTY_CONFIG.BULLET_SPEED_INC);

                // ★修正箇所: Math.cos(a) の 'a' が未定義だったので 'e.angle' に変更
                const shootAngle = e.angle;

                enemyBullets.push({
                    x: e.x,
                    y: e.y,
                    vx: Math.cos(shootAngle) * currentEnemyBulletSpd,
                    vy: Math.sin(shootAngle) * currentEnemyBulletSpd,
                    life: BULLET_CONFIG.ENEMY_NORMAL.LIFE,
                    color: '#c00' // ドラゴンの弾色を指定
                });
                AudioSys.playSE('shoot');
            }
        }

        function updateCubeAI(e) {
            const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy) || 0.001;
            e.vx += (dx / d) * 0.2 * SPEED_SCALE * gameSpeed;
            e.vy += (dy / d) * 0.2 * SPEED_SCALE * gameSpeed;
            const cv = Math.hypot(e.vx, e.vy); if (cv > e.speed) { e.vx = (e.vx / cv) * e.speed; e.vy = (e.vy / cv) * e.speed; }
            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;
            e.rotX += 0.03;
            e.rotY += 0.04;
        }

        function updateHunterAI(e) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy) || 0.001;

            // 定数から基本スピードを取得（SPEED_SCALEは既に掛かっている前提か、ここで掛けるか）
            // 今回は e.speed (生成時に計算済み) をベースにします
            const baseSpd = e.speed;

            e.actionTimer++;

            // --- 状態1: 高速接近 (APPROACH) ---
            if (e.state === 'approach') {
                // 定数 HUNTER_ROT があれば使用、なければ直書き
                e.angle += ENEMY_SPEEDS.HUNTER_ROT;

                // プレイヤーに向かって加速
                // 加速度も baseSpd に比例させることで、ステージが進んで速くなっても挙動が安定します
                const acc = baseSpd * 0.1;
                e.vx += (dx / dist) * acc;
                e.vy += (dy / dist) * acc;

                if (dist < 180) {
                    e.state = 'attack';
                    e.actionTimer = 0;
                    e.burstCount = 0;
                }
            }
            // --- 状態2: 攻撃 (ATTACK) ---
            else if (e.state === 'attack') {
                e.vx *= 0.85;
                e.vy *= 0.85;

                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - e.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                e.angle += diff * 0.2;

                if (e.actionTimer > 20 && e.actionTimer % 10 === 0 && e.burstCount < 3) {
                    // 弾速も定数の影響を受ける
                    const bulletSpd = BULLET_CONFIG.ENEMY_NORMAL.SPEED * 1.3 * SPEED_SCALE;

                    enemyBullets.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(e.angle) * bulletSpd,
                        vy: Math.sin(e.angle) * bulletSpd,
                        life: BULLET_CONFIG.ENEMY_NORMAL.LIFE,
                        color: '#f80'
                    });

                    // 反動
                    e.vx -= Math.cos(e.angle) * (baseSpd * 0.5);
                    e.vy -= Math.sin(e.angle) * (baseSpd * 0.5);

                    AudioSys.playSE('shoot');
                    e.burstCount++;
                }

                if (e.burstCount >= 3 && e.actionTimer > 60) {
                    e.state = 'retreat';
                    e.actionTimer = 0;
                }
            }
            // --- 状態3: 離脱 (RETREAT) ---
            else if (e.state === 'retreat') {
                e.angle -= 0.2;

                const escapeAcc = baseSpd * 0.08;
                e.vx -= (dx / dist) * escapeAcc;
                e.vy -= (dy / dist) * escapeAcc;

                if (dist > 450 || e.actionTimer > 120) {
                    e.state = 'approach';
                    e.actionTimer = 0;
                }
            }

            // --- 速度制限（ここが定数活用のキモ） ---
            const currentSpeed = Math.hypot(e.vx, e.vy);
            // 状態に合わせて制限速度を可変にする（接近時は基本の1.5倍まで許容）
            let maxLimit = baseSpd;
            if (e.state === 'approach') maxLimit = baseSpd * 1.5;
            if (e.state === 'retreat') maxLimit = baseSpd * 1.2;

            if (currentSpeed > maxLimit) {
                e.vx = (e.vx / currentSpeed) * maxLimit;
                e.vy = (e.vy / currentSpeed) * maxLimit;
            }

            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;
        }

        function updateAsteroidAI(e) {
            // 時間経過のカウント
            e.spawnTimer = (e.spawnTimer || 0) + 1;

            // --- 覚醒判定（通常仕様に戻す） ---
            // "stage !== 9" の制限を削除。時間が来れば追尾モードへ移行。
            if (!e.isTracking && e.spawnTimer > e.trackingStart) {
                e.isTracking = true;
                // モード切替時の速度変換と減速
                e.vx = (e.vx * e.speed) * 0.2;
                e.vy = (e.vy * e.speed) * 0.2;
                e.speed = 1;
                // 回転を速くする
                e.rotSpd *= 3;
            }

            if (e.isTracking) {
                // --- 追跡モード ---
                // 色の変化（赤みがかかる）
                const gb = Math.floor(215 + 40 * Math.sin(frame * 0.1));
                e.color = `rgb(255, ${gb}, ${gb})`;

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.hypot(dx, dy) || 0.001;
                const accel = (0.6 / e.size) * SPEED_SCALE;

                e.vx += (dx / dist) * accel * gameSpeed;
                e.vy += (dy / dist) * accel * gameSpeed;

                const maxSpeed = 7.0 * SPEED_SCALE;
                e.vx *= 0.99; e.vy *= 0.99;
                const currentSpeed = Math.hypot(e.vx, e.vy);
                if (currentSpeed > maxSpeed) {
                    e.vx = (e.vx / currentSpeed) * maxSpeed;
                    e.vy = (e.vy / currentSpeed) * maxSpeed;
                }
                e.x += e.vx * gameSpeed;
                e.y += e.vy * gameSpeed;

            } else {
                // --- 通常モード（漂流） ---
                e.color = '#ffffff';

                e.x += e.vx * e.speed * gameSpeed;
                e.y += e.vy * e.speed * gameSpeed;

                if (e.x < 0 || e.x > worldSize) e.vx *= -1;
                if (e.y < 0 || e.y > worldSize) e.vy *= -1;
            }

            // 自転
            e.angle += e.rotSpd;
        }

        function updatePhantomAI(e) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy) || 1;

            if (e.state === 'stealth') {
                // ステルス状態：ゆっくり近づく
                e.vx += (dx / dist) * 0.05 * gameSpeed;
                e.vy += (dy / dist) * 0.05 * gameSpeed;
                e.vx *= 0.95; e.vy *= 0.95;
                e.angle = Math.atan2(e.vy, e.vx);

                // 透明度を低く保つ
                e.alpha += (0.15 - e.alpha) * 0.1;

                // 距離が近づいたら姿を現す
                if (dist < 280) {
                    e.state = 'appear';
                    e.timer = 0;
                }
            } else if (e.state === 'appear') {
                // 実体化状態：足を止めて自機をロックオン
                e.vx *= 0.8; e.vy *= 0.8;
                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - e.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                e.angle += diff * 0.2;

                // 姿を現す（明滅）
                e.timer += gameSpeed;
                e.alpha = 0.5 + Math.sin(e.timer * 0.5) * 0.5;

                // 一定時間後に突進開始
                if (e.timer > 30) {
                    e.state = 'dash';
                    e.timer = 0;
                    const dashSpd = 18 * SPEED_SCALE;
                    e.vx = Math.cos(e.angle) * dashSpd;
                    e.vy = Math.sin(e.angle) * dashSpd;
                    e.alpha = 1.0;
                    if (typeof AudioSys !== 'undefined') AudioSys.playSE('shoot');
                }
            } else if (e.state === 'dash') {
                // 突進状態：直進のみ
                e.timer += gameSpeed;
                e.trail.unshift({ x: e.x, y: e.y });
                if (e.trail.length > 8) e.trail.pop();

                // 一定時間経過か、画面端到達で再びステルスへ
                if (e.timer > 50 || e.x <= WALL_MARGIN || e.x >= worldSize - WALL_MARGIN || e.y <= WALL_MARGIN || e.y >= worldSize - WALL_MARGIN) {
                    e.state = 'stealth';
                    e.trail = [];
                }
            }

            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;
        }

        function updateEclipseAI(e) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy) || 1;

            // 常にゆっくり近づき、逃げ場を塞ぐ
            e.vx += (dx / dist) * 0.02 * SPEED_SCALE * gameSpeed;
            e.vy += (dy / dist) * 0.02 * SPEED_SCALE * gameSpeed;

            const spdLimit = e.speed;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > spdLimit) {
                e.vx = (e.vx / cv) * spdLimit;
                e.vy = (e.vy / cv) * spdLimit;
            }

            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;

            // 歯車の回転
            e.angle += e.rotSpeed * gameSpeed;

            // 行動パターンのサイクル
            e.actionTimer += gameSpeed;
            const cycle = Math.floor(e.actionTimer) % 350;

            if (cycle === 120) {
                // 攻撃1：全方位ばらまき弾
                const ways = 16;
                const bSpd = 5 * SPEED_SCALE;
                for (let i = 0; i < ways; i++) {
                    const a = (Math.PI * 2 / ways) * i + e.angle;
                    enemyBullets.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(a) * bSpd, vy: Math.sin(a) * bSpd,
                        life: 300, color: e.color
                    });
                }
                if (typeof AudioSys !== 'undefined') AudioSys.playSE('shoot');
                distortGrid(e.x, e.y, 80, 150);
            } else if (cycle > 250 && cycle < 310) {
                // 攻撃2：自機狙いの3連高速バースト
                if (cycle % 20 === 0) {
                    const a = Math.atan2(dy, dx);
                    const bSpd = 14 * SPEED_SCALE;
                    enemyBullets.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(a) * bSpd, vy: Math.sin(a) * bSpd,
                        life: 300, color: '#fff' // 高速弾は白
                    });
                    if (typeof AudioSys !== 'undefined') AudioSys.playSE('launch');
                }
            }
        }

        function updateBossAI(e) {
            // --- 1. 出現演出中の処理 ---
            if (e.isSpawning) {
                e.spawnTimer++;
                if (e.spawnTimer >= e.spawnMax) {
                    e.isSpawning = false;
                } else {
                    e.x = e.spawnX;
                    e.y = e.spawnY;
                    e.vx = 0;
                    e.vy = 0;
                    return;
                }
            }

            // --- 2. 移動ロジック ---
            if (!Number.isFinite(e.x)) e.x = e.spawnX || worldSize / 2;
            if (!Number.isFinite(e.y)) e.y = e.spawnY || worldSize / 2;

            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.1;

            e.vx += (dx / d) * 0.02 * SPEED_SCALE * gameSpeed;
            e.vy += (dy / d) * 0.02 * SPEED_SCALE * gameSpeed;

            const cv = Math.hypot(e.vx, e.vy);
            if (cv > e.speed) {
                e.vx = (e.vx / cv) * e.speed;
                e.vy = (e.vy / cv) * e.speed;
            }

            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;

            const margin = 100;
            e.x = Math.max(margin, Math.min(worldSize - margin, e.x));
            e.y = Math.max(margin, Math.min(worldSize - margin, e.y));

            // --- 3. 高速回転・レーザーミサイルバラ撒き・射撃ロジック ---
            e.fireTimer++;

            const maxCycle = 280;
            const brakeStart = 160;
            const fireTime = 220;
            const restartTime = 250;

            let rotationSpeed = 0.12;

            if (e.fireTimer < brakeStart) {
                // 【通常回転フェーズ】
                // ★弱体化：発射密度をさらに下げ「20フレームごと」に（以前は12）
                if (e.fireTimer % 20 === 0) {
                    const sides = e.variant.sides;
                    // ★弱体化：弾速を 14 → 9 に低下させ、回避に猶予を持たせる
                    const bulletSpd = 9 * SPEED_SCALE;

                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 45,
                            y: e.y + Math.sin(a) * 45,
                            vx: Math.cos(a) * (BULLET_CONFIG.BOSS_LASER.SPEED * SPEED_SCALE),
                            vy: Math.sin(a) * (BULLET_CONFIG.BOSS_LASER.SPEED * SPEED_SCALE),
                            life: BULLET_CONFIG.BOSS_LASER.LIFE,
                            isLaserMissile: true,
                            color: e.color
                        });
                    }
                    if (e.fireTimer % 20 === 0) AudioSys.playSE('shoot');
                }
            }
            else if (e.fireTimer >= brakeStart && e.fireTimer < fireTime) {
                // 【減速フェーズ】
                const ratio = 1.0 - (e.fireTimer - brakeStart) / (fireTime - brakeStart);
                rotationSpeed = Math.pow(ratio, 1.5) * 0.12;

                if (frame % 3 === 0) {
                    const ang = Math.random() * Math.PI * 2;
                    particles.push({
                        x: e.x + Math.cos(ang) * 80, y: e.y + Math.sin(ang) * 80,
                        vx: -Math.cos(ang) * 4, vy: -Math.sin(ang) * 4,
                        color: '#fff', life: 0.2, size: 1.5
                    });
                }
            }
            else if (e.fireTimer >= fireTime && e.fireTimer < restartTime) {
                // 【発射＆硬直フェーズ】
                rotationSpeed = 0;

                if (e.fireTimer === fireTime) {
                    const sides = e.variant.sides;
                    const bulletSpd = ENEMY_SPEEDS.BOSS_MISSILE * SPEED_SCALE;

                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 60,
                            y: e.y + Math.sin(a) * 60,
                            vx: Math.cos(a) * (BULLET_CONFIG.BOSS_HOMING.SPEED * SPEED_SCALE),
                            vy: Math.sin(a) * (BULLET_CONFIG.BOSS_HOMING.SPEED * SPEED_SCALE),
                            life: BULLET_CONFIG.BOSS_HOMING.LIFE,
                            isMissile: true,
                            color: e.color,
                            trail: []
                        });
                    }
                    AudioSys.playSE('launch');
                    rings.push({ x: e.x, y: e.y, r: 20, color: '#fff', life: 1.0 });
                    rings.push({ x: e.x, y: e.y, r: 100, color: e.color, life: 0.8 });
                    distortGrid(e.x, e.y, 100, 200);
                }
            }
            else if (e.fireTimer >= restartTime) {
                // 【再始動フェーズ】
                const ratio = (e.fireTimer - restartTime) / (maxCycle - restartTime);
                rotationSpeed = Math.pow(ratio, 2) * 0.12;
            }

            e.angle += rotationSpeed;
            if (e.fireTimer >= maxCycle) e.fireTimer = 0;
        }

        // --- updateBossSpecialAI 関数本体 ---
        function updateBossSpecialAI(e) {
            // --- 共通: 出現演出 ---
            if (e.isSpawning) {
                e.spawnTimer++;
                if (e.spawnTimer >= e.spawnMax) e.isSpawning = false;
                else {
                    e.x = e.spawnX; e.y = e.spawnY; e.vx = 0; e.vy = 0;
                    return;
                }
            }

            // --- 共通: 移動ロジック ---
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const distToPlayer = Math.hypot(dx, dy) || 1;

            // 通常より少し積極的に動く
            e.vx += (dx / distToPlayer) * 0.03 * SPEED_SCALE * gameSpeed;
            e.vy += (dy / distToPlayer) * 0.03 * SPEED_SCALE * gameSpeed;

            e.vx *= 0.96; e.vy *= 0.96;
            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;

            const margin = 150;
            e.x = Math.max(margin, Math.min(worldSize - margin, e.x));
            e.y = Math.max(margin, Math.min(worldSize - margin, e.y));

            // --- 共通: カウンター攻撃判定（マイルド版） ---
            if (e.prevHp && e.hp < e.prevHp) {
                // 確率を15%に落とし、単発の自機狙いにする
                if (Math.random() < 0.15) {
                    const angle = Math.atan2(player.y - e.y, player.x - e.x);
                    const spd = 10 * SPEED_SCALE;
                    enemyBullets.push({
                        x: e.x, y: e.y,
                        vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
                        life: 180, color: '#fff'
                    });
                    // 反撃のサインとして小さな火花
                    createExplosion(e.x, e.y, '#fff', 3);
                    AudioSys.playSE('shoot');
                }
            }
            e.prevHp = e.hp;

            // --- フェーズ管理 ---
            e.fireTimer++;
            const cycle = 750;
            const phaseTime = e.fireTimer % cycle;

            if (phaseTime < 250) {
                // Phase 1: 拡散 (16F間隔のリズム)
                e.angle += 0.15;
                if (frame % 16 === 0) {
                    const sides = e.variant.sides;
                    // 定数による弾速調整
                    const bulletSpd = BULLET_CONFIG.BOSS_LASER.SPEED * SPEED_SCALE * BOSS_RUSH_BULLET_CONFIG.PHASE1_LASER_SPD;
                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 45, y: e.y + Math.sin(a) * 45,
                            vx: Math.cos(a) * bulletSpd, vy: Math.sin(a) * bulletSpd,
                            life: BULLET_CONFIG.BOSS_LASER.LIFE, isLaserMissile: true, color: e.color
                        });
                    }
                    AudioSys.playSE('shoot');
                }
            } else if (phaseTime < 450) {
                // Phase 2: 狙撃 (警告あり)
                const targetAngle = Math.atan2(player.y - e.y, player.x - e.x);
                let diff = targetAngle - e.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                e.angle += diff * 0.1;

                const sub = (phaseTime - 250) % 60;
                if (sub < 20) e.isWarningSnipe = true;
                else if (sub === 21) {
                    e.isWarningSnipe = false;
                    const lead = 15;
                    const predX = player.x + player.vx * lead;
                    const predY = player.y + player.vy * lead;
                    const aim = Math.atan2(predY - e.y, predX - e.x);
                    // 定数による弾速調整
                    const spd = BOSS_RUSH_BULLET_CONFIG.PHASE2_SNIPE_SPD * SPEED_SCALE;
                    for (let i = 0; i < 3; i++) {
                        enemyBullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(aim) * spd * (1 - i * 0.1),
                            vy: Math.sin(aim) * spd * (1 - i * 0.1),
                            life: 200, color: '#f00'
                        });
                    }
                    AudioSys.playSE('launch');
                    createExplosion(e.x, e.y, '#f00', 5);
                }
            } else {
                // Phase 3: 誘導
                e.angle += 0.03;
                const sub = phaseTime - 450;
                if (sub === 10 || sub === 120) {
                    const sides = Math.min(e.variant.sides, 6);
                    // 定数による弾速調整
                    const speed = BULLET_CONFIG.BOSS_HOMING.SPEED * SPEED_SCALE * BOSS_RUSH_BULLET_CONFIG.PHASE3_MISSILE_SPD;
                    for (let i = 0; i < sides; i++) {
                        const a = e.angle + (Math.PI * 2 / sides) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 60, y: e.y + Math.sin(a) * 60,
                            vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
                            life: 300, isMissile: true, color: e.color,
                            trail: []
                        });
                    }
                    AudioSys.playSE('launch');
                    distortGrid(e.x, e.y, 100, 200);
                }
            }
        }

        // ★新規作成: ラスボス(戦艦)のAI
        function updateBattleshipAI(e) {
            // 1. 出現演出
            if (e.isSpawning) {
                e.spawnTimer++;
                if (e.spawnTimer >= e.spawnMax) {
                    e.isSpawning = false;
                    ui.bossContainer.style.display = 'block';
                    ui.bossNameLabel.innerText = "GENESIS-ARK";
                    ui.bossNameLabel.style.color = "#0ff";
                    ui.bossHpBarInline.style.backgroundColor = "#0ff";
                    ui.bossBarFrame.style.borderColor = "#0ff";
                }
                return;
            }

            // --- 全体のサイクル管理（23秒周期に変更して「間」を作る） ---
            e.fireTimer++;
            const cycle = e.fireTimer % 1380; // 1200 から 1380 に延長
            const sides = e.variant.sides || 12;

            // 攻撃パターン4（突進）の間だけ判定するフラグ
            const isRushing = (cycle >= 900 && cycle < 1200);

            // 2. 基本移動（プレイヤーへの追尾）
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const d = Math.hypot(dx, dy) || 0.1;

            const moveSpeed = isRushing ? e.speed * 2.5 : e.speed;
            const accel = isRushing ? 0.05 : 0.01;

            e.vx += (dx / d) * accel * SPEED_SCALE;
            e.vy += (dy / d) * accel * SPEED_SCALE;
            const cv = Math.hypot(e.vx, e.vy);
            if (cv > moveSpeed) {
                e.vx = (e.vx / cv) * moveSpeed;
                e.vy = (e.vy / cv) * moveSpeed;
            }
            e.x += e.vx * gameSpeed;
            e.y += e.vy * gameSpeed;

            // 3. 旋回ロジック
            if (isRushing) {
                e.angle += 0.15 * gameSpeed; // パターン4: 高速回転
            } else {
                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - e.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                e.angle += diff * 0.01 * gameSpeed;
            }

            // 4. 攻撃パターン
            // --- パターン1: 収束・拡散レーザー (0-5秒) ---
            if (cycle < 300) {
                // 各砲台から同時に放射状に3発発射
                if (cycle % 60 === 0) {
                    const spawnRadius = 100;
                    for (let j = 0; j < sides; j++) {
                        const baseAngle = e.angle + (Math.PI * 2 / sides) * j;
                        const spawnX = e.x + Math.cos(baseAngle) * spawnRadius;
                        const spawnY = e.y + Math.sin(baseAngle) * spawnRadius;

                        for (let i = -1; i <= 1; i++) {
                            const a = baseAngle + (i * 0.2);
                            enemyBullets.push({
                                x: spawnX, y: spawnY,
                                vx: Math.cos(a) * 12 * SPEED_SCALE,
                                vy: Math.sin(a) * 12 * SPEED_SCALE,
                                life: 200, color: '#0ff', isLaserMissile: true
                            });
                        }
                    }
                    AudioSys.playSE('shoot');
                }
            }

            // --- パターン2: グラビティ・ハッチ (5-10秒) ---
            else if (cycle < 600) {
                if (cycle % 10 === 0) distortGrid(e.x, e.y, 250, -15);

                if (cycle % 15 === 0) {
                    const a = e.angle + (cycle * 0.1);
                    const hatchRadius = 90;
                    const spawnX = e.x + Math.cos(a) * hatchRadius;
                    const spawnY = e.y + Math.sin(a) * hatchRadius;

                    enemyBullets.push({
                        x: spawnX, y: spawnY,
                        vx: Math.cos(a) * 3 * SPEED_SCALE,
                        vy: Math.sin(a) * 3 * SPEED_SCALE,
                        life: 400, isMissile: true, isFighter: true, color: '#0ff'
                    });
                    AudioSys.playSE('launch');
                }
            }

            // --- パターン3: 放射状ホーミングミサイル6連射 (10-15秒) ---
            else if (cycle < 900) {
                const subCycle = cycle % 100;
                // 10F間隔で6回（計60F）撃つ設定
                if (subCycle < 60 && subCycle % 20 === 0) {
                    const ways = 6; // 12方向に一斉発射
                    const offsetAngle = e.angle + (subCycle * 0.03);

                    for (let i = 0; i < ways; i++) {
                        const a = offsetAngle + (Math.PI * 2 / ways) * i;
                        enemyBullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(a) * 5 * SPEED_SCALE,
                            vy: Math.sin(a) * 5 * SPEED_SCALE,
                            life: 800,
                            color: '#00ffff', // ラスボスらしいマゼンタ
                            isMissile: true,
                            // ★重要：ミサイルごとに軌跡を保存する配列を追加
                            trail: []
                        });
                    }
                    AudioSys.playSE('launch');
                }
            }

            // --- パターン4: アーク・ディビジョン・突進 (15-20秒) ---
            else if (cycle < 1200) {
                if (cycle % 10 === 0) {
                    for (let i = 0; i < 8; i++) {
                        const a = e.angle + (Math.PI * 2 / 8) * i;
                        enemyBullets.push({
                            x: e.x + Math.cos(a) * 80, y: e.y + Math.sin(a) * 80,
                            vx: Math.cos(a) * 4, vy: Math.sin(a) * 4,
                            life: 200, color: '#0ff', isLaserMissile: true
                        });
                    }
                }
                if (Math.random() < 0.3) createExplosion(e.x + (Math.random() - 0.5) * 150, e.y + (Math.random() - 0.5) * 150, '#0ff', 5);
            }

            // --- パターン5: クールダウン・排熱 (20-23秒) ---
            else {
                // 攻撃は一切行わず、プレイヤーにゆっくりと向き直る隙の大きな時間
                // 機体から冷却用の蒸気（白い煙）を吹き出させる演出
                if (frame % 5 === 0) {
                    particles.push({
                        x: e.x + (Math.random() - 0.5) * 150,
                        y: e.y + (Math.random() - 0.5) * 150,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: 'rgba(255, 255, 255, 0.5)', // 白煙
                        life: 1.0,
                        size: 4 + Math.random() * 3
                    });
                }
            }
        }

        // =========================================================
        // 9. エンティティ更新 (Entity Updates)
        // =========================================================
        function updateEntities() {
            updatePlayerBullets();
            updateLasers();
            updateEnemies();
            updateEnemyBullets();
            updateCrystals();
            updatePowerups();
            updateMissiles();
            updateParticlesAndRings();
            updatePlayerStatus();
        }

        function updatePlayerBullets() {
            bullets.forEach(b => {
                b.x += b.vx * gameSpeed;
                b.y += b.vy * gameSpeed;
                b.life--;

                // --- ワールド境界との衝突判定 ---
                if (b.x < WALL_MARGIN || b.x > worldSize - WALL_MARGIN ||
                    b.y < WALL_MARGIN || b.y > worldSize - WALL_MARGIN) {

                    const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, b.x));
                    const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, b.y));

                    createWallImpact(impactX, impactY, '#0f8');
                    b.life = 0;
                }

                // --- 敵との当たり判定 ---
                enemies.forEach(e => {
                    // 弾が既に消えている、または敵が死んでいる場合はスキップ
                    if (b.life <= 0 || e.hp <= 0) return;

                    // --- 出現演出中のボスはショットをすり抜ける ---
                    if (e.type === 'boss' && e.isSpawning) return;

                    // 敵の種類ごとの判定半径
                    let hitRadius = 30 * e.scale;
                    if (e.type === 'asteroid') hitRadius = 25 * e.scale;
                    else if (e.type === 'dragon') hitRadius = ENEMY_HITBOX.DRAGON;
                    else if (e.type === 'triangle') hitRadius = ENEMY_HITBOX.TRIANGLE;
                    else if (e.type === 'cube') hitRadius = ENEMY_HITBOX.CUBE;
                    else if (e.type === 'tadpole') hitRadius = ENEMY_HITBOX.TADPOLE;
                    else if (e.type === 'hunter') hitRadius = ENEMY_HITBOX.HUNTER;
                    else if (e.type === 'boss') hitRadius = 45;

                    // 距離チェック
                    if (Math.hypot(b.x - e.x, b.y - e.y) < hitRadius) {

                        b.life = 0; // 弾を消す
                        e.hp--;     // ダメージを与える

                        // --- ★修正ポイント：ヒット演出 ---

                        // 1. ボスの場合
                        if (e.type === 'boss') {
                            e.flashTimer = 5;
                            AudioSys.playSE('boss_hit');
                            for (let i = 0; i < 3; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    // ★修正: 飛び散る速度に SPEED_SCALE を適用 (10 * 2.0 程度にして勢いを出す)
                                    vx: (Math.random() - 0.5) * 20 * SPEED_SCALE,
                                    vy: (Math.random() - 0.5) * 20 * SPEED_SCALE,
                                    color: '#fff',
                                    life: 0.2,
                                    // ★修正: サイズに G_SCALE を適用
                                    size: 2 * G_SCALE
                                });
                            }
                        }
                        // 2. ボス以外の敵（ここが重要）
                        else {
                            // HPがまだ残っているなら火花を出す
                            if (e.hp > 0) {
                                const sparkColor = e.color || '#fff';
                                for (let i = 0; i < 4; i++) {
                                    particles.push({
                                        x: b.x,
                                        y: b.y,
                                        // 弾が当たって砕けるイメージで拡散
                                        vx: (Math.random() - 0.5) * 8, // ★速度を少し上げて散らばりやすく
                                        vy: (Math.random() - 0.5) * 8,
                                        color: sparkColor,

                                        // ★ここを修正：0.2だと薄すぎるので、0.8～1.2程度にする
                                        life: 0.8 + Math.random() * 0.4,

                                        size: 2.0 // ★少し大きくして視認性アップ
                                    });
                                }
                            }
                        }
                    }
                });
            });
            bullets = bullets.filter(b => b.life > 0);
        }

        function updateLasers() {
            lasers.forEach(l => {
                l.life--;
                const maxLen = 2000;
                let currentLen = maxLen; // デフォルトの長さ

                const cos = Math.cos(l.angle);
                const sin = Math.sin(l.angle);

                // --- ★追加：壁との交差判定（壁で止める処理） ---
                const min = WALL_MARGIN;
                const max = worldSize - WALL_MARGIN;

                // 1. X方向の壁（左右）までの距離を計算
                // cosがプラスなら右壁(max)、マイナスなら左壁(min)を見る
                let distX = Infinity;
                if (cos !== 0) {
                    distX = (cos > 0 ? max - l.x : min - l.x) / cos;
                }

                // 2. Y方向の壁（上下）までの距離を計算
                // sinがプラスなら下壁(max)、マイナスなら上壁(min)を見る
                let distY = Infinity;
                if (sin !== 0) {
                    distY = (sin > 0 ? max - l.y : min - l.y) / sin;
                }

                // 3. 近い方の壁までの距離を採用
                const distToWall = Math.min(distX, distY);

                // 4. 壁が射程より近ければ、そこでレーザーを止める
                if (distToWall < currentLen) {
                    currentLen = distToWall;

                    // 壁に当たった地点でエフェクト発生
                    const hitX = l.x + cos * currentLen;
                    const hitY = l.y + sin * currentLen;
                    createWallImpact(hitX, hitY, '#0ff'); // シアン色の火花
                }
                // ------------------------------------------

                const p1x = l.x;
                const p1y = l.y;

                // 5. 敵との衝突判定（壁より手前に敵がいればさらに短くなる）
                enemies.forEach(e => {
                    const dx = e.x - p1x;
                    const dy = e.y - p1y;
                    const distToEnemy = Math.hypot(dx, dy);

                    // 敵の方向とレーザーの方向が一致しているか
                    const angleToEnemy = Math.atan2(dy, dx);
                    let diff = Math.abs(l.angle - angleToEnemy);
                    if (diff > Math.PI) diff = Math.PI * 2 - diff;

                    // 角度が近く、かつ現在の長さ（壁までの距離含む）より近い場合
                    // ★ 修正ポイント：diff（角度の許容差）を広げる
                    // 0.35 程度にすると、中心軸から少し離れた敵にも当たります
                    if (diff < 0.35 && distToEnemy < currentLen) { // ★修正: maxLenではなくcurrentLenと比較
                        const hitRadius = (e.type === 'boss' ? 45 : 15) * e.scale;

                        // BOSSの場合はレーザーを遮断（長さを更新）
                        if (e.type === 'boss') {
                            currentLen = Math.min(currentLen, distToEnemy);
                            e.flashTimer = 5;
                        }

                        // ダメージ処理
                        e.hp -= 0.5;
                        if (frame % 2 === 0) {
                            createExplosion(e.x, e.y, e.color, 2);
                            // ヒット地点のエフェクト
                            const hitX = p1x + Math.cos(l.angle) * distToEnemy;
                            const hitY = p1y + Math.sin(l.angle) * distToEnemy;
                            particles.push({
                                x: hitX, y: hitY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                color: '#fff', life: 0.2, size: 2
                            });
                        }
                    }
                });

                // 6. 最終的な描画長さを保存
                l.renderLen = currentLen;

                // 7. 敵弾の消去判定（既存のまま）
                enemyBullets.forEach(eb => {
                    const A = p1x - (p1x + cos * currentLen);
                    const B = p1y - (p1y + sin * currentLen);
                    const C = (p1x + cos * currentLen) * p1y - p1x * (p1y + sin * currentLen);
                    const dist = Math.abs(A * eb.y - B * eb.x + C) / (Math.hypot(A, B) || 1);
                    const dot = (eb.x - p1x) * cos + (eb.y - p1y) * sin;
                    // ★ 修正ポイント：判定半径の計算に下駄を履かせる
                    // (l.width / 2 + 5) の「+ 5」を「+ 15」や「+ 20」に増やします
                    if (dist < ((l.width / 2 + 15) * G_SCALE) && dot > 0 && dot < currentLen) {
                        eb.life = 0;
                        score += 10;
                    }
                });
            });
            lasers = lasers.filter(l => l.life > 0);
        }

        function updateEnemyBullets() {
            const bulletStageMag = 1.0 + (stage - 1) * DIFFICULTY_CONFIG.BULLET_SPEED_INC;

            enemyBullets.forEach(eb => {
                // --- A. フェードアウト中の処理 ---
                if (eb.isFading) {
                    eb.baseAlpha = (eb.baseAlpha === undefined ? 1.0 : eb.baseAlpha) - 0.03;
                    const wave = (Math.sin(frame * 1.0) + 1) / 2;
                    eb.alpha = eb.baseAlpha * wave;
                    if (eb.baseAlpha <= 0) { eb.life = 0; return; }
                    eb.x += eb.vx * gameSpeed;
                    eb.y += eb.vy * gameSpeed;
                    return;
                }

                eb.x += eb.vx * gameSpeed;
                eb.y += eb.vy * gameSpeed;
                eb.life--;

                // --- B. ワールド境界との衝突判定 ---
                const isHitWall = (eb.x < WALL_MARGIN || eb.x > worldSize - WALL_MARGIN || eb.y < WALL_MARGIN || eb.y > worldSize - WALL_MARGIN);
                if (isHitWall) {
                    if (eb.isMissile || eb.isLaserMissile) {
                        const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, eb.x));
                        const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, eb.y));
                        createExplosion(impactX, impactY, eb.color, 10);
                        AudioSys.playSE('explode');
                        distortGrid(impactX, impactY, 15, 30);
                    }
                    eb.life = 0;
                    return;
                }

                // --- C. 寿命切れ ---
                if (eb.life <= 0) {
                    if (eb.isMissile || eb.isLaserMissile) {
                        eb.isFading = true; eb.fadeTimer = 15; eb.life = 1;
                        AudioSys.playSE('explode', 0.5);
                    } else {
                        eb.life = 0;
                    }
                    return;
                }

                // =========================================================
                // ★追加: アステロイドによる弾の吸収（盾機能）
                // =========================================================
                if (eb.life > 0) {
                    // 全ての敵（アステロイド含む）に対して判定
                    for (const rock of enemies) {
                        // アステロイド以外は弾をスルーする（味方撃ち防止）
                        if (rock.type !== 'asteroid' || rock.hp <= 0) continue;

                        // 判定距離（岩の見た目より少し大きめに吸わせると守られている感が出る）
                        const rockRadius = 25 * rock.scale * G_SCALE;

                        if (Math.hypot(rock.x - eb.x, rock.y - eb.y) < rockRadius) {
                            // 弾を消滅させる
                            eb.life = 0;

                            // 演出: カンッ！という火花
                            createExplosion(eb.x, eb.y, '#fff', 3);

                            // ★重要: 岩にダメージを与えるか？
                            // ここでは「岩は敵弾に対しては無敵（または非常に硬い）」とします。
                            // そうしないと盾があっという間に壊れて戦略が崩壊するため。
                            // どうしても壊したい場合は rock.hp -= 0.1; などを追加してください。

                            // ループを抜ける（1つの弾が複数の岩に当たるのを防ぐ）
                            break;
                        }
                    }
                    // 弾が消滅していたら、これ以降のプレイヤー判定などはスキップ
                    if (eb.life === 0) return;
                }
                // =========================================================


                // --- D. ミサイルの誘導 ---
                if (eb.isMissile && eb.life > 0) {

                    // ★追加：追尾用タイマーの初期化（例: 120フレーム ＝ 約2秒間だけ追尾する）
                    if (eb.homingTimer === undefined) {
                        eb.homingTimer = 240;
                    }

                    // 軌跡（トレイル）の記録
                    if (eb.trail) {
                        eb.trail.unshift({ x: eb.x, y: eb.y });
                        if (eb.trail.length > 10) eb.trail.pop();
                    }

                    // ★タイマーが残っている間だけ誘導（旋回）を行う
                    if (eb.homingTimer > 0) {
                        eb.homingTimer--; // タイマーを減らす

                        // 慣性（旋回を滑らかにするため）
                        eb.vx *= 0.99; eb.vy *= 0.99;

                        const dx = player.x - eb.x, dy = player.y - eb.y;
                        const d = Math.hypot(dx, dy) || 0.001;

                        // プレイヤーへ向けて加速
                        const accel = 0.4 * SPEED_SCALE;
                        eb.vx += (dx / d) * accel * gameSpeed;
                        eb.vy += (dy / d) * accel * gameSpeed;
                    }
                    // タイマーが0になった後は、加速や旋回を行わず、現在の vx, vy のまま直進します

                    const v = Math.hypot(eb.vx, eb.vy);

                    // 巡航速度の設定。BULLET_CONFIGから正しく取得される
                    const cruiseSpeed = BULLET_CONFIG.BOSS_HOMING.SPEED * SPEED_SCALE * bulletStageMag;

                    if (v > cruiseSpeed) {
                        eb.vx = (eb.vx / v) * cruiseSpeed;
                        eb.vy = (eb.vy / v) * cruiseSpeed;
                    }

                    // プレイヤーのショットで撃墜できる判定
                    bullets.forEach(b => {
                        const hitDist = 20 * G_SCALE;
                        if (b.life > 0 && Math.hypot(b.x - eb.x, b.y - eb.y) < hitDist) {
                            createExplosion(eb.x, eb.y, eb.color, 8);
                            AudioSys.playSE('explode');
                            eb.life = 0; b.life = 0; score += 50;
                        }
                    });
                }

                // --- E. プレイヤーとの判定 ---
                if (eb.life > 0 && gameState !== 'DYING' && player.invuln <= 0) {
                    const dist = Math.hypot(player.x - eb.x, player.y - eb.y);
                    const collisionRadius = (eb.isMissile ? 12 : 8) * G_SCALE;
                    if (dist < collisionRadius) {
                        eb.life = 0;
                        createExplosion(player.x, player.y, eb.color || '#f00', 10);
                        damage(15);
                    }
                }
            });
            enemyBullets = enemyBullets.filter(eb => eb.life > 0);
        }

        function updateMissiles() {
            // missiles配列がない場合は何もしない
            if (typeof missiles === 'undefined') return;

            missiles.forEach(m => {
                // --- 1. ターゲット探索 ---
                if (!m.target || !enemies.includes(m.target)) {
                    let min = 9999;
                    enemies.forEach(e => {
                        if (e.hp > 0) { // 生きている敵だけ対象
                            const d = Math.hypot(e.x - m.x, e.y - m.y);
                            if (d < min) { min = d; m.target = e; }
                        }
                    });
                }

                // --- 2. 誘導（ホーミング） ---
                const scale = (typeof SPEED_SCALE !== 'undefined') ? SPEED_SCALE : 0.25;

                if (m.target) {
                    const ta = Math.atan2(m.target.y - m.y, m.target.x - m.x);
                    // 旋回力にも SCALE を適用
                    m.vx += Math.cos(ta) * 0.5 * scale;
                    m.vy += Math.sin(ta) * 0.5 * scale;
                }

                // --- 3. 速度制限と更新 ---
                const s = Math.hypot(m.vx, m.vy);
                if (s > 0.001) {
                    // m.speed は生成時に scale 済みなのでそのまま使う
                    m.vx = (m.vx / s) * m.speed;
                    m.vy = (m.vy / s) * m.speed;
                }

                // 移動
                m.x += m.vx * gameSpeed;
                m.y += m.vy * gameSpeed;
                m.life--;

                // --- 4. 壁衝突判定 ---
                if (m.x < WALL_MARGIN || m.x > worldSize - WALL_MARGIN ||
                    m.y < WALL_MARGIN || m.y > worldSize - WALL_MARGIN) {

                    // 壁に当たったら爆発
                    if (typeof createExplosion === 'function') {
                        const impactX = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, m.x));
                        const impactY = Math.max(WALL_MARGIN, Math.min(worldSize - WALL_MARGIN, m.y));
                        createExplosion(impactX, impactY, '#fd0', 10);
                    }
                    if (AudioSys) AudioSys.playSE('explode');
                    m.life = 0;
                    return;
                }

                // --- 5. 敵との衝突判定 ---
                enemies.forEach(e => {
                    if (e.hp <= 0) return;
                    const hitRadius = (e.type === 'asteroid' ? 25 * e.scale : 30);

                    if (Math.hypot(e.x - m.x, e.y - m.y) < hitRadius) {
                        e.hp -= 15;
                        m.life = 0;
                        if (typeof createExplosion === 'function') createExplosion(m.x, m.y, '#fd0', 8);
                        if (AudioSys) AudioSys.playSE('explode');
                        if (typeof distortGrid === 'function') distortGrid(m.x, m.y, 20, 50);
                    }
                });

                // --- 6. 軌跡パーティクル ---
                if (frame % 2 === 0 && typeof particles !== 'undefined') {
                    particles.push({
                        x: m.x, y: m.y,
                        vx: (Math.random() - 0.5) * scale,
                        vy: (Math.random() - 0.5) * scale,
                        color: '#fd0', life: 0.3, size: 2 * G_SCALE
                    });
                }
            });

            // 寿命切れを削除
            missiles = missiles.filter(m => m.life > 0);
        }

        function updateCrystals() {
            crystals.forEach(c => {
                c.life -= gameSpeed;

                // --- 1. 初速（飛び散り）の適用 ---
                // destroyEnemyで設定された vx, vy があれば使用します
                // 0.95 を掛けることで、飛び散った勢いが徐々に弱まる（摩擦）表現になります
                c.vx = (c.vx || 0) * 0.95;
                c.vy = (c.vy || 0) * 0.95;

                // 初速にも SPEED_SCALE を適用して移動させる
                c.x += c.vx * SPEED_SCALE * gameSpeed;
                c.y += c.vy * SPEED_SCALE * gameSpeed;

                // --- 2. 自機への吸い寄せ（マグネット） ---
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const dist = Math.hypot(dx, dy) || 0.0001;

                // 吸い寄せスピード計算に SPEED_SCALE を適用
                // ベース速度(10.0) + 距離による加速(0.08)
                // これにより、遠くにあるときは高速で、近くでも適度な速さで吸い寄せられます
                const pullSpeed = (10.0 + (dist * 0.08)) * SPEED_SCALE;

                const moveAmount = Math.min(dist, pullSpeed);

                c.x += (dx / dist) * moveAmount;
                c.y += (dy / dist) * moveAmount;

                // --- 3. 回収判定 ---
                if (dist < 30) { // 判定距離（少し広めに30px）
                    c.life = 0;

                    // 衛星（サテライト）追加ロジック
                    if (player.satellites.length < 12) {
                        // 初期座標と角度を持たせて push
                        player.satellites.push({
                            x: player.x,
                            y: player.y,
                            angle: Math.random() * Math.PI * 2
                        });
                    }
                }
            });

            // 寿命切れを削除
            crystals = crystals.filter(c => c.life > 0);
        }

        function updatePowerups() {
            powerups.forEach(p => {
                // --- 1. 消失防止と寿命の更新 ---
                // レベルアップアイテム以外は寿命を減らす
                if (p.type !== 'level') {
                    p.life -= gameSpeed;
                }

                // 自機との距離と方向ベクトルを計算
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.hypot(dx, dy) || 0.001;

                // --- 2. レベルアップアイテム専用：吸い寄せロジック ---
                if (p.type === 'level') {
                    // 遠くても確実に自機へ向かう（距離に応じた加速）
                    const pullSpeed = (2.0 + (dist * 0.04)) * SPEED_SCALE;
                    const moveAmount = Math.min(dist, pullSpeed) * gameSpeed;

                    p.x += (dx / dist) * moveAmount;
                    p.y += (dy / dist) * moveAmount;

                    // 飛んでいる間、キラキラしたパーティクルを出す演出
                    if (frame % 3 === 0) {
                        particles.push({
                            x: p.x, y: p.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#0f8', life: 0.3, size: 1.5
                        });
                    }
                }

                // --- 3. 回収判定 ---
                if (dist < 30) {
                    p.life = 0;
                    AudioSys.playSE('powerup');

                    if (p.type === 'laser') {
                        player.laserTimer = LASER_DURATION;
                        rings.push({ x: player.x, y: player.y, r: 10, color: '#0ff', life: 1 });
                        rings.push({ x: player.x, y: player.y, r: 50, color: '#0ff', life: 1 });
                    }
                    else if (p.type === 'invincible') {
                        player.invuln = INVULN_DURATION;
                        AudioSys.playSE('invincible');

                        // 取得時の演出：白い大きなリングを表示
                        rings.push({ x: player.x, y: player.y, r: 10, color: '#fff', life: 1.0 });
                        // グリッドを大きく歪ませる
                        distortGrid(player.x, player.y, 150, 300);
                    }
                    else if (p.type === 'level') {
                        player.weaponLevel = Math.min(MAX_WEAPON_LEVEL, player.weaponLevel + 1);
                        // スコアポップアップと同じ仕組みで「LEVEL UP!」と表示
                        scorePopups.push({
                            x: player.x,
                            y: player.y - 20,
                            text: "LEVEL UP!",
                            life: 60, alpha: 1, vy: -1.2
                        });
                    }
                    else if (p.type === 'shield') {
                        // 最大値(PLAYER_BASE_SHIELD)を超えないように回復
                        player.shield = Math.min(PLAYER_BASE_SHIELD, player.shield + 10);

                        // バーの表示更新
                        ui.shieldBar.style.width = Math.max(0, player.shield) + "%";
                        if (player.shield < 30) ui.shieldBar.classList.add('shield-critical');
                        else ui.shieldBar.classList.remove('shield-critical');
                        if (ui.shieldVal) ui.shieldVal.innerText = Math.floor(player.shield);

                        // ポップアップ表示
                        scorePopups.push({
                            x: player.x,
                            y: player.y - 20,
                            text: "SHIELD +10",
                            life: 60, alpha: 1, vy: -1.2
                        });
                    }
                }
            });
            // 取得済み(life=0)または時間切れのものを削除
            powerups = powerups.filter(p => p.life > 0);
        }

        function updateScorePopups() { scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; }); scorePopups = scorePopups.filter(s => s.life > 0); }

        function updateParticlesAndRings() {
            particles.forEach(p => {
                p.x += p.vx * gameSpeed;
                p.y += p.vy * gameSpeed;
                p.vx *= Math.pow(0.92, gameSpeed);
                p.vy *= Math.pow(0.92, gameSpeed);
                p.vy += 0.005 * gameSpeed;
                p.life -= 0.02 * gameSpeed;
            });
            particles = particles.filter(p => p.life > 0);
            rings.forEach(r => {
                r.r += 8 * SPEED_SCALE * gameSpeed;
                r.life -= 0.08 * SPEED_SCALE * gameSpeed;
            });
            rings = rings.filter(r => r.life > 0);
        }

        function updateGrid() {
            // スケールを考慮して、現在の表示範囲に必要なインデックス範囲を計算
            const viewW = width / cameraScale;
            const viewH = height / cameraScale;

            // バッファを少し多め（10 -> 15）に設定
            const buffer = 15;
            const startX = Math.max(0, Math.floor(camera.x / GRID_SPACING) - buffer);
            const endX = Math.min(gridPoints.length - 1, Math.ceil((camera.x + viewW) / GRID_SPACING) + buffer);
            const startY = Math.max(0, Math.floor(camera.y / GRID_SPACING) - buffer);
            const endY = Math.min(gridPoints[0].length - 1, Math.ceil((camera.y + viewH) / GRID_SPACING) + buffer);

            for (let i = startX; i <= endX; i++) {
                for (let j = startY; j <= endY; j++) {
                    const p = gridPoints[i][j];
                    if (!p) continue;

                    const dx = p.x - p.ox, dy = p.y - p.oy;
                    const dist = Math.hypot(dx, dy);

                    if (dist > 0.1) {
                        const f = -0.12 * dist;
                        const ang = Math.atan2(dy, dx);
                        p.vx += Math.cos(ang) * f * gameSpeed;
                        p.vy += Math.sin(ang) * f * gameSpeed;
                    }

                    p.vx *= 0.85;
                    p.vy *= 0.85;

                    if (Math.abs(p.vx) < 0.01 && Math.abs(p.vy) < 0.01 && dist < 0.1) {
                        p.x = p.ox; p.y = p.oy;
                        p.vx = 0; p.vy = 0;
                    } else {
                        p.x += p.vx * gameSpeed;
                        p.y += p.vy * gameSpeed;
                    }
                }
            }
        }

        function distortGrid(x, y, force, radius) {
            const cx = Math.floor(x / GRID_SPACING), cy = Math.floor(y / GRID_SPACING), r = Math.ceil(radius / GRID_SPACING);
            for (let i = Math.max(0, cx - r); i < Math.min(gridPoints.length, cx + r); i++) for (let j = Math.max(0, cy - r); j < Math.min(gridPoints[0].length, cy + r); j++) {
                const p = gridPoints[i][j], d = Math.hypot(p.x - x, p.y - y);
                if (d < radius) { const f = force * (1 - d / radius), a = Math.atan2(p.y - y, p.x - x); p.vx += Math.cos(a) * f; p.vy += Math.sin(a) * f; }
            }
        }


        // =========================================================
        // 10. 描画システム (Rendering Systems)
        // =========================================================

        function draw() {
            ctx.save();
            ctx.scale(cameraScale, cameraScale);
            ctx.translate(-camera.x, -camera.y);

            drawBackground();          // 1. 背景
            drawWorldBounds();         // 2. 枠
            drawWormholes();           // 3. 穴
            drawEnemies();             // 4. 敵
            drawEnemyProjectiles();    // 5. 敵弾（透明度適用済み）

            if (gameState === 'PLAYING') {
                drawPlayerSystems();   // 6. 自機
            }

            drawLasers();              // 7. 自機レーザー
            drawPlayerBullets();       // 8. 自機ショット
            drawItems();               // 9. アイテム
            drawVisualEffects();       // 10. エフェクト


            // UI要素（ワールド座標系でないものも含むが、ここでは便宜上呼び出し）
            if (gameState === 'PLAYING' || gameState === 'DYING') {
                drawMiniMap();
            }
            drawScorePopups();

            ctx.restore();

            // 4. 死亡・エンディング・名前入力時のフェード演出
            if (gameState === 'DYING' || gameState === 'ENDING' || gameState === 'GAMEOVER_UI') {
                // カメラの影響を受けないように座標系をリセット
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                let fade = 1.0;
                if (gameState === 'DYING') {
                    // 死亡時は徐々に暗くする
                    fade = Math.max(0, (60 - dyingTimer) / 60);
                } else {
                    // ENDING や GAMEOVER_UI の時は「強制的に真っ黒(1.0)」にする
                    fade = 1.0;
                }

                ctx.fillStyle = `rgba(0, 0, 0, ${fade})`;
                // 画面全体を塗りつぶす
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // 画面固定のUI演出
            drawBossWarningEffect();
        }

        // --- 以下、各描画サブ関数 ---

        function isOnScreen(obj, margin = 50) {
            // 現在のカメラの表示範囲（スケール考慮）
            const viewW = width / cameraScale;
            const viewH = height / cameraScale;

            return (
                obj.x > camera.x - margin &&
                obj.x < camera.x + viewW + margin &&
                obj.y > camera.y - margin &&
                obj.y < camera.y + viewH + margin
            );
        }

        function drawBackground() {
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const sx = (s.x - camera.x * s.parallax) % worldSize;
                const sy = (s.y - camera.y * s.parallax) % worldSize;
                const dx = (sx + worldSize) % worldSize;
                const dy = (sy + worldSize) % worldSize;
                ctx.globalAlpha = s.brightness;
                ctx.beginPath(); ctx.arc(dx, dy, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // --- グリッド描画 (軽量化版) ---
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, worldSize, worldSize);
            ctx.clip();

            // shadowBlurを廃止し、加算合成(lighter)でネオン感を出す
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = 'rgba(0, 150, 255, 0.4)'; // 少し濃いめに
            ctx.lineWidth = 1.5; // 少し太めに

            ctx.beginPath();
            const viewW = width / cameraScale;
            const viewH = height / cameraScale;

            for (let i = 0; i < gridPoints.length; i++) {
                for (let j = 0; j < gridPoints[i].length; j++) {
                    const p = gridPoints[i][j];
                    if (!p || p.x < camera.x - 50 || p.x > camera.x + viewW + 50 || p.y < camera.y - 50 || p.y > camera.y + viewH + 50) continue;
                    if (i > 0 && gridPoints[i - 1][j]) { ctx.moveTo(gridPoints[i - 1][j].x, gridPoints[i - 1][j].y); ctx.lineTo(p.x, p.y); }
                    if (j > 0 && gridPoints[i][j - 1]) { ctx.moveTo(gridPoints[i][j - 1].x, gridPoints[i][j - 1].y); ctx.lineTo(p.x, p.y); }
                }
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawWorldBounds() {
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 3;
            ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, worldSize - WALL_MARGIN * 2, worldSize - WALL_MARGIN * 2);
        }

        function drawWormholes() {
            wormholes.forEach(w => {
                if (w.active || w.life > -60) {
                    let scale = 1;
                    if (w.life > 300) scale = (400 - w.life) / 100;
                    else if (w.life <= 0) scale = Math.max(0, (60 + w.life) / 60);
                    ctx.save();
                    ctx.translate(w.x, w.y);
                    ctx.scale(scale, scale);
                    ctx.shadowBlur = 30; ctx.shadowColor = '#20f';
                    const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.2, '#000'); grad.addColorStop(0.8, '#000'); grad.addColorStop(1, '#0ff');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(0, 0, 20 + Math.sin(frame * 0.1) * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0, 0, 35 + Math.cos(frame * 0.05) * 5, 0, Math.PI * 2); ctx.stroke();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(5, 5); ctx.stroke();
                    ctx.restore();
                }
            });
        }

        // --- drawEnemiesの修正 ---
        function drawEnemies() {
            enemies.forEach(e => {
                const margin = (e.type === 'boss' || e.type === 'dragon' || e.type === 'battleship') ? 350 : 100;
                if (!isOnScreen(e, margin)) return;

                ctx.save();
                ctx.globalAlpha = e.isWarping ? (e.warpPercent || 0) : 1.0;

                if (e.type === 'dragon') drawDragonEnemy(ctx, e);
                else if (e.type === 'triangle') drawTriangleEnemy(ctx, e);
                else if (e.type === 'cube') drawCubeEnemy(ctx, e);
                else if (e.type === 'tadpole') drawTadpoleEnemy(ctx, e);
                else if (e.type === 'asteroid') drawAsteroidEnemy(ctx, e);
                else if (e.type === 'hunter') drawHunterEnemy(ctx, e);
                else if (e.type === 'phantom') drawPhantomEnemy(ctx, e); 
                else if (e.type === 'eclipse') drawEclipseEnemy(ctx, e);

                else if (e.type === 'boss') drawBossEnemy(ctx, e); 
                else if (e.type === 'battleship') drawBattleshipBoss(ctx, e);

                ctx.restore();
            });
        }

        // --- drawEnemyProjectilesの修正 ---
        function drawEnemyProjectiles() {
            ctx.globalCompositeOperation = 'lighter';
            enemyBullets.forEach(eb => {
                if (!isOnScreen(eb, 50)) return;
                ctx.save();
                ctx.translate(eb.x, eb.y);
                const currentAlpha = eb.isFading ? Math.max(0, eb.alpha) : 1.0;
                ctx.globalAlpha = currentAlpha;

                if (eb.isLaserMissile) {
                    drawLaserMissile(ctx, eb);
                } else if (eb.isFighter) { // ★戦闘機フラグがある場合
                    drawFighterJet(ctx, eb);
                } else if (eb.isMissile) { // 通常ボスのホーミングミサイル
                    drawHomingMissile(ctx, eb);
                } else {
                    drawNormalBullet(ctx, eb);
                }
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawPlayerSystems() {
            if (gameState === 'DYING') return;

            const vx = player.vx;
            const vy = player.vy;
            const currentMoveMag = Math.hypot(vx, vy);

            let thrustFactor = 0;
            if (currentMoveMag > 0.1) {
                const dirX = Math.cos(player.angle);
                const dirY = Math.sin(player.angle);
                const moveX = vx / currentMoveMag;
                const moveY = vy / currentMoveMag;

                const dot = dirX * moveX + dirY * moveY;
                thrustFactor = Math.max(0.2, dot);
            }

            const speedFactor = Math.min(1.0, currentMoveMag / (PLAYER_BASE_SPEED * SPEED_SCALE * 0.8));
            const finalThrustScale = speedFactor * thrustFactor;

            if (finalThrustScale > 0.05) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                let pColor = player.invuln > 0 ? '255, 230, 0' : (player.laserTimer > 0 ? '0, 255, 255' : '0, 255, 180');

                const offsetStart = 8 * G_SCALE;

                // ★粒の最大数を 20 → 30 に増やして長さを確保 (1.5倍)
                const particleCount = Math.floor(30 * finalThrustScale);

                for (let i = 0; i < particleCount; i++) {
                    const ratio = (1 - i / particleCount);

                    // ★粒の間隔係数を 4 → 6 に広げ、最大リーチを伸ばす
                    const dist = offsetStart + (i * 6 * G_SCALE * finalThrustScale);

                    const alpha = Math.pow(ratio, 1.2) * 0.35;
                    // 後方に向けて徐々に細くなる計算
                    const finalSize = (7 - i * 0.2) * G_SCALE;

                    if (finalSize < 0.5) continue;

                    ctx.save();
                    const offsetX = -Math.cos(player.angle) * dist;
                    const offsetY = -Math.sin(player.angle) * dist;

                    ctx.translate(player.x + offsetX, player.y + offsetY);
                    ctx.rotate(player.angle);

                    ctx.beginPath();
                    ctx.ellipse(0, 0, finalSize, finalSize * 0.5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${pColor}, ${alpha})`;
                    ctx.fill();

                    // 芯の光（より長い噴射に合わせて、光る範囲を少し広げました）
                    if (i < 12 && Math.random() > 0.3) {
                        ctx.beginPath();
                        ctx.arc(0, 0, finalSize * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                        ctx.fill();
                    }
                    ctx.restore();
                }
                ctx.restore();
            }

            // 残像
            player.history.forEach((pos, i) => {
                if (i === 0) return;
                ctx.save();
                ctx.translate(pos.x, pos.y); ctx.rotate(pos.angle); ctx.scale(G_SCALE, G_SCALE);
                ctx.globalAlpha = 0.4 * (1 - i / player.history.length);
                let trailColor = player.invuln > 0 ? '#ff0' : (player.laserTimer > 0 ? '#0ff' : '#0f8');
                ctx.strokeStyle = trailColor; ctx.lineWidth = 1.5; ctx.shadowBlur = 5; ctx.shadowColor = trailColor;
                ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath(); ctx.stroke();
                ctx.restore();
            });

            if (player.weaponLevel >= MAX_WEAPON_LEVEL - 1) drawEmeraldPhoenix(ctx, player);
            if (player.invuln > 0) drawInvulnBarrier(ctx, player);
            drawPlayer(ctx, player);
        }

        function drawPlayerBullets() {
            ctx.fillStyle = '#0f8';
            ctx.beginPath(); // ループの前にパスを開始

            bullets.forEach(b => {
                if (!isOnScreen(b, 50)) return;

                // 各弾丸の円形パスを繋げていく
                ctx.moveTo(b.x + 2, b.y);
                ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
            });

            ctx.fill(); // 最後に一括で塗りつぶす
        }

        function drawItems() {
            // クリスタル
            ctx.fillStyle = '#008000';
            crystals.forEach(c => {
                if (!isOnScreen(c, 50)) return;
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(frame * 0.1);
                const scale = c.life > 60 ? 1 : c.life / 60; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill();
                ctx.restore();
            });

            // パワーアップ
            powerups.forEach(p => {
                if (!isOnScreen(p, 50)) return;

                let char = '?';
                let color = '#fff';
                if (p.type === 'laser') { color = '#aff'; char = 'L'; }
                else if (p.type === 'level') { color = '#0f0'; char = 'W'; }
                else if (p.type === 'invincible') { color = '#ff0'; char = 'I'; }
                else if (p.type === 'shield') { color = '#0ff'; char = 'S'; }

                ctx.save();
                ctx.translate(p.x, p.y);
                const scale = p.life > 60 ? 1 : p.life / 60; ctx.scale(scale, scale);
                ctx.lineWidth = 2; ctx.strokeRect(-8, -8, 16, 16);
                ctx.fillStyle = color; ctx.font = 'bold 12px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(char, 0, 0);
                ctx.restore();
            });
        }

        function drawVisualEffects() {
            // 特殊ミサイル（プレイヤー側など）
            ctx.fillStyle = '#fd0';
            missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4 * G_SCALE, 0, Math.PI * 2); ctx.fill(); });

            // パーティクル
            particles.forEach(p => {
                if (!isOnScreen(p, 30)) return;
                ctx.save();
                ctx.globalAlpha = Math.min(1, p.life);
                ctx.beginPath(); const length = 4.0; ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * length, p.y - p.vy * length);
                ctx.lineWidth = p.size || 2; ctx.strokeStyle = p.color; ctx.lineCap = 'round'; ctx.stroke();
                ctx.restore();
            });
            ctx.globalAlpha = 1.0;

            rings.forEach(r => {
                if (!isOnScreen({ x: r.x, y: r.y }, r.r + 50)) return;

                ctx.save();
                ctx.globalAlpha = r.life;

                // 1. 外側の太い光（薄い色）
                ctx.strokeStyle = r.color;
                ctx.lineWidth = 4 * G_SCALE;
                ctx.globalAlpha = r.life * 0.3; // 透明度を下げる
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.r * G_SCALE, 0, Math.PI * 2);
                ctx.stroke();

                // 2. 内側の鋭い光（白い芯）
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1 * G_SCALE;
                ctx.globalAlpha = r.life;
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.r * G_SCALE, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            });
        }


        // player
        function drawPlayer(ctx, p) {
            // --- 1. 自機本体の描画 ---
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            ctx.scale(G_SCALE, G_SCALE);

            // 状態に応じた機体色の決定
            let shipColor = '#0f8';
            if (p.invuln > 0) shipColor = '#ff0';
            else if (p.laserTimer > 0) shipColor = '#0ff';

            ctx.strokeStyle = shipColor;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = shipColor;

            // --- ベース機体（全レベル共通） ---
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.stroke();

            // --- 装飾・進化パーツの追加 ---

            // LV2以上: メインウィングの展開
            if (p.weaponLevel >= 1) {
                ctx.beginPath();
                ctx.moveTo(-5, 5); ctx.lineTo(-18, 15);
                ctx.moveTo(-5, -5); ctx.lineTo(-18, -15);
                ctx.stroke();
            }

            // LV3以上: サイドスラスター/フィン
            if (p.weaponLevel >= 2) {
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(5, 5); ctx.lineTo(-5, 12);
                ctx.moveTo(5, -5); ctx.lineTo(-5, -12);
                ctx.stroke();
            }

            // LV4以上: 機首の強化（ツインカウル）
            if (p.weaponLevel >= 3) {
                ctx.beginPath();
                ctx.moveTo(10, 3); ctx.lineTo(25, 2);
                ctx.moveTo(10, -3); ctx.lineTo(25, -2);
                ctx.stroke();
            }

            // LV5以上: リアサブウィング
            if (p.weaponLevel >= 4) {
                ctx.beginPath();
                ctx.moveTo(-8, 8); ctx.lineTo(-22, 5);
                ctx.moveTo(-8, -8); ctx.lineTo(-22, -5);
                ctx.stroke();
            }

            // LV6以上: 重装甲化（エネルギーライン）
            if (p.weaponLevel >= 5) {
                ctx.save();
                ctx.strokeStyle = '#fff'; // エネルギーラインは白
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(15, 0); ctx.lineTo(-3, 0);
                ctx.stroke();
                ctx.restore();
            }



            ctx.restore();
            ctx.shadowBlur = 0; // シャドウをリセット

            // --- 2. サテライト（衛星）の描画 ---
            p.satellites.forEach(s => {
                ctx.fillStyle = (p.laserTimer > 0) ? '#0ff' : '#0f0';
                ctx.beginPath();
                ctx.arc(s.x, s.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawInvulnBarrier(ctx, p) {
            ctx.save();
            ctx.translate(p.x, p.y);

            const bRadius = 45 * G_SCALE;
            // パルスを少し速く、ダイナミックにする
            const pulseSpeed = p.invuln < 120 ? 0.25 : 0.1;
            const pulse = Math.sin(frame * pulseSpeed) * (p.invuln < 120 ? 6 : 3);
            const r = bRadius + pulse;

            // --- ★カラー動的設定：残り2秒（120F）を切ると警告色へ ---
            let barrierColor = '#ff0'; // 通常：黄色
            let glowBlur = 15;

            if (p.invuln < 120) {
                // 終了間際：赤と黄を高速点滅（残り時間が少ないほど速くなる）
                const flashFreq = p.invuln < 60 ? 3 : 6;
                const isFlash = Math.floor(frame / flashFreq) % 2 === 0;
                barrierColor = isFlash ? '#f44' : '#ff0';
                glowBlur = isFlash ? 25 : 10;
            }

            ctx.strokeStyle = barrierColor;
            ctx.shadowBlur = glowBlur;
            ctx.shadowColor = barrierColor;
            ctx.lineWidth = 2.0; // 少し太くして視認性アップ
            ctx.globalCompositeOperation = 'lighter';

            // --- 1. 球体を構成する3つの回転リング ---
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate((Math.PI / 3) * i + (frame * 0.02)); // 全体もゆっくり自転させる

                // 擬似3D回転
                const rotSpeed = p.invuln < 120 ? 0.15 : 0.05;
                const scaleY = Math.sin(frame * rotSpeed + i * 2);
                ctx.scale(1, scaleY);

                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // --- 2. 輪郭の薄い円（外郭） ---
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // --- 3. 内部の塗りつぶし（グラデーション） ---
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
            grad.addColorStop(0.7, 'transparent');
            grad.addColorStop(1.0, barrierColor);
            ctx.fillStyle = grad;
            ctx.globalAlpha = 0.15;
            ctx.fill();

            ctx.restore();

            // --- 4. バリアから漏れ出るエネルギー粒子（残り時間に応じて増加） ---
            const particleCount = p.invuln < 120 ? 3 : 1;
            if (frame % 2 === 0) {
                for (let i = 0; i < particleCount; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const dist = r;
                    particles.push({
                        x: p.x + Math.cos(ang) * dist,
                        y: p.y + Math.sin(ang) * dist,
                        vx: Math.cos(ang) * 2,
                        vy: Math.sin(ang) * 2,
                        color: barrierColor,
                        life: 0.4,
                        size: 1.5
                    });
                }
            }
        }

        function drawEmeraldPhoenix(ctx, p) {

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);

            // --- 状態に応じた動的なカラー設定 ---
            let mainColor = '#0f8';    // 通常：エメラルドグリーン
            let accentColor = '#0ff';  // 通常：シアン

            if (p.invuln > 0) {
                mainColor = '#ff0';    // 無敵：イエロー
                accentColor = '#fff';  // 無敵：ホワイト
            } else if (p.laserTimer > 0) {
                mainColor = '#0ff';    // レーザー：シアン
                accentColor = '#fff';  // レーザー：ホワイト
            }

            ctx.shadowBlur = 20;
            ctx.shadowColor = mainColor;
            ctx.globalCompositeOperation = 'lighter';

            const scale = G_SCALE * 1.1;
            const time = frame * 0.15;
            const flap = Math.sin(time) * 15;

            // 1. 揺らめく翼（メインカラー）
            ctx.lineWidth = 2;
            ctx.strokeStyle = mainColor;

            for (let side of [-1, 1]) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    -10 * scale, side * (30 + flap) * scale,
                    -40 * scale, side * (40 + flap) * scale,
                    -20 * scale, side * 5 * scale
                );
                ctx.stroke();

                // 翼内のアクセントハイライト
                ctx.save();
                ctx.strokeStyle = accentColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.moveTo(-5 * scale, side * 5 * scale);
                ctx.lineTo(-25 * scale, side * (25 + flap) * scale);
                ctx.stroke();
                ctx.restore();
            }

            // 2. 輝く3本の尾羽（真ん中を太く、機体色に同期）
            for (let i = 0; i < 3; i++) {
                const isCenter = (i === 1);
                const tailOff = Math.sin(frame * 0.2 + i) * 10;

                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = mainColor;

                if (isCenter) {
                    ctx.lineWidth = 3 * scale; // 真ん中を太く
                    ctx.shadowBlur = 25;       // 発光を強化
                } else {
                    ctx.lineWidth = 1 * scale;
                    ctx.globalAlpha = 0.6;
                }

                ctx.moveTo(-10 * scale, (i - 1) * 5 * scale);
                ctx.quadraticCurveTo(
                    -40 * scale, tailOff * scale,
                    -70 * scale, (tailOff + (i - 1) * 15) * scale
                );
                ctx.stroke();
                ctx.restore();
            }

            // --- 3. 頭部デザイン（くちばしの点を削除し、シャープなラインへ） ---
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -4 * scale);
            ctx.lineTo(25 * scale, 0); // 鋭い先端
            ctx.lineTo(0, 4 * scale);
            ctx.stroke();

            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';

            // 4. 羽毛パーティクルの生成（色を同期）
            if (frame % 2 === 0) {
                const pAngle = p.angle + Math.PI + (Math.random() - 0.5);
                const pSpeed = 2 + Math.random() * 4;
                particles.push({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(pAngle) * pSpeed,
                    vy: Math.sin(pAngle) * pSpeed,
                    color: Math.random() > 0.5 ? mainColor : accentColor,
                    life: 1,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function drawLasers() {
            lasers.forEach(l => {
                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.angle);
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 1.5;

                // 修正：固定値 2000 ではなく、計算された l.renderLen を使う
                const len = l.renderLen || 2000;

                const segments = 20;
                const segLen = len / segments;
                const jitter = 15 * (l.life / 5);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let i = 1; i <= segments; i++) {
                    const px = i * segLen;
                    const py = (Math.random() - 0.5) * jitter * 2;
                    ctx.lineTo(px, py);
                }
                ctx.stroke();

                // 芯の白い線
                if (Math.random() > 0.2) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(len, (Math.random() - 0.5) * 5);
                    ctx.stroke();
                }

                // ヒット地点の光（BOSSに当たっている時）
                if (len < 1900) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(len, 0, 10 + Math.random() * 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        // enemy
        function drawDragonEnemy(ctx, e) {
            const dragonScale = e.scale * G_SCALE;
            const coreColor = e.color;

            // --- 1. 胴体セグメント ---
            ctx.lineWidth = 3.5;
            ctx.lineCap = 'butt';
            ctx.lineJoin = 'miter';

            for (let i = e.segments.length - 1; i >= 0; i--) {
                const s = e.segments[i];
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                ctx.scale(dragonScale, dragonScale);

                const sizeMod = Math.max(0.6, 1 - (i * 0.08));
                const w = 12 * sizeMod;
                const h = 18 * sizeMod;

                // 装甲の塗り
                ctx.fillStyle = 'rgba(20, 0, 0, 0.9)';
                ctx.beginPath();
                ctx.moveTo(w, -h / 2);
                ctx.lineTo(w, h / 2);
                ctx.lineTo(-w * 0.9, h * 0.35);
                ctx.lineTo(-w * 0.9, -h * 0.35);
                ctx.closePath();
                ctx.fill();

                // 装甲の線
                ctx.strokeStyle = coreColor;
                ctx.stroke();

                // フィン（線を一本のパスにまとめて描画命令を削減）
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-w * 0.5, -h / 3); ctx.lineTo(w, -h / 3);
                ctx.moveTo(-w * 0.5, h / 3); ctx.lineTo(w, h / 3);
                ctx.stroke();

                ctx.restore();
            }

            // --- 2. 頭部ユニット ---
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(dragonScale, dragonScale);

            // メインヘッド
            ctx.fillStyle = '#300';
            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(-10, -12);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, 12);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = coreColor;
            ctx.lineWidth = 4;
            ctx.stroke();

            // --- 3. センサーアイ：擬似発光（軽量化版） ---
            const blink = (Math.sin(frame * 0.15) * 0.5) + 0.5;
            // ぼかしの代わりに、背面に一回り大きい半透明の矩形を描く
            if (blink > 0.2) {
                ctx.fillStyle = '#ff8800';
                ctx.globalAlpha = blink * 0.4;
                // 外側の光輪
                ctx.fillRect(3, -5, 12, 10);
            }

            // 目本体
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = `rgb(255, ${128 + 127 * blink}, 60)`;
            ctx.fillRect(5, -3, 8, 6);

            // アンテナ
            ctx.strokeStyle = coreColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, -10); ctx.lineTo(-15, -20);
            ctx.moveTo(-5, 10); ctx.lineTo(-15, 20);
            ctx.stroke();

            ctx.restore();
        }

        function drawTriangleEnemy(ctx, e) {
            if (!e || typeof e.x !== 'number' || isNaN(e.x)) return;

            ctx.save();

            // --- 1. 座標と進行方向への回転 ---
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);

            const currentScale = (e.scale || 0.7) * G_SCALE * 1.2;
            ctx.scale(currentScale, currentScale);

            // --- 2. 描画設定 ---
            const visualAlpha = e.isWarping ? (e.warpPercent || 0) : 1.0;
            ctx.globalAlpha = visualAlpha;
            ctx.globalCompositeOperation = 'lighter';

            // --- 3. 3D形状（縦長の正八面体） ---
            const size = 12;
            const pts = [
                { x: 3.5, y: 0, z: 0 },  // 前頂点（縦長）
                { x: -1.2, y: 0, z: 0 },  // 後頂点
                { x: 0, y: 1, z: 1 }, { x: 0, y: -1, z: 1 },
                { x: 0, y: -1, z: -1 }, { x: 0, y: 1, z: -1 }
            ];

            // --- 4. 自転計算 ---
            const cosR = Math.cos(e.rotX || 0);
            const sinR = Math.sin(e.rotX || 0);
            const proj = pts.map(p => {
                let ny = p.y * cosR - p.z * sinR;
                return { x: p.x * size, y: ny * size };
            });

            const lines = [
                [0, 2], [0, 3], [0, 4], [0, 5],
                [1, 2], [1, 3], [1, 4], [1, 5],
                [2, 3], [3, 4], [4, 5], [5, 2]
            ];

            // --- 5. ワイヤーフレーム ---
            ctx.strokeStyle = e.color || '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            lines.forEach(l => {
                ctx.moveTo(proj[l[0]].x, proj[l[0]].y);
                ctx.lineTo(proj[l[1]].x, proj[l[1]].y);
            });
            ctx.stroke();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // --- 6. 点滅する熱源コア ---
            // フレーム数から0.8〜1.2の範囲で揺らぎを作る
            const pulse = 0.8 + Math.sin(frame * 0.15) * 0.2;

            // レイヤー1：赤（外側）
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(0, 0, 7.5 * pulse, 0, Math.PI * 2);
            ctx.fill();

            // レイヤー2：橙（中間）
            ctx.fillStyle = '#f90';
            ctx.beginPath();
            ctx.arc(0, 0, 5 * pulse, 0, Math.PI * 2);
            ctx.fill();

            // レイヤー3：白（中心）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 2.5, 0, Math.PI * 2); // 中心は安定させるため固定
            ctx.fill();

            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawCubeEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // --- 1. アイテムの種類に応じたコアの色設定 ---
            let coreColor = '#ff0'; // デフォルト（クリスタル/なし）：黄
            if (e.drop === 'laser') coreColor = '#0ff';      // レーザー：シアン
            if (e.drop === 'level') coreColor = '#0f0';      // レベルアップ：緑
            if (e.drop === 'invincible') coreColor = '#fff'; // 無敵：白

            // 点滅演出
            const pulse = (Math.sin(frame * 0.15) * 0.5) + 0.5;
            const coreSize = 6 + pulse * 4;

            ctx.shadowBlur = 15 + pulse * 10;
            ctx.shadowColor = coreColor;

            // コアの外光（パルスに合わせて透明度変化）
            const rgb = coreColor === '#ff0' ? '255, 255, 0' :
                coreColor === '#0ff' ? '0, 255, 255' :
                    coreColor === '#0f0' ? '0, 255, 0' : '255, 255, 255';

            ctx.fillStyle = `rgba(${rgb}, ${0.4 + pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();

            // コアの中心（高輝度）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. 外殻のワイヤーフレーム (緑色で固定) ---
            ctx.shadowBlur = 5;
            ctx.shadowColor = e.color;
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 1.5;

            const size = 16;
            const pts = [
                { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 },
                { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
                { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 },
                { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
            ];

            const cosX = Math.cos(e.rotX), sinX = Math.sin(e.rotX);
            const cosY = Math.cos(e.rotY), sinY = Math.sin(e.rotY);

            const proj = pts.map(p => {
                let y = p.y * cosX - p.z * sinX;
                let z = p.y * sinX + p.z * cosX;
                let x = p.x * cosY + z * sinY;
                return { x: x * size, y: y * size };
            });

            const lines = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            ctx.beginPath();
            lines.forEach(l => {
                ctx.moveTo(proj[l[0]].x, proj[l[0]].y);
                ctx.lineTo(proj[l[1]].x, proj[l[1]].y);
            });
            ctx.stroke();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawHunterEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            // 自転演出
            const spin = (e.rotSpeed || 0.12) * frame;
            ctx.rotate(spin);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            const isAiming = (e.state === 'aim');
            const isDmg = e.flashTimer > 0;
            if (isDmg) e.flashTimer--;

            // --- 外郭のカラー（e.colorを反映） ---
            let mainColor = isDmg ? '#ffffff' : (e.color || '#00ffff');

            ctx.shadowBlur = 8;
            ctx.shadowColor = mainColor;
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 1.2;

            // --- 1. 外郭ワイヤーフレーム（円形） ---
            ctx.beginPath();
            ctx.arc(0, 0, 16, 0, Math.PI * 2);
            ctx.stroke();

            // --- 1.2 スポーク（4方向の強化アーム構造） ---
            for (let i = 0; i < 4; i++) {
                const ang = (Math.PI / 2) * i;
                const cos = Math.cos(ang);
                const sin = Math.sin(ang);

                ctx.beginPath();
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 1.0;

                // 支柱を二股（V字）のトラス構造にする
                // 中心から少し離れた位置から、先端に向けて広がるライン
                const armSpread = 0.2; // 広がり具合
                ctx.moveTo(cos * 4, sin * 4);
                ctx.lineTo(Math.cos(ang - armSpread) * 14, Math.sin(ang - armSpread) * 14);
                ctx.moveTo(cos * 4, sin * 4);
                ctx.lineTo(Math.cos(ang + armSpread) * 14, Math.sin(ang + armSpread) * 14);
                ctx.stroke();

                // --- 先端のセンサーパーツ（ひし形/ポッド状） ---
                ctx.save();
                ctx.translate(cos * 16, sin * 16);
                ctx.rotate(ang); // スポークの向きに合わせる

                ctx.beginPath();
                // 鋭いひし形のチップデザイン
                ctx.moveTo(4, 0);   // 先端
                ctx.lineTo(0, 3);   // 横
                ctx.lineTo(-3, 0);  // 後ろ
                ctx.lineTo(0, -3);  // 横
                ctx.closePath();

                // ダメージ時は白、通常はメインカラーの塗り
                ctx.fillStyle = isDmg ? '#fff' : mainColor;
                ctx.globalAlpha = 0.6; // 少し透けさせてワイヤー感を出す
                ctx.fill();

                // 輪郭線
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = isDmg ? '#fff' : mainColor;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }

            // --- 2. 中央の赤く光るコア ---
            ctx.save();
            // 自転の影響を受けないよう逆回転させても良いですが、
            // 円形なのでそのまま描画します。

            // コアの脈動計算
            const pulse = Math.sin(frame * 0.15) * 1.5;
            const coreBaseRad = isAiming ? 6 : 4;
            const coreRad = coreBaseRad + pulse;

            // コアの外光（グローエフェクト）
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = isAiming ? 25 : 15;
            ctx.shadowColor = '#ff0000';

            // 放射状グラデーションで「熱源」を表現
            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRad * 1.5);
            coreGrad.addColorStop(0, '#ffffff');      // 中心は白熱
            coreGrad.addColorStop(0.3, '#ff3300');    // 中間は鮮やかな赤
            coreGrad.addColorStop(1, 'transparent'); // 外側へ消える

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(0, 0, coreRad * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // コアの実体（中心の小さな円）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // --- 3. 照準レーザー（赤いコアに合わせて赤色を強調） ---
            if (isAiming) {
                ctx.save();
                ctx.rotate(-spin);
                ctx.rotate(e.angle);

                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.setLineDash([10, 5]);
                ctx.strokeStyle = `rgba(255, 0, 50, ${0.6 + Math.sin(frame * 0.8) * 0.3})`;
                ctx.lineWidth = 2;
                ctx.moveTo(12, 0);
                ctx.lineTo(600, 0);
                ctx.stroke();

                // 砲口のフラッシュ
                ctx.beginPath();
                ctx.arc(12, 0, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ffaaaa';
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
        }

        function drawTadpoleEnemy(ctx, e) {
            ctx.save();

            // --- 描画関数内 ---
            const baseColor = e.color; // 例: "#00ffff"
            const hue = getHue(baseColor); // 色相を取得


            // lightCyan: 元の色と同じ色相で、輝度を90%（ほぼ白に近い明るさ）にする
            const lightColor = `hsl(${hue}, 100%, 90%)`;

            // --- 1. テイル（高速流動フラグメント）の描画 ---
            if (e.history.length > 1) {
                ctx.setLineDash([12, 18]);
                for (let i = 0; i < e.history.length - 1; i += 3) {
                    const p1 = e.history[i];
                    const p2 = e.history[i + 1];
                    if (!p2) break;

                    const ratio = i / e.history.length;
                    const alpha = (1 - ratio) * 0.6;

                    // 尾も水色のグラデーションに
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = (14 - ratio * 14) * G_SCALE;

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }

            // --- 2. 幾何学メカニカル・ヘッド（頭部）の描画 ---
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            // 背景の遮蔽（より深い紺色で水色を引き立てる）
            ctx.fillStyle = 'rgba(0, 10, 20, 0.9)';
            ctx.beginPath();
            ctx.rect(-10, -15, 45, 30);
            ctx.fill();

            // ワイヤーフレームの設定
            ctx.strokeStyle = baseColor;
            ctx.lineWidth = 2.5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = baseColor;

            // --- メインボディ「＝＝＝」部分 ---
            for (let j = 0; j < 3; j++) {
                const xPos = j * 12;
                // シリンダーリング
                ctx.beginPath();
                ctx.ellipse(xPos, 0, 8, 15, 0, 0, Math.PI * 2);
                ctx.stroke();

                // 水平支柱（ハイライト色を混ぜる）
                ctx.save();
                ctx.strokeStyle = lightColor;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(xPos, -15); ctx.lineTo(xPos + 12, -15);
                ctx.moveTo(xPos, 15); ctx.lineTo(xPos + 12, 15);
                ctx.stroke();
                ctx.restore();
            }

            // --- 先端ユニット「＜＜」部分 ---
            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.moveTo(35, -14); ctx.lineTo(52, 0); ctx.lineTo(35, 14); // 外側の ＜
            ctx.stroke();

            ctx.save();
            ctx.strokeStyle = lightColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(25, -9); ctx.lineTo(42, 0); ctx.lineTo(25, 9);   // 内側の ＜
            ctx.stroke();
            ctx.restore();

            // --- コア・ユニット ---
            // 中心部で強く輝く水色のエネルギー体
            ctx.fillStyle = lightColor;
            ctx.shadowBlur = 20;
            ctx.shadowColor = baseColor;
            ctx.beginPath();
            ctx.rect(5, -4, 8, 8);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawAsteroidEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.angle);

            // スケールを適用
            const s = e.scale * G_SCALE;
            ctx.scale(s, s);

            // ネオンホワイトのワイヤーフレーム設定
            ctx.strokeStyle = e.color;

            // ★ポイント: 小さくなっても線の太さを維持する計算
            // スケール s で割ることで、画面上の見た目の太さを常に一定（約1.5px）に保ちます
            ctx.lineWidth = 1.5 / s;

            ctx.shadowBlur = 12 / s; // 発光もスケールに合わせて調整
            ctx.shadowColor = '#fff';

            ctx.beginPath();
            // 岩の形状（e.sizeをシードにして形状を固定）
            for (let i = 0; i < 8; i++) {
                const r = 22 * (0.8 + Math.sin(i * 2.1 + e.size * 5) * 0.25);
                const ang = (Math.PI * 2 / 8) * i;
                const tx = Math.cos(ang) * r;
                const ty = Math.sin(ang) * r;
                if (i === 0) ctx.moveTo(tx, ty); else ctx.lineTo(tx, ty);
            }
            ctx.closePath();
            ctx.stroke();

            // 内部の亀裂（これも線の太さを維持）
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.moveTo(-10, -5); ctx.lineTo(5, 8);
            ctx.stroke();

            ctx.restore();
        }

        function drawPhantomEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            const scale = e.scale * G_SCALE;
            ctx.scale(scale, scale);

            ctx.globalCompositeOperation = 'lighter';

            // --- 2. 3D計算（垂直にコインが回るような回転） ---
            // ★ゆっくり回るように速度を調整
            const rotSpeed = e.state === 'dash' ? 0.2 : 0.01;
            if (e.rotAngle === undefined) e.rotAngle = Math.random() * Math.PI * 2;
            e.rotAngle += rotSpeed;

            // 簡易3D投影
            const project = (x, y, z) => {
                // ★ Y軸回転（立てたコインが垂直に回る動き）
                const x1 = x * Math.cos(e.rotAngle) - z * Math.sin(e.rotAngle);
                const z1 = x * Math.sin(e.rotAngle) + z * Math.cos(e.rotAngle);
                const y1 = y;

                // ★ X軸回転（少し上から見下ろす角度をつけて立体感と厚みを見せる）
                const tilt = 0.4;
                const y2 = y1 * Math.cos(tilt) - z1 * Math.sin(tilt);

                return { px: x1, py: y2 };
            };

            // サイズ (1.3倍)
            const R = 20.8; // 外径 
            const r = 11.7; // 内径 
            const h = 7.8;  // 厚みの半分 
            const sides = 8; // 八角形

            const projOuterTop = [];
            const projInnerTop = [];
            const projOuterBot = [];
            const projInnerBot = [];

            // 頂点生成と投影
            for (let i = 0; i < sides; i++) {
                const a = (Math.PI * 2 / sides) * i;
                const cx = Math.cos(a);
                const cy = Math.sin(a);

                // XY平面に八角形を作り、Z方向で厚みを表現
                projOuterTop.push(project(cx * R, cy * R, h));
                projInnerTop.push(project(cx * r, cy * r, h));
                projOuterBot.push(project(cx * R, cy * R, -h));
                projInnerBot.push(project(cx * r, cy * r, -h));
            }

            // 描画ヘルパー
            const drawLoop = (pts) => {
                ctx.beginPath();
                pts.forEach((p, i) => i === 0 ? ctx.moveTo(p.px, p.py) : ctx.lineTo(p.px, p.py));
                ctx.closePath();
                ctx.stroke();
            };

            // --- 3. シンプルなワイヤーフレーム描画 ---
            ctx.globalAlpha = e.alpha;
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 2.5;

            // 4つのリングを描く
            drawLoop(projOuterTop);
            drawLoop(projInnerTop);
            drawLoop(projOuterBot);
            drawLoop(projInnerBot);

            // 上下のリングを繋ぐ厚み方向の線を描く
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                ctx.moveTo(projOuterTop[i].px, projOuterTop[i].py);
                ctx.lineTo(projOuterBot[i].px, projOuterBot[i].py);
                ctx.moveTo(projInnerTop[i].px, projInnerTop[i].py);
                ctx.lineTo(projInnerBot[i].px, projInnerBot[i].py);
            }
            ctx.stroke();

            // --- 4. 赤-オレンジの点滅するコア ---
            const center = project(0, 0, 0);

            // 色を赤(Hue:0付近)〜オレンジ(Hue:30付近)で明滅させる
            const hue = 15 + Math.sin(frame * 0.25) * 15;
            const coreColor = `hsl(${hue}, 100%, 60%)`;
            const pulse = 1.2 + Math.sin(frame * 0.4) * 0.3;

            // 強い発光
            ctx.fillStyle = coreColor;
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = coreColor;
            ctx.globalAlpha = 1.0;

            ctx.beginPath();
            const coreSize = (e.state === 'dash' ? 6.5 : 4.5) * pulse;
            ctx.arc(center.px, center.py, coreSize, 0, Math.PI * 2);
            ctx.fill();

            // 中心に白い芯
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(center.px, center.py, coreSize * 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function drawEclipseEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);

            const isDmg = e.hp % 1 !== 0; // ダメージを受けた瞬間の判定用（簡易的）
            const mainColor = isDmg ? '#fff' : e.color;

            ctx.globalCompositeOperation = 'lighter';

            // 1. 外輪の回転（歯車）
            ctx.save();
            ctx.rotate(e.angle);
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = mainColor;

            const radius = 32;
            const teeth = 8;
            ctx.beginPath();
            for (let i = 0; i < teeth * 2; i++) {
                const r = (i % 2 === 0) ? radius : radius + 12; // ギザギザを作る
                const a = (Math.PI / teeth) * i;
                if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.stroke();

            // 外輪の内側の線
            ctx.beginPath();
            ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // 2. 逆回転する中層リング
            ctx.save();
            ctx.rotate(-e.angle * 1.5);
            ctx.strokeStyle = '#ffbb00';
            ctx.lineWidth = 2;
            ctx.setLineDash([15, 10]); // 破線
            ctx.beginPath();
            ctx.arc(0, 0, radius - 14, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // 3. 中心コアの脈動
            const pulse = Math.sin(frame * 0.1) * 3;
            ctx.fillStyle = '#ff00aa';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff00aa';
            ctx.beginPath();
            ctx.arc(0, 0, 12 + pulse, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();

            // 4. 攻撃予兆エフェクト
            const cycle = Math.floor(e.actionTimer) % 350;
            if (cycle > 80 && cycle < 120) {
                // 全方位弾チャージ（収束する光の輪）
                const chargeRatio = (120 - cycle) / 40;
                ctx.strokeStyle = `rgba(255, 255, 255, ${chargeRatio})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 50 * chargeRatio, 0, Math.PI * 2);
                ctx.stroke();
            } else if (cycle > 220 && cycle < 250) {
                // 狙撃チャージ（赤いレーザーサイト）
                const a = Math.atan2(player.y - e.y, player.x - e.x);
                ctx.rotate(a);
                ctx.strokeStyle = `rgba(255, 0, 0, ${Math.sin(frame * 0.5)})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(800, 0);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawBossEnemy(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            // 1. 出現演出 (最適化: 高速なイージング)
            if (e.isSpawning) {
                const t = e.spawnTimer / e.spawnMax;
                const easeOut = 1 - Math.pow(1 - t, 4);
                ctx.globalAlpha = t;
                const spawnScale = 0.1 + 0.9 * easeOut;
                ctx.scale(spawnScale, spawnScale);
                ctx.globalCompositeOperation = 'lighter';
            }

            // 2. 基本回転とスケーリング
            ctx.rotate(e.angle);
            const shipScale = e.scale * G_SCALE;
            ctx.scale(shipScale, shipScale);

            const isDmg = e.flashTimer > 0;
            if (isDmg) e.flashTimer--;

            // 3. パラメータの取得
            const sides = e.variant.sides;
            const baseColor = e.color;
            const mainStroke = isDmg ? '#ffffff' : baseColor;
            // ★追加: リアクター用の深紅カラー定義
            const reactorColor = isDmg ? '#ffffff' : '#cc0000';

            // 全体の基本半径
            const baseRadius = 45;

            // --- 4. 中層：土台・トラス構造 ---
            ctx.save();
            ctx.fillStyle = 'rgba(5, 10, 15, 0.95)';
            ctx.beginPath(); drawPolygonPath(ctx, baseRadius, sides); ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                ctx.moveTo(0, 0); ctx.lineTo(Math.cos(angle) * baseRadius, Math.sin(angle) * baseRadius);
            }
            ctx.stroke(); ctx.restore();

            // --- 4.5. 内装フレーム (追加) ---
            ctx.save();
            // 内側のフレームなので、土台より少し小さくする
            const innerFrameRad = baseRadius * 0.85;

            // メインカラーを少し暗くして、奥行き感を出す
            ctx.strokeStyle = mainStroke;
            ctx.lineWidth = 0.8; // 細い線で精密感を出す
            ctx.globalAlpha = 0.5; // 半透明にして内部構造らしく見せる

            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                // 現在の頂点の角度
                const angle1 = (Math.PI * 2 / sides) * i - Math.PI / 2;
                // 次の頂点の角度
                const angle2 = (Math.PI * 2 / sides) * (i + 1) - Math.PI / 2;
                // 2つの頂点の中間の角度
                const midAngle = (angle1 + angle2) / 2;

                // 1. 頂点から中心に向かうフレーム
                ctx.moveTo(Math.cos(angle1) * innerFrameRad, Math.sin(angle1) * innerFrameRad);
                ctx.lineTo(Math.cos(angle1) * (innerFrameRad * 0.3), Math.sin(angle1) * (innerFrameRad * 0.3));

                // 2. 頂点間をつなぐ、少し内側に凹んだトラス構造
                ctx.moveTo(Math.cos(angle1) * innerFrameRad, Math.sin(angle1) * innerFrameRad);
                // 中間の角度の、少し内側の点に向かって線を引く
                ctx.lineTo(Math.cos(midAngle) * (innerFrameRad * 0.6), Math.sin(midAngle) * (innerFrameRad * 0.6));
                // 次の頂点に向かって線を引く
                ctx.lineTo(Math.cos(angle2) * innerFrameRad, Math.sin(angle2) * innerFrameRad);
            }
            // 内側の小さな多角形も描く
            drawPolygonPath(ctx, innerFrameRad * 0.3, sides);

            ctx.stroke();
            ctx.restore();

            // --- 5. 精密砲台モジュール (角の数だけ配置) ---
            for (let i = 0; i < sides; i++) {
                ctx.save();
                ctx.rotate((Math.PI * 2 / sides) * i);
                ctx.translate(0, -baseRadius + 5);
                ctx.scale(0.5, 0.5);

                // A. 側面装甲
                ctx.fillStyle = '#050000';
                ctx.beginPath();
                ctx.moveTo(-16, -28); ctx.lineTo(16, -28); ctx.lineTo(14, 25);
                ctx.lineTo(8, 30); ctx.lineTo(-8, 30); ctx.lineTo(-14, 25);
                ctx.closePath(); ctx.fill();
                ctx.strokeStyle = mainStroke; ctx.lineWidth = 2; ctx.stroke();

                // B. 天面
                ctx.translate(0, -3);
                const modGrad = ctx.createLinearGradient(-10, -20, 10, 20);
                modGrad.addColorStop(0, 'rgba(40, 40, 40, 0.95)');
                modGrad.addColorStop(0.5, 'rgba(10, 10, 10, 0.95)');
                modGrad.addColorStop(1, 'rgba(0, 0, 0, 0.95)');
                ctx.fillStyle = modGrad;
                ctx.beginPath();
                ctx.moveTo(-12, -35); ctx.lineTo(12, -35); ctx.lineTo(14, 15);
                ctx.lineTo(8, 25); ctx.lineTo(-8, 25); ctx.lineTo(-14, 15);
                ctx.closePath(); ctx.fill();
                ctx.strokeStyle = mainStroke; ctx.lineWidth = 1; ctx.stroke();

                // C. リアクター (★変更: 深紅の発光)
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const energyPulse = Math.sin(frame * 0.3 + i) * 0.3 + 0.7;
                ctx.fillStyle = reactorColor; // 深紅を適用
                ctx.globalAlpha = energyPulse;
                for (let k = 0; k < 5; k++) {
                    const y = -10 + k * 6;
                    const w = 14 + k * 1.5;
                    ctx.fillRect(-w / 2 - 1, y - 1, w + 2, 4);
                }
                ctx.restore();

                // D. 砲身 (★変更: 大きく突き出すように延長)
                ctx.strokeStyle = mainStroke;
                ctx.lineWidth = 1;
                ctx.beginPath();
                // 根元のレール部分
                ctx.moveTo(-6, -35); ctx.lineTo(-6, -10);
                ctx.moveTo(6, -35); ctx.lineTo(6, -10);
                // 先端の砲身（大幅に延長: 25 -> 50）
                ctx.moveTo(0, 10); ctx.lineTo(0, 50);
                ctx.stroke();

                // 砲口のアクセント
                ctx.fillStyle = mainStroke;
                ctx.beginPath(); ctx.arc(0, 50, 1.5, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
            }

            // --- 6. 多層外殻フレーム ---
            ctx.save();
            const layers = 4;
            // ★変更: 外側への広がりを大きくして、線と線の間の「隙間」をしっかり確保する
            const outerRad = baseRadius + 28; // 12 から 28 に拡大
            const innerRad = baseRadius + 2;  // 本体から少しだけ離す

            for (let i = 0; i < layers; i++) {
                const ratio = i / (layers - 1);

                // ★変更: 外側に行くほど少しずつ間隔が広がるように計算（立体感アップ）
                const r = innerRad + (outerRad - innerRad) * Math.pow(ratio, 1.2);

                // ★変更: 内側を濃く、外側に広がるほど薄く消えていくグラデーション表現
                const layerAlpha = 0.15 + 0.6 * (1 - ratio);

                // ★変更: 線が太すぎるとくっついてしまうので、細くて鋭い線にする
                const layerWidth = 1.2 - (0.7 * ratio);

                ctx.beginPath();
                drawPolygonPath(ctx, r, sides);
                ctx.strokeStyle = mainStroke;
                ctx.lineWidth = Math.max(0.5, layerWidth); // 最小でも0.5の太さは維持
                ctx.globalAlpha = layerAlpha;
                ctx.stroke();
            }

            // フレーム接続リブ（放射状の支柱）
            ctx.beginPath();
            ctx.lineWidth = 2.0;
            ctx.strokeStyle = mainStroke;
            ctx.globalAlpha = 0.5;
            for (let i = 0; i < sides; i++) {
                // 砲台と同じ位置（頂点）から支柱を伸ばす
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                ctx.moveTo(Math.cos(angle) * innerRad, Math.sin(angle) * innerRad);
                ctx.lineTo(Math.cos(angle) * outerRad, Math.sin(angle) * outerRad);
            }
            ctx.stroke();
            ctx.restore();

            // --- 7. コア・ソケット ---
            const socketRad = baseRadius * 0.45;
            ctx.save();
            ctx.fillStyle = '#080808'; ctx.strokeStyle = mainStroke; ctx.lineWidth = 1.5;
            ctx.beginPath(); drawPolygonPath(ctx, socketRad, sides); ctx.fill(); ctx.stroke();
            for (let i = 0; i < sides; i++) {
                ctx.save(); ctx.rotate((Math.PI * 2 / sides) * i);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.moveTo(socketRad * 0.5, -3); ctx.lineTo(socketRad * 0.8, -1);
                ctx.lineTo(socketRad * 0.8, 1); ctx.lineTo(socketRad * 0.5, 3);
                ctx.fill(); ctx.restore();
            }
            ctx.restore();

            // --- 8. 立体ダイヤモンド・コア ---
            ctx.save();
            const pulse = Math.sin(frame * 0.1);
            const coreSize = socketRad * 0.6 + pulse * 1.5;

            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = isDmg ? 40 : 20;
            ctx.shadowColor = mainStroke;

            ctx.fillStyle = 'rgba(10, 0, 0, 0.8)';
            ctx.beginPath(); drawPolygonPath(ctx, coreSize, sides); ctx.fill();

            const coreLayers = 3;
            for (let l = 0; l < coreLayers; l++) {
                const scale3d = 1.0 - (l * 0.25);
                const alpha3d = 0.4 + (l * 0.2);
                ctx.save();
                ctx.rotate(frame * (0.02 + l * 0.01) * (l % 2 === 0 ? 1 : -1));
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha3d})`;
                ctx.fillStyle = mainStroke;
                ctx.globalAlpha = alpha3d * 0.3;
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 0;
                ctx.beginPath(); drawPolygonPath(ctx, coreSize * scale3d, sides);
                ctx.fill(); ctx.stroke();
                ctx.beginPath();
                const rad = coreSize * scale3d;
                for (let i = 0; i < sides; i++) {
                    const ang = (Math.PI * 2 / sides) * i - Math.PI / 2;
                    ctx.moveTo(0, 0); ctx.lineTo(Math.cos(ang) * rad, Math.sin(ang) * rad);
                }
                ctx.stroke(); ctx.restore();
            }
            ctx.fillStyle = '#ffffff'; ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
            ctx.restore(); // コア終了

            // --- 9. ダメージエフェクト ---
            if (isDmg && !e.isSpawning) {
                for (let i = 0; i < 4; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const spd = 4 + Math.random() * 10;
                    particles.push({
                        x: e.x + (Math.random() - 0.5) * 40, y: e.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
                        color: Math.random() > 0.4 ? '#fff' : baseColor, life: 0.5, size: 2 + Math.random() * 2
                    });
                }
            }
            ctx.restore(); // 全体終了
        }

        // --- 巨大戦艦（ラスボス）の描画 ---
        function drawBattleshipBoss(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y);

            if (e.isSpawning) {
                const t = e.spawnTimer / e.spawnMax;
                const easeOut = 1 - Math.pow(1 - t, 4);
                ctx.globalAlpha = t;
                const spawnScale = 0.1 + 0.9 * easeOut;
                ctx.scale(spawnScale, spawnScale);
                ctx.globalCompositeOperation = 'lighter';
            }

            ctx.rotate(e.angle);
            const shipScale = e.scale * G_SCALE * 1.5;
            ctx.scale(shipScale, shipScale);

            const isDmg = e.flashTimer > 0;
            if (isDmg) e.flashTimer--;

            const sides = e.variant.sides || 12;

            const colorCyan = '#00ffff';
            const colorDeepRed = '#aa0000';
            const colorRedNeon = '#ff0022';
            const colorHighLight = '#ffaaaa';

            const mainStroke = isDmg ? '#ffffff' : colorCyan;
            const subStroke = isDmg ? '#ffffff' : colorRedNeon;
            const reactorColor = isDmg ? '#ffffff' : '#cc0000';

            const baseRadius = 90;

            // --- 4. 中層：土台・トラス構造 ---
            ctx.save();
            ctx.fillStyle = 'rgba(5, 10, 15, 0.95)';
            ctx.beginPath();
            drawPolygonPath(ctx, baseRadius, sides);
            ctx.fill();

            ctx.strokeStyle = '#004455';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * baseRadius, Math.sin(angle) * baseRadius);
            }
            ctx.stroke();
            ctx.restore();

            // --- 4.5. 内装フレーム ---
            ctx.save();
            const innerFrameRad = baseRadius * 0.85;
            ctx.strokeStyle = mainStroke;
            ctx.lineWidth = 0.8;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle1 = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const angle2 = (Math.PI * 2 / sides) * (i + 1) - Math.PI / 2;
                const midAngle = (angle1 + angle2) / 2;
                ctx.moveTo(Math.cos(angle1) * innerFrameRad, Math.sin(angle1) * innerFrameRad);
                ctx.lineTo(Math.cos(angle1) * (innerFrameRad * 0.3), Math.sin(angle1) * (innerFrameRad * 0.3));
                ctx.moveTo(Math.cos(angle1) * innerFrameRad, Math.sin(angle1) * innerFrameRad);
                ctx.lineTo(Math.cos(midAngle) * (innerFrameRad * 0.6), Math.sin(midAngle) * (innerFrameRad * 0.6));
                ctx.lineTo(Math.cos(angle2) * innerFrameRad, Math.sin(angle2) * innerFrameRad);
            }
            drawPolygonPath(ctx, innerFrameRad * 0.3, sides);
            ctx.stroke();
            ctx.restore();

            // --- 5. 精密砲台モジュール ---
            for (let i = 0; i < sides; i++) {
                ctx.save();
                ctx.rotate((Math.PI * 2 / sides) * i);
                ctx.translate(0, -baseRadius + 12);
                ctx.scale(0.8, 0.8);

                ctx.fillStyle = '#050000';
                ctx.beginPath();
                ctx.moveTo(-16, -28); ctx.lineTo(16, -28); ctx.lineTo(14, 25);
                ctx.lineTo(8, 30); ctx.lineTo(-8, 30); ctx.lineTo(-14, 25);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = colorCyan;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.translate(0, -3);
                const modGrad = ctx.createLinearGradient(-10, -20, 10, 20);
                modGrad.addColorStop(0, 'rgba(30, 0, 5, 0.95)');
                modGrad.addColorStop(0.5, 'rgba(60, 10, 20, 0.95)');
                modGrad.addColorStop(1, 'rgba(20, 0, 0, 0.95)');
                ctx.fillStyle = modGrad;
                ctx.beginPath();
                ctx.moveTo(-12, -35); ctx.lineTo(12, -35); ctx.lineTo(14, 15);
                ctx.lineTo(8, 25); ctx.lineTo(-8, 25); ctx.lineTo(-14, 15);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = mainStroke;
                ctx.lineWidth = 0.8;
                ctx.stroke();

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const energyPulse = Math.sin(frame * 0.3 + i) * 0.3 + 0.7;
                ctx.fillStyle = reactorColor;
                ctx.globalAlpha = energyPulse;
                for (let k = 0; k < 5; k++) {
                    const y = -10 + k * 6;
                    const w = 14 + k * 1.5;
                    ctx.fillRect(-w / 2 - 1, y - 1, w + 2, 4);
                }
                ctx.restore();

                ctx.strokeStyle = mainStroke;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-6, -35); ctx.lineTo(-6, -10);
                ctx.moveTo(6, -35); ctx.lineTo(6, -10);
                ctx.moveTo(0, 10); ctx.lineTo(0, 50);
                ctx.stroke();

                ctx.fillStyle = mainStroke;
                ctx.beginPath(); ctx.arc(0, 50, 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            // --- 6. 多層外殻フレーム ---
            ctx.save();
            const layers = 5;
            const outerRad = baseRadius + 40;
            const innerRad = baseRadius + 5;
            for (let i = 0; i < layers; i++) {
                const ratio = i / (layers - 1);
                const r = innerRad + (outerRad - innerRad) * Math.pow(ratio, 1.2);
                const layerAlpha = 0.15 + 0.7 * (1 - ratio);
                const layerWidth = 1.5 - (1.0 * ratio);

                ctx.beginPath();
                drawPolygonPath(ctx, r, sides);
                ctx.strokeStyle = colorCyan;
                ctx.lineWidth = Math.max(0.5, layerWidth);
                ctx.globalAlpha = layerAlpha;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.lineWidth = 1.0;
            ctx.strokeStyle = mainStroke;
            ctx.globalAlpha = 0.5;
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                ctx.moveTo(Math.cos(angle) * innerRad, Math.sin(angle) * innerRad);
                ctx.lineTo(Math.cos(angle) * outerRad, Math.sin(angle) * outerRad);
            }
            ctx.stroke();
            ctx.restore();

            // --- 7. コア・ソケット ---
            const socketRad = baseRadius * 0.45;
            ctx.save();
            ctx.fillStyle = '#080000';
            ctx.strokeStyle = colorCyan;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            drawPolygonPath(ctx, socketRad, sides);
            ctx.fill();
            ctx.stroke();

            for (let i = 0; i < sides; i++) {
                ctx.save();
                ctx.rotate((Math.PI * 2 / sides) * i);
                ctx.fillStyle = '#660000';
                ctx.beginPath();
                const decorDist = socketRad * 0.65;
                ctx.moveTo(decorDist, -4); ctx.lineTo(decorDist + 13, -2);
                ctx.lineTo(decorDist + 13, 2); ctx.lineTo(decorDist, 4);
                ctx.fill();
                ctx.strokeStyle = colorCyan;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(decorDist + 13, 0); ctx.lineTo(decorDist - 5, 0);
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // --- 8. 立体ダイヤモンド・コア ---
            ctx.save();
            const pulse = Math.sin(frame * 0.1);
            const coreSize = socketRad * 0.6 + pulse * 1.5;

            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = isDmg ? 60 : 30;
            ctx.shadowColor = colorRedNeon;

            ctx.fillStyle = colorDeepRed;
            ctx.beginPath(); drawPolygonPath(ctx, coreSize, sides); ctx.fill();

            const coreLayers = 4;
            for (let l = 0; l < coreLayers; l++) {
                const scale3d = 1.0 - (l * 0.18);
                const alpha3d = 0.4 + (l * 0.15);
                ctx.save();
                ctx.rotate(frame * (0.01 + l * 0.005) * (l % 2 === 0 ? 1 : -1));
                ctx.strokeStyle = `rgba(255, 200, 200, ${alpha3d})`;
                ctx.fillStyle = `rgba(255, 0, 50, ${alpha3d * 0.2})`;
                ctx.lineWidth = 1.0;
                ctx.shadowBlur = 0;

                ctx.beginPath(); drawPolygonPath(ctx, coreSize * scale3d, sides);
                ctx.fill(); ctx.stroke();

                ctx.beginPath();
                const rad = coreSize * scale3d;
                for (let i = 0; i < sides; i++) {
                    const ang = (Math.PI * 2 / sides) * i - Math.PI / 2;
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(ang) * rad, Math.sin(ang) * rad);
                    if (l === 0) {
                        const nextAng = (Math.PI * 2 / sides) * (i + 1) - Math.PI / 2;
                        ctx.moveTo(Math.cos(ang) * rad * 0.5, Math.sin(ang) * rad * 0.5);
                        ctx.lineTo(Math.cos(nextAng) * rad, Math.sin(nextAng) * rad);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();

            ctx.globalAlpha = 0.3 + pulse * 0.1;
            ctx.strokeStyle = colorHighLight;
            ctx.lineWidth = 0.5;
            ctx.shadowBlur = 0;
            ctx.beginPath();
            const flareSize = coreSize * 1.5;
            ctx.moveTo(-flareSize, -flareSize); ctx.lineTo(flareSize, flareSize);
            ctx.moveTo(flareSize, -flareSize); ctx.lineTo(-flareSize, flareSize);
            ctx.stroke();
            ctx.restore();

            // --- 9. ダメージエフェクト ---
            if (isDmg && !e.isSpawning) {
                for (let i = 0; i < 4; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const spd = 4 + Math.random() * 10;
                    particles.push({
                        x: e.x + (Math.random() - 0.5) * 40, y: e.y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
                        color: Math.random() > 0.4 ? '#fff' : colorRedNeon, life: 0.5, size: 2 + Math.random() * 2
                    });
                }
            }
            ctx.restore();
        }

        // --- 補助関数: n角形のパスを描く ---
        function drawPolygonPath(ctx, radius, sides) {
            // 頂点が常に上（Y軸マイナス方向）を向くように角度をオフセット
            const offsetAngle = -Math.PI / 2;
            for (let i = 0; i < sides; i++) {
                const theta = (Math.PI * 2 / sides) * i + offsetAngle;
                const x = Math.cos(theta) * radius;
                const y = Math.sin(theta) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
        }

        // --- 極限軽量・高速回転多面体コア（DIAMOND-CORE） ---
        function drawFighterJet(ctx, eb) {
            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);

            const scale = G_SCALE * 1.5;
            const col = '#0FF';

            // 1. 内部コア (サイズを大きくし、存在感を強調)
            const pulse = Math.sin(frame * 0.15) * 2 + 6; // 底上げして最小値を大きく
            ctx.fillStyle = '#F00';
            // 倍率を 0.2 -> 0.35 前後に上げることで、ワイヤーフレーム内の充填率をアップ
            ctx.fillRect(-pulse * 0.35 * scale, -pulse * 0.35 * scale, pulse * 0.7 * scale, pulse * 0.7 * scale);

            // 2. 自転する「正八面体」ワイヤーフレーム
            ctx.strokeStyle = col;
            ctx.lineWidth = 1.0;

            const rot = frame * 0.12; // 回転速度を少しアップ
            const points = [];
            const pCount = 4; // 胴体部分の頂点数（四角形）

            // 頂点計算：胴体（中央のリング）
            for (let i = 0; i < pCount; i++) {
                const lon = (Math.PI * 2 / pCount) * i + rot;
                const py = Math.cos(lon) * 10 * scale;
                const pz = Math.sin(lon); // 奥行き
                points.push({ x: 0, y: py, z: pz });
            }

            // 極点（機首と後部）
            const head = { x: 14 * scale, y: 0, z: 0 };
            const tail = { x: -14 * scale, y: 0, z: 0 };

            // ワイヤー描画
            points.forEach((p, idx) => {
                // 奥行きに応じた透明度
                ctx.globalAlpha = (p.z + 1) / 2 * 0.6 + 0.4;

                // リングの接続（四角形の枠）
                const nextIdx = (idx === pCount - 1) ? 0 : idx + 1;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(points[nextIdx].x, points[nextIdx].y);
                ctx.stroke();

                // 機首への接続
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(head.x, head.y);
                ctx.stroke();

                // 後部への接続
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(tail.x, tail.y);
                ctx.stroke();
            });

            ctx.globalAlpha = 1.0;
        }




        function drawNormalBullet(ctx, eb) {
            ctx.rotate(frame * 0.15);

            const bulletColor = (Math.floor(frame / 5) % 2 === 0) ? '#ff0000' : '#ff8800';
            const size = 7 * G_SCALE;


            ctx.fillStyle = bulletColor;

            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.7, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size * 0.7, 0);
            ctx.closePath();
            ctx.fill();

            // 中心を白くして発光感を出す
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHomingMissile(ctx, eb) {
            // --- 0. フェードアウト処理の反映 ---
            // eb.alpha が定義されている場合はそれを使用し、なければ 1.0 とする
            const currentAlpha = (eb.alpha !== undefined) ? eb.alpha : 1.0;

            // --- 1. ジェット噴射の軌跡（トレイル）を描画 ---
            if (eb.trail && eb.trail.length > 1) {
                ctx.save();
                ctx.translate(-eb.x, -eb.y);

                const trailColor = eb.color || '#f00';
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';

                for (let i = 0; i < eb.trail.length - 1; i++) {
                    const p1 = eb.trail[i];
                    const p2 = eb.trail[i + 1];
                    const ratio = 1 - (i / eb.trail.length);

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);

                    // ① 外側の光（全体の透明度 currentAlpha を掛ける）
                    ctx.strokeStyle = trailColor;
                    ctx.lineWidth = 6 * ratio * G_SCALE;
                    ctx.globalAlpha = 0.2 * ratio * currentAlpha; // ★修正
                    ctx.stroke();

                    // ② 内側の白い芯
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 * ratio * G_SCALE;
                    ctx.globalAlpha = 0.4 * ratio * currentAlpha; // ★修正
                    ctx.stroke();
                }
                ctx.restore();
            }

            // --- 2. ミサイル本体の描画 ---
            ctx.save();
            // 本体描画全体にフェードアウトを適用
            ctx.globalAlpha = currentAlpha; // ★追加

            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);
            const mSize = 12 * G_SCALE;
            const color = eb.color || '#f00';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mSize, 0);
            ctx.lineTo(-mSize, mSize * 0.6);
            ctx.lineTo(-mSize * 0.4, 0);
            ctx.lineTo(-mSize, -mSize * 0.6);
            ctx.closePath();

            // 塗りの透明度はベースの透明度の半分にする
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5 * currentAlpha; // ★修正
            ctx.fill();

            ctx.globalAlpha = currentAlpha; // 線のために戻す
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-mSize * 0.5, 0, 3 * G_SCALE, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawLaserMissile(ctx, eb) {
            const angle = Math.atan2(eb.vy, eb.vx);
            ctx.rotate(angle);

            const len = 40 * G_SCALE;
            const color = eb.color || '#0ff';

            // 加算合成は強力ですが、一回にまとめます
            ctx.globalCompositeOperation = 'lighter';

            // --- 1. 外側の光（厚み） ---
            // lineWidthと不透明度の組み合わせでグローを代用（ぼかしなし）
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 8 * G_SCALE;
            ctx.beginPath();
            ctx.moveTo(-len / 2, 0);
            ctx.lineTo(len / 2, 0);
            ctx.stroke();

            // --- 2. 中心の芯（真っ白） ---
            // 描画ステート（AlphaとWidth）を変更して重ねる
            ctx.strokeStyle = '#fff';
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 3 * G_SCALE;
            ctx.beginPath();
            ctx.moveTo(-len / 2, 0);
            ctx.lineTo(len / 2, 0);
            ctx.stroke();

            // source-overに戻すのは全体の最後、または描画マネージャー側で行うとさらに軽くなります
            ctx.globalCompositeOperation = 'source-over';
        }

        // score map popups
        function drawScorePopups() {
            ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
            scorePopups.forEach(s => { ctx.globalAlpha = s.alpha; ctx.fillText(s.text, s.x, s.y); });
            ctx.globalAlpha = 1.0;
        }

        function drawMiniMap() {
            // プレイ中または死亡演出中以外は非表示
            const container = document.getElementById('minimap-container');
            if (gameState !== 'PLAYING' && gameState !== 'DYING') {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';

            const mSize = 100; // HTMLで指定したサイズ
            const scale = mSize / worldSize; // 変換倍率

            // --- 描画開始 ---
            miniMapCtx.clearRect(0, 0, mSize, mSize);

            // 1. ワールド境界（薄い枠線）
            miniMapCtx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            miniMapCtx.strokeRect(0, 0, mSize, mSize);

            // 2. ワームホール（青い点）
            miniMapCtx.fillStyle = '#22f';
            wormholes.forEach(w => {
                if (w.active) {
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(w.x * scale, w.y * scale, 1.5, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            });

            // 3. 敵の位置
            enemies.forEach(e => {
                if (e.type === 'boss') {
                    // ボス：大きな赤点（点滅）
                    miniMapCtx.fillStyle = (frame % 30 < 15) ? '#f00' : '#fff';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(e.x * scale, e.y * scale, 3.5, 0, Math.PI * 2);
                    miniMapCtx.fill();
                    // ボスのグロー効果
                    miniMapCtx.shadowBlur = 5;
                    miniMapCtx.shadowColor = '#f00';
                } else {
                    // 雑魚敵：小さな紫点
                    miniMapCtx.fillStyle = e.color || '#f0f';
                    miniMapCtx.shadowBlur = 0;
                    miniMapCtx.fillRect(e.x * scale - 1, e.y * scale - 1, 2, 2);
                }
            });

            // 4. 自機の位置（緑の点 + 軽い光）
            miniMapCtx.fillStyle = '#0f0';
            miniMapCtx.shadowBlur = 8;
            miniMapCtx.shadowColor = '#0f0';
            miniMapCtx.beginPath();
            miniMapCtx.arc(player.x * scale, player.y * scale, 2.5, 0, Math.PI * 2);
            miniMapCtx.fill();

            // シャドウ設定をリセット（他への影響を防ぐ）
            miniMapCtx.shadowBlur = 0;
        }

        function updateUI() {
            // --- ★修正: 'boss' だけでなく 'battleship' (ラスボス) も対象にする ---
            const currentBoss = enemies.find(e => e.type === 'boss' || e.type === 'battleship');

            if (currentBoss) {
                ui.bossContainer.style.display = 'block';
                const hpPct = Math.max(0, (currentBoss.hp / currentBoss.maxHp) * 100);
                const bColor = currentBoss.color;

                ui.bossHpBarInline.style.width = hpPct + "%";
                ui.bossHpBarInline.style.backgroundColor = bColor;
                ui.bossHpBarInline.style.boxShadow = `0 0 10px ${bColor}`;
                ui.bossBarFrame.style.borderColor = bColor;
                ui.bossNameLabel.style.color = bColor;

                // ★追加: Battleshipの場合は、専用の名前と色を強制的に適用する
                if (currentBoss.type === 'battleship') {
                    ui.bossNameLabel.innerText = "GENESIS-ARK";
                    ui.bossNameLabel.style.color = "#0ff"; // シアン
                    ui.bossHpBarInline.style.backgroundColor = "#0ff";
                    ui.bossHpBarInline.style.boxShadow = "0 0 10px #0ff";
                    ui.bossBarFrame.style.borderColor = "#0ff";
                } else {
                    ui.bossNameLabel.innerText = currentBoss.variant.name;
                }

                // ピンチ時の点滅演出
                if (hpPct < 25 && frame % 10 < 5) ui.bossHpBarInline.style.backgroundColor = '#fff';
            } else {
                ui.bossContainer.style.display = 'none';
            }

            // ★変更: ステージ9はボス進行度を表示
            if (stage === 9) {
                const progress = rushBossIndex / 8;
                ui.enemyBar.style.width = `${(1 - progress) * 100}%`;
                document.querySelector('.bar-label.enemy').innerText = `BOSS RUSH: ${rushBossIndex}/8`;
            } else {
                const enemyRemains = Math.max(0, enemiesToSpawn - enemiesKilled);
                ui.enemyBar.style.width = `${(enemyRemains / enemiesToSpawn) * 100}%`;
                document.querySelector('.bar-label.enemy').innerText = `ENEMY: ${enemyRemains}`;
            }

            // Shield Bar
            const shieldPercent = Math.max(0, (player.shield / PLAYER_BASE_SHIELD) * 100);
            ui.shieldBar.style.width = shieldPercent + "%";
            if (player.shield < PLAYER_BASE_SHIELD * 0.3) ui.shieldBar.classList.add('shield-critical');
            else ui.shieldBar.classList.remove('shield-critical');
            if (ui.shieldVal) ui.shieldVal.innerText = Math.floor(Math.max(0, player.shield));

            // Weapon Bar
            ui.weaponDisplay.innerHTML = '';
            if (player.laserTimer > 0) {
                const pct = Math.max(0, (player.laserTimer / LASER_DURATION) * 100);
                const frameDiv = document.createElement('div'); frameDiv.className = 'laser-bar-frame';
                const fillDiv = document.createElement('div'); fillDiv.className = 'laser-bar-fill';
                fillDiv.style.width = pct + '%';
                if (player.laserTimer < 120 && Math.floor(frame / 4) % 2 === 0) fillDiv.style.opacity = 0.3;
                frameDiv.appendChild(fillDiv); ui.weaponDisplay.appendChild(frameDiv);
                player.laserTimer--;
            } else {
                for (let i = 1; i <= MAX_WEAPON_LEVEL; i++) {
                    const block = document.createElement('div'); block.className = 'w-block';
                    if (i <= player.weaponLevel) block.classList.add('active');
                    ui.weaponDisplay.appendChild(block);
                }
            }

            // Invuln Bar
            if (player.invuln > 20) {
                ui.invulnWrapper.style.display = 'block';
                const pct = Math.min(100, (player.invuln / INVULN_DURATION) * 100);
                ui.invulnBar.style.width = pct + "%";
                if (player.invuln < 120 && Math.floor(frame / 4) % 2 === 0) ui.invulnBar.style.opacity = 0.3;
                else ui.invulnBar.style.opacity = 1.0;
            } else {
                ui.invulnWrapper.style.display = 'none';
            }

            if (typeof drawMiniMap === 'function') drawMiniMap();
        }

        // エフェクト関連
        function createWallImpact(x, y, color) {
            // 壁に当たった際のエネルギーの火花
            for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * SPEED_SCALE * 15; // 弾の勢いを表現
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    size: 1.5 * G_SCALE,
                    life: 0.3 + Math.random() * 0.2
                });
            }
            // 小さな光のリング
            rings.push({ x: x, y: y, r: 2, color: color, life: 0.3 });
        }

        function createExplosion(x, y, baseColor, n) {
            const count = Math.floor(n * EXPLOSION_COUNT_MAG);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 8 + 2) * EXPLOSION_SPEED_MAG;

                let color;
                const rnd = Math.random();

                // --- 色の決定ロジックを整理 ---
                if (rnd < 0.85) {
                    // 85% は指定されたベースカラー（敵の色）
                    color = baseColor;
                } else {
                    // 残り 15% は「白」または「高輝度な黄色」のみに絞る（火花表現）
                    color = Math.random() > 0.5 ? '#ffffff' : '#ffff00';
                }

                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    size: (Math.random() * 3 + 1) * G_SCALE,
                    life: 1.0 + Math.random() * 0.5
                });
            }
        }

        function drawBossWarningEffect() {
            if (!isBossWarning) return;

            // これから出現するボスの色を取得
            const variantIndex = (stage - 1) % BOSS_VARIANTS.length;
            const bossColor = BOSS_VARIANTS[variantIndex].color;

            // --- 1. 出現予定地点にターゲットサイトを描画 ---
            ctx.save();

            ctx.scale(cameraScale, cameraScale);

            ctx.translate(-camera.x, -camera.y);

            const p = warningTimer / 180;
            ctx.strokeStyle = bossColor;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = bossColor;
            ctx.beginPath();
            ctx.arc(nextBossSpawnX, nextBossSpawnY, 50 + p * 200, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            const crossSize = 10;
            ctx.moveTo(nextBossSpawnX - crossSize, nextBossSpawnY);
            ctx.lineTo(nextBossSpawnX + crossSize, nextBossSpawnY);
            ctx.moveTo(nextBossSpawnX, nextBossSpawnY - crossSize);
            ctx.lineTo(nextBossSpawnX, nextBossSpawnY + crossSize);
            ctx.stroke();
            ctx.restore();

            // --- 2. 警告メッセージの描画 (BOSS HPバーの位置に合わせる) ---
            if (warningTimer > 20 && Math.floor(warningTimer / (WARNING_SOUND_INTERVAL / 2)) % 2 !== 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';

                // 右端の余白設定（CSSのpadding等に合わせる）
                const marginRight = 10;
                const x = width - marginRight;

                // 表示位置：SHIELD(約40px) + ENEMY(約40px) = 80px 以上の高さから開始
                // boss-ui-containerが出る想定位置 (110〜120pxあたり)
                const y = 115;

                // ボスHPバーと同じ幅 (gauge-boxのwidth: 120px)
                const boxW = 120;
                const boxH = 45;

                // 背景ボックス
                ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                ctx.fillRect(x - boxW, y, boxW, boxH);

                // ボスカラーのサイドバー
                ctx.fillStyle = bossColor;
                ctx.fillRect(x - boxW, y, 3, boxH);

                ctx.textAlign = "right";
                ctx.textBaseline = "top";

                // "WARNING !!"
                // 幅に合わせてフォントサイズを微調整 (16px)
                ctx.font = "900 16px Orbitron, sans-serif";
                ctx.fillStyle = "#ff0000";
                ctx.shadowColor = "#ff0000";
                ctx.shadowBlur = 8;
                ctx.fillText("WARNING !!", x - 5, y + 5);

                // サブメッセージ
                ctx.font = "700 8px Orbitron, sans-serif";
                ctx.fillStyle = "#ffffff";
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.8;
                const msg = "BOSS APPROACHING";
                ctx.fillText(msg, x - 5, y + 26);

                ctx.restore();
            }
        }

        // ユーティリティ
        // 補助関数：色から色相(Hue)を取り出す（コードの最後の方に追加してください）
        function getHue(color) {
            if (color.startsWith('#')) {
                // 簡易的な16進数→Hue変換（ボスの主要色に対応）
                if (color === '#f0f') return 300; // マゼンタ
                if (color === '#ffff00') return 60; // 黄
                if (color === '#0f8') return 150; // エメラルド
                if (color === '#0cc') return 180; // シアン
                if (color === '#44f') return 240; // 青
                if (color === '#f40') return 20;  // オレンジ赤
                if (color === '#f08') return 330; // ローズ
                if (color === '#fff') return 0;   // 白
            }
            return 0;
        }


        // =========================================================
        // 11. 入力・イベントリスナー (Input & Event Listeners)
        // =========================================================
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) setPaused(true); else setPaused(false);
        });

        window.addEventListener('blur', () => setPaused(true));
        window.addEventListener('focus', () => setPaused(false));

        const resumeAction = (e) => {
            if (e) e.preventDefault();
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                ui.pauseOverlay.style.display = 'none';
                AudioSys.resumeBGM();
            }
        };

        ui.pauseOverlay.addEventListener('click', resumeAction);
        ui.pauseOverlay.addEventListener('touchstart', resumeAction, { passive: false });

        function handleTouch(e) {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.move.active = false; input.aim.active = false;

            const lR = ui.stickL.getBoundingClientRect(); const rR = ui.stickR.getBoundingClientRect();
            const lC = { x: lR.left + lR.width / 2, y: lR.top + lR.height / 2 };
            const rC = { x: rR.left + rR.width / 2, y: rR.top + rR.height / 2 };

            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                const dL = Math.hypot(t.clientX - lC.x, t.clientY - lC.y);
                const dR = Math.hypot(t.clientX - rC.x, t.clientY - rC.y);

                if (dL < 100) {
                    input.move.active = true; const a = Math.atan2(t.clientY - lC.y, t.clientX - lC.x); const d = Math.min(dL, 40);
                    input.move.x = Math.cos(a) * (d / 40); input.move.y = Math.sin(a) * (d / 40);
                    ui.knobL.style.transform = `translate(${input.move.x * 40}px,${input.move.y * 40}px)`;
                } else if (dR < 100) {
                    input.aim.active = true; const a = Math.atan2(t.clientY - rC.y, t.clientX - rC.x); const d = Math.min(dR, 40);
                    input.aim.x = Math.cos(a) * (d / 40); input.aim.y = Math.sin(a) * (d / 40);
                    ui.knobR.style.transform = `translate(${input.aim.x * 40}px,${input.aim.y * 40}px)`;
                }
            }
            if (!input.move.active) { input.move.x = 0; input.move.y = 0; ui.knobL.style.transform = 'translate(0,0)'; }
            if (!input.aim.active) { input.aim.x = 0; input.aim.y = 0; ui.knobR.style.transform = 'translate(0,0)'; }
        }

        ui.launchBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            launchSatellites();
            ui.launchBtn.classList.add('active');
            setTimeout(() => ui.launchBtn.classList.remove('active'), 100);
        });
        ui.controls.addEventListener('touchstart', handleTouch, { passive: false });
        ui.controls.addEventListener('touchmove', handleTouch, { passive: false });
        ui.controls.addEventListener('touchend', handleTouch, { passive: false });

        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-ost').onclick = openOST;
        document.getElementById('btn-back').onclick = closeOST;

        window.addEventListener('keydown', e => {
            if (document.activeElement === document.getElementById('player-name-input')) return;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyZ', 'KeyX'].includes(e.code)) e.preventDefault();
            input.keys[e.code] = true;
            if (gameState === 'TITLE' && e.code === 'Space') startGame();
            if (gameState === 'PLAYING' && e.code === 'KeyX') launchSatellites();
        });
        window.addEventListener('keyup', e => input.keys[e.code] = false);
        window.addEventListener('resize', resize);


        let isInit = false;
        const handleInteraction = () => {
            if (isInit) return;
            isInit = true;
            AudioSys.resume();

            document.removeEventListener('click', handleInteraction);
            document.removeEventListener('touchstart', handleInteraction);
            document.removeEventListener('keydown', handleInteraction);
        };


        document.addEventListener('click', handleInteraction);
        document.addEventListener('touchstart', handleInteraction);
        document.addEventListener('keydown', handleInteraction);

        // ゲームパッド制御用
        function handleGamepadInput() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let activeGp = null;

            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    activeGp = gamepads[i];
                    break;
                }
            }

            if (!activeGp) return;

            // --- 【重要】コントローラーが接続されているなら画面UIを隠す ---
            // プレイ中かつ、UIが表示されている場合のみ非表示に切り替える
            if (gameState === 'PLAYING' && ui.controls.style.display !== 'none') {
                ui.controls.style.display = 'none';
            }

            // --- 左スティック: 移動 ---
            const moveX = activeGp.axes[0];
            const moveY = activeGp.axes[1];
            const moveDeadzone = 0.2;

            if (Math.abs(moveX) > moveDeadzone || Math.abs(moveY) > moveDeadzone) {
                input.move.active = true;
                input.move.x = moveX;
                input.move.y = moveY;
            } else {
                // スティックが倒されていないときは入力を止める（タッチ操作との干渉防止）
                if (input.move.active && !input.keys['ArrowLeft']) { // キーボード優先なら条件追加
                    input.move.x = 0;
                    input.move.y = 0;
                    input.move.active = false;
                }
            }

            // --- 右スティック: 照準 ---
            const aimX = activeGp.axes[2];
            const aimY = activeGp.axes[3];
            const aimDeadzone = 0.2;

            if (Math.abs(aimX) > aimDeadzone || Math.abs(aimY) > aimDeadzone) {
                input.aim.active = true;
                input.aim.x = aimX;
                input.aim.y = aimY;
            } else {
                input.aim.active = false;
            }

            // --- ボタン入力: BOMB/LAUNCH ---
            const bombBtn = activeGp.buttons[2].pressed || activeGp.buttons[5].pressed || activeGp.buttons[7].pressed;
            if (bombBtn && !input.padBombPressed) {
                if (gameState === 'PLAYING') launchSatellites();
                if (gameState === 'TITLE') startGame();
            }
            input.padBombPressed = bombBtn;

            // ポーズ解除
            if (activeGp.buttons[0].pressed && gameState === 'PAUSED') {
                resumeAction();
            }
        }

        // 接続イベント
        window.addEventListener("gamepadconnected", (e) => {
            console.log("Gamepad connected: " + e.gamepad.id);
            // プレイ中なら即座にUIを消す
            if (gameState === 'PLAYING') {
                ui.controls.style.display = 'none';
            }
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            console.log("Gamepad disconnected");
            // プレイ中ならタッチUIを復活させる
            if (gameState === 'PLAYING') {
                ui.controls.style.display = 'block';
            }
            // 入力リセット
            input.move.x = 0; input.move.y = 0;
            input.move.active = false; input.aim.active = false;
        });

        init(); loop();
    </script>
</body>

</html>
