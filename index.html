<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON GRAVITY: CORRECTED</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; background: #050505; overflow: hidden; 
            font-family: 'Orbitron', monospace; color: #fff; 
            user-select: none; -webkit-user-select: none; touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; position: absolute; top:0; left:0; z-index: 1; }
        
        /* UI Layer */
        #ui { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            display: flex; flex-direction: column; padding: 10px; box-sizing: border-box;
        }
        .hud-row { display: flex; justify-content: space-between; width: 100%; max-width: 800px; margin: 0 auto; }
        #score-display { font-size: 24px; color: #0ff; text-shadow: 0 0 10px #0ff; }
        
        #shield-wrapper { width: 140px; text-align: right; pointer-events: auto; }
        #shield-container { width: 100%; height: 8px; border: 1px solid #0ff; background: rgba(0,20,40,0.8); margin-top: 5px; }
        #shield-bar { width: 100%; height: 100%; background: #0ff; transition: width 0.1s; }
        .shield-critical { animation: blink 0.2s infinite; background: #f00 !important; }

        #progress-bar {
            position: absolute; bottom: 10px; left: 10%; width: 80%; height: 4px; background: #333;
        }
        #progress-fill { height: 100%; width: 0%; background: #f0f; box-shadow: 0 0 5px #f0f; transition: width 0.5s; }

        /* Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto;
        }
        .menu-btn {
            background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; color: #0ff;
            padding: 20px 50px; margin: 15px; font-size: 22px; font-family: 'Orbitron';
            cursor: pointer; min-width: 240px; text-align: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        .menu-btn:active { background: #0ff; color: #000; transform: scale(0.95); }

        /* OST */
        #ost-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 110; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .track-item { padding: 20px; width: 80%; border-bottom: 1px solid #333; color: #888; text-align: center; font-size: 18px; }
        .track-item.playing { color: #0ff; border-color: #0ff; }

        /* Controls */
        #controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 50; display: none; touch-action: none; pointer-events: auto;
        }
        .joystick-area {
            position: absolute; width: 120px; height: 120px;
            border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255,255,255,0.05);
            display: flex; justify-content: center; align-items: center; pointer-events: none;
        }
        .knob {
            width: 50px; height: 50px; border-radius: 50%; background: rgba(255, 255, 255, 0.5); 
            position: absolute; transform: translate(0, 0); transition: transform 0.05s;
        }
        
        /* Guide Text for Mobile */
        #mobile-hint {
            position: absolute; top: 20%; width: 100%; text-align: center; color: rgba(255,255,255,0.3);
            font-size: 14px; pointer-events: none; display: none;
        }

        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="ui">
    <div class="hud-row">
        <div>
            <div id="score-display">000000</div>
            <div style="font-size:12px; color:#aaa;">STAGE: <span id="stage-num">1</span></div>
            <div style="font-size:12px; color:#aaa;">WEAPON: <span id="w-lv">1</span></div>
        </div>
        <div id="shield-wrapper">
            <span style="font-size:10px; color:#0ff;">SHIELD</span>
            <div id="shield-container"><div id="shield-bar"></div></div>
        </div>
    </div>
    <div id="warning-msg" style="display:none; color:#f00; width:100%; text-align:center; margin-top:20%; font-size:20px; animation:blink 0.2s infinite;">GRAVITY CRITICAL</div>
    <div id="stage-msg" style="display:none; color:#fff; width:100%; text-align:center; margin-top:30%; font-size:40px; text-shadow:0 0 20px #0ff;">STAGE CLEAR</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>
</div>

<div id="mobile-hint">TAP UPPER SCREEN TO BOMB</div>

<div id="overlay">
    <h1 style="color:#0ff; font-size:40px; margin-bottom:40px; text-shadow:0 0 20px #0ff; text-align:center;">NEON GRAVITY<br><span style="font-size:20px;color:#fff;">CORRECTED</span></h1>
    <div class="menu-btn" id="btn-start">START GAME</div>
    <div class="menu-btn" id="btn-ost">SOUNDTRACK</div>
    <div style="margin-top:20px; font-size:12px; color:#888;">PC: [ARROWS] Move [SPACE] Shoot [Z] Bomb<br>MOBILE: Sticks to Move/Aim, Tap Top to Bomb</div>
</div>

<div id="ost-ui">
    <h2 style="color:#0ff;">SOUNDTRACK</h2>
    <div id="track-list" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
    <div class="menu-btn" id="btn-back" style="margin-top:20px;">BACK</div>
</div>

<div id="controls">
    <div id="stick-left" class="joystick-area"><div class="knob" id="knob-left"></div></div>
    <div id="stick-right" class="joystick-area"><div class="knob" id="knob-right"></div></div>
</div>

<canvas id="game"></canvas>

<script>
// --- Settings ---
const G_SCALE = 0.7; 
const SPEED_SCALE = 0.25; 
const WALL_MARGIN = 5; 
const MAX_WEAPON_LEVEL = 5;
const GRID_SPACING = 30;

// --- DOM References ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = {
    overlay: document.getElementById('overlay'), ost: document.getElementById('ost-ui'),
    controls: document.getElementById('controls'), score: document.getElementById('score-display'),
    stage: document.getElementById('stage-num'), wLv: document.getElementById('w-lv'),
    shieldBar: document.getElementById('shield-bar'), msg: document.getElementById('stage-msg'),
    warn: document.getElementById('warning-msg'), hint: document.getElementById('mobile-hint'),
    knobL: document.getElementById('knob-left'), knobR: document.getElementById('knob-right'),
    stickL: document.getElementById('stick-left'), stickR: document.getElementById('stick-right'),
    prog: document.getElementById('progress-fill')
};

// --- Game State ---
let width, height;
let gameRect = { x: 0, y: 0, w: 0, h: 0 }; 

let gameState = 'TITLE'; 
let score = 0, frame = 0, stage = 1;
let spawnedCount = 0, enemiesToSpawn = 0, isStageClear = false;
let killCount = 0;

const player = { x:0, y:0, vx:0, vy:0, angle:0, satellites:[], shield:100, weaponLevel:1, invuln:0 };
const input = { move:{x:0,y:0,active:false}, aim:{x:0,y:0,active:false}, keys:{} };

let bullets=[], enemies=[], enemyBullets=[], particles=[], crystals=[], missiles=[], powerups=[], wormholes=[], scorePopups=[], gridPoints=[], rings=[];

// --- Audio ---
const BGM_FILES = {
    title: 'audio/Neo_Gravity_Title.mp3', clear: 'audio/Neo_Gravity_Clear.mp3',
    stages: ['audio/Neo_Gravity_00.mp3','audio/Neo_Gravity_01.mp3','audio/Neo_Gravity_02.mp3','audio/Neo_Gravity_03.mp3']
};

const AudioSys = {
    ctx: null, bgmEl: null, currentSrc: null, noiseBuffer: null,
    init() {
        if(!this.ctx) {
            try { const AC = window.AudioContext || window.webkitAudioContext; if(AC) { this.ctx = new AC(); this.createNoise(); } } catch(e){}
        }
        if(!this.bgmEl) { this.bgmEl = new Audio(); this.bgmEl.loop = true; this.bgmEl.volume = 0.4; }
    },
    resume() { if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(()=>{}); },
    createNoise() {
        if(!this.ctx) return;
        const bSize = this.ctx.sampleRate * 2;
        const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bSize; i++) data[i] = Math.random()*2-1;
        this.noiseBuffer = buf;
    },
    playSE(type) {
        if(!this.ctx) return;
        this.resume();
        const t = this.ctx.currentTime;
        const g = this.ctx.createGain(); g.connect(this.ctx.destination);
        if(type==='shoot'){
            const o=this.ctx.createOscillator(); o.type='triangle'; 
            o.frequency.setValueAtTime(800,t); o.frequency.exponentialRampToValueAtTime(100,t+0.1);
            g.gain.setValueAtTime(0.2,t); g.gain.linearRampToValueAtTime(0,t+0.1);
            o.connect(g); o.start(t); o.stop(t+0.1);
        } else if(type==='explode'){
            if(this.noiseBuffer) {
                const n=this.ctx.createBufferSource(); n.buffer=this.noiseBuffer;
                const f=this.ctx.createBiquadFilter(); f.type='lowpass';
                f.frequency.setValueAtTime(600,t); f.frequency.exponentialRampToValueAtTime(20,t+0.5);
                g.gain.setValueAtTime(0.6,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.5);
                n.connect(f); f.connect(g); n.start(t); n.stop(t+0.5);
            }
        } else if(type==='dragon_explode'){ 
            if(this.noiseBuffer) {
                const n=this.ctx.createBufferSource(); n.buffer=this.noiseBuffer;
                const f=this.ctx.createBiquadFilter(); f.type='lowpass';
                f.frequency.setValueAtTime(200,t); f.frequency.linearRampToValueAtTime(10,t+1.5);
                g.gain.setValueAtTime(0.8,t); g.gain.exponentialRampToValueAtTime(0.01,t+1.5);
                n.connect(f); f.connect(g); n.start(t); n.stop(t+1.5);
            }
        } else if(type==='launch'){
            const o=this.ctx.createOscillator(); o.type='square';
            o.frequency.setValueAtTime(200,t); o.frequency.linearRampToValueAtTime(600,t+0.4);
            g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.4);
            o.connect(g); o.start(t); o.stop(t+0.4);
        } else if(type==='powerup'){
            const o=this.ctx.createOscillator(); o.type='sine';
            o.frequency.setValueAtTime(600,t); o.frequency.linearRampToValueAtTime(1800,t+0.2);
            g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.2);
            o.connect(g); o.start(t); o.stop(t+0.2);
        } else if(type==='damage'){ 
            const o=this.ctx.createOscillator(); o.type='sawtooth';
            o.frequency.setValueAtTime(150,t); o.frequency.linearRampToValueAtTime(50,t+0.2);
            g.gain.setValueAtTime(0.4,t); g.gain.linearRampToValueAtTime(0,t+0.2);
            o.connect(g); o.start(t); o.stop(t+0.2);
        } else if(type==='invincible'){ 
            const o=this.ctx.createOscillator(); o.type='sine';
            o.frequency.setValueAtTime(300,t); o.frequency.linearRampToValueAtTime(800,t+0.5);
            g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.5);
            o.connect(g); o.start(t); o.stop(t+0.5);
        }
    },
    playBGM(key, idx=0) {
        if(!this.bgmEl) return;
        let src = "";
        if(key==='title') src = BGM_FILES.title;
        else if(key==='clear') src = BGM_FILES.clear;
        else if(key==='stage') src = BGM_FILES.stages[idx % BGM_FILES.stages.length];
        if(this.currentSrc === src && !this.bgmEl.paused) return;
        this.bgmEl.src = src; this.bgmEl.currentTime = 0; this.bgmEl.play().catch(e=>{ console.warn("BGM Error:", e); });
        this.currentSrc = src;
    },
    stopBGM() { if(this.bgmEl) this.bgmEl.pause(); }
};

// --- Layout & Init ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    
    const isPortrait = height > width;
    if (isPortrait) {
        gameRect = { x: 0, y: 0, w: width, h: height * 0.75 };
        ui.stickL.style.left = '40px'; ui.stickL.style.bottom = '50px'; ui.stickL.style.right = 'auto';
        ui.stickR.style.right = '40px'; ui.stickR.style.bottom = '50px'; ui.stickR.style.left = 'auto';
        ui.hint.style.display = 'block';
    } else {
        const margin = 160; 
        gameRect = { x: margin, y: 0, w: width - (margin*2), h: height };
        ui.stickL.style.left = '20px'; ui.stickL.style.bottom = '40px';
        ui.stickR.style.right = '20px'; ui.stickR.style.bottom = '40px';
        ui.hint.style.display = 'none';
    }
    initGrid();
}

function initGrid() {
    const gW = Math.max(width, gameRect.w || width);
    const gH = Math.max(height, gameRect.h || height);
    const cols = Math.ceil(gW/GRID_SPACING)+2;
    const rows = Math.ceil(gH/GRID_SPACING)+2;
    
    gridPoints = [];
    for(let x=0; x<=cols; x++) {
        gridPoints[x]=[];
        for(let y=0; y<=rows; y++) gridPoints[x][y]={x:x*GRID_SPACING, y:y*GRID_SPACING, ox:x*GRID_SPACING, oy:y*GRID_SPACING, vx:0, vy:0};
    }
}

function init() {
    resize();
    AudioSys.init();
    AudioSys.playBGM('title');
}

window.addEventListener('resize', resize);

// --- Game Logic ---
function startGame() {
    AudioSys.init(); AudioSys.resume(); AudioSys.playBGM('stage', 0);
    gameState = 'PLAYING';
    ui.overlay.style.display = 'none'; ui.ost.style.display = 'none'; 
    document.getElementById('controls').style.display = 'block'; 
    document.getElementById('stick-left').style.display = 'flex';
    document.getElementById('stick-right').style.display = 'flex';
    
    score = 0; stage = 1; frame = 0;
    
    player.x = gameRect.x + gameRect.w/2; 
    player.y = gameRect.y + gameRect.h/2; 
    player.vx=0; player.vy=0; 
    player.shield=100; player.weaponLevel=1; player.satellites=[]; player.invuln=0;
    
    ui.score.innerText = "000000"; ui.stage.innerText = "1"; ui.wLv.innerText = "1"; 
    ui.shieldBar.style.width = "100%"; ui.shieldBar.classList.remove('shield-critical');
    ui.shieldBar.style.backgroundColor = '#0ff';
    ui.warn.style.display = 'none';

    startStage();
}

function startStage() {
    enemiesToSpawn = 30 + (stage * 15); 
    spawnedCount = 0; isStageClear = false; killCount = 0;
    ui.msg.style.display = 'none';
    bullets=[]; enemies=[]; enemyBullets=[]; crystals=[]; missiles=[]; powerups=[]; wormholes=[]; scorePopups=[]; rings=[];
    if(stage > 1) AudioSys.playBGM('stage', stage - 1);

    // Initial Wormholes
    const whCount = Math.max(1, Math.floor((stage+1)/2)); 
    for(let i=0; i<whCount; i++) {
        spawnWormhole();
    }
}

function spawnWormhole() {
    // 寿命: 400フレーム (約6.6秒)
    wormholes.push({ 
        x: gameRect.x + 50 + Math.random()*(gameRect.w - 100), 
        y: gameRect.y + 50 + Math.random()*(gameRect.h - 100), 
        life: 400, 
        maxLife: 400,
        active: true 
    });
    distortGrid(wormholes[wormholes.length-1].x, wormholes[wormholes.length-1].y, 50, 150);
}

function loop() {
    requestAnimationFrame(loop);
    ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
    if(gameState === 'PLAYING') update();
    draw();
}

function update() {
    frame++;
    if(!Number.isFinite(player.x) || !Number.isFinite(player.y)) { 
        player.x=gameRect.x+gameRect.w/2; player.y=gameRect.y+gameRect.h/2; player.vx=0; player.vy=0; 
    }

    // Controls
    let mx = input.keys['ArrowLeft']?-1:input.keys['ArrowRight']?1:input.move.x;
    let my = input.keys['ArrowUp']?-1:input.keys['ArrowDown']?1:input.move.y;
    
    const moveSpeed = 6.0 * SPEED_SCALE;
    player.vx = mx * moveSpeed; 
    player.vy = my * moveSpeed;
    player.x += player.vx; player.y += player.vy;

    // Wall Collision
    if(player.x < gameRect.x + WALL_MARGIN) { player.x = gameRect.x + WALL_MARGIN; player.vx = 0; }
    if(player.x > gameRect.x + gameRect.w - WALL_MARGIN) { player.x = gameRect.x + gameRect.w - WALL_MARGIN; player.vx = 0; }
    if(player.y < gameRect.y + WALL_MARGIN) { player.y = gameRect.y + WALL_MARGIN; player.vy = 0; }
    if(player.y > gameRect.y + gameRect.h - WALL_MARGIN) { player.y = gameRect.y + gameRect.h - WALL_MARGIN; player.vy = 0; }

    // Aim
    if(input.aim.active) player.angle = Math.atan2(input.aim.y, input.aim.x);
    else if(Math.hypot(mx,my) > 0.1) player.angle = Math.atan2(my, mx);

    if((input.aim.active || input.keys['Space'] || input.keys['KeyZ']) && frame % 10 === 0) fire();

    // Wormholes Logic (Spawn -> Emit -> Vanish)
    // New Wormhole check (ワームホールが減ってきたら追加)
    if (spawnedCount < enemiesToSpawn && wormholes.filter(w=>w.active).length < (1+Math.floor(stage/2)) && Math.random() < 0.01) {
        spawnWormhole();
    }

    wormholes.forEach((w) => {
        w.life--; // バグ修正: 常に減らす
        
        if (w.active) {
            // Spawn Enemy Periodically
            if (w.life > 60 && w.life % 60 === 0 && spawnedCount < enemiesToSpawn) {
                spawnEnemy(w.x, w.y);
                spawnedCount++;
                distortGrid(w.x, w.y, 10, 80);
            }
            // Repulsion
            const dx = player.x - w.x; const dy = player.y - w.y;
            const d = Math.hypot(dx, dy) || 0.01;
            if (d < 180) { 
                const f = 500 / (d + 1);
                player.x += (dx/d) * f * 0.01; player.y += (dy/d) * f * 0.01;
            }
        }

        // 自然消滅
        if (w.life <= 0) w.active = false;
    });
    // フェードアウト用に少し残す
    wormholes = wormholes.filter(w => w.life > -60);

    // Satellites
    player.satellites.forEach((s,i) => {
        s.angle = (s.angle||0) + 0.15;
        const rad = 45 * G_SCALE;
        const off = (Math.PI*2/player.satellites.length)*i;
        s.x = player.x + Math.cos(s.angle+off)*rad; s.y = player.y + Math.sin(s.angle+off)*rad;
    });

    updateEntities();
    updateGrid();
    updateScorePopups();
    
    // Progress based on Kill Count
    const progress = Math.min(100, (killCount / enemiesToSpawn) * 100);
    ui.prog.style.width = `${progress}%`;

    // Clear Condition: Kill all enemies
    // ワームホールは無視、出現数が出尽くして、かつ敵が全滅したらクリア
    if(spawnedCount >= enemiesToSpawn && enemies.length === 0 && !isStageClear) {
        isStageClear = true; ui.msg.style.display = 'block';
        AudioSys.playBGM('clear');
        setTimeout(() => { stage++; ui.stage.innerText = stage; startStage(); }, 4000);
    }

    if(player.shield < 30) ui.shieldBar.classList.add('shield-critical');
    else ui.shieldBar.classList.remove('shield-critical');
}

function fire() {
    const s = 12 * SPEED_SCALE;
    for(let i=0; i<player.weaponLevel; i++) {
        const a = player.angle + (i-(player.weaponLevel-1)/2)*0.1;
        bullets.push({x:player.x, y:player.y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:240});
    }
    AudioSys.playSE('shoot');
    distortGrid(player.x, player.y, 10, 40);
}

function spawnEnemy(x, y) {
    const r = Math.random();
    const spd = SPEED_SCALE;
    const ox = (Math.random()-0.5)*30; const oy = (Math.random()-0.5)*30;
    
    if (r < 0.1) { // Dragon (Slower speed)
        let e = {x:x+ox, y:y+oy, vx:0, vy:0, hp:8, speed:1.5*spd, color:'#f00', type:'dragon', angle:0, segments:[], drop:'invincible', scale:0.9, fireTimer:0};
        for(let i=0; i<16; i++) e.segments.push({x:x+ox, y:y+oy, angle:0});
        enemies.push(e);
    } else {
        if(r < 0.5) { // Triangle
            let e = {x:x+ox, y:y+oy, vx:0, vy:0, hp:1, speed:3.0*spd, color:'#fa0', type:'triangle', angle:0, drop:'none', scale:0.7};
            enemies.push(e);
        } else { // Rhombus
            let e = {x:x+ox, y:y+oy, vx:0, vy:0, hp:2, speed:1.5*spd, color:'#0ff', type:'rhombus', angle:0, drop:'crystal', scale:0.8, rot:0};
            enemies.push(e);
        }
    }
}

function updateEntities() {
    bullets.forEach(b => {
        b.x+=b.vx; b.y+=b.vy; b.life--;
        enemies.forEach(e => { if(Math.hypot(b.x-e.x, b.y-e.y)<20 * e.scale){ b.life=0; e.hp--; } });
    });
    bullets = bullets.filter(b => b.life>0);

    enemies.forEach(e => {
        const dx=player.x-e.x, dy=player.y-e.y;
        const d=Math.hypot(dx,dy) || 0.0001;
        
        let speedMult = 0.1;
        if(e.type === 'triangle') speedMult = 0.15;
        if(e.type === 'rhombus') speedMult = 0.05;

        e.vx += (dx/d)*speedMult*SPEED_SCALE; e.vy += (dy/d)*speedMult*SPEED_SCALE;
        e.x+=e.vx + Math.cos(e.angle)*e.speed; e.y+=e.vy + Math.sin(e.angle)*e.speed;
        
        // Bounce within gameRect
        if(e.x < gameRect.x + WALL_MARGIN || e.x > gameRect.x + gameRect.w - WALL_MARGIN) e.vx *= -1.2;
        if(e.y < gameRect.y + WALL_MARGIN || e.y > gameRect.y + gameRect.h - WALL_MARGIN) e.vy *= -1.2;
        e.x = Math.max(gameRect.x+WALL_MARGIN, Math.min(gameRect.x+gameRect.w-WALL_MARGIN, e.x));
        e.y = Math.max(gameRect.y+WALL_MARGIN, Math.min(gameRect.y+gameRect.h-WALL_MARGIN, e.y));

        if(e.type==='dragon') {
            e.angle = Math.atan2(dy, dx);
            let lx=e.x, ly=e.y;
            e.segments.forEach(s => { const dd=Math.hypot(lx-s.x, ly-s.y); if(dd>10*G_SCALE*e.scale){ s.x+=(lx-s.x)*0.3; s.y+=(ly-s.y)*0.3; } lx=s.x; ly=s.y; });
            e.fireTimer++;
            if(e.fireTimer>100) { e.fireTimer=0; enemyBullets.push({x:e.x, y:e.y, vx:Math.cos(e.angle)*4*SPEED_SCALE, vy:Math.sin(e.angle)*4*SPEED_SCALE, life:200}); AudioSys.playSE('shoot'); }
        } else if(e.type==='rhombus') {
            e.angle = Math.atan2(e.vy, e.vx); e.rot = (e.rot || 0) + 0.1;
        } else {
            e.angle = Math.atan2(e.vy, e.vx);
        }

        if(d < 20 && player.invuln <= 0) { damage(20); if(e.type!=='dragon') e.hp=0; }
        
        for(let i=player.satellites.length-1; i>=0; i--){
            const s=player.satellites[i];
            if(Math.hypot(s.x-e.x, s.y-e.y)<25) { e.hp=0; player.satellites.splice(i,1); e.noDrop=true; break; }
        }
        if(e.hp<=0) destroyEnemy(e);
    });
    enemies = enemies.filter(e => e.hp > 0);

    enemyBullets.forEach(eb => {
        eb.x+=eb.vx; eb.y+=eb.vy; eb.life--;
        if(Math.hypot(player.x-eb.x, player.y-eb.y)<15 && player.invuln<=0) { damage(15); eb.life=0; createExplosion(player.x, player.y, '#f00', 10); }
    });
    enemyBullets = enemyBullets.filter(eb => eb.life>0);

    crystals.forEach(c => {
        const dx=player.x-c.x, dy=player.y-c.y;
        const d=Math.hypot(dx,dy) || 0.0001;
        const factor = 0.03 + (d * 0.0005); 
        c.x += dx * factor; c.y += dy * factor;
        if(d < 20) { c.life=0; if(player.satellites.length<12) player.satellites.push({}); }
    });
    crystals = crystals.filter(c => c.life > 0);

    powerups.forEach(p => {
        if(Math.hypot(player.x-p.x, player.y-p.y)<25) {
            p.life=0;
            if(p.type==='level') { if(player.weaponLevel<MAX_WEAPON_LEVEL) player.weaponLevel++; ui.wLv.innerText=player.weaponLevel; AudioSys.playSE('powerup'); }
            else { player.invuln=600; player.shield=Math.min(100,player.shield+50); ui.shieldBar.style.width=player.shield+"%"; AudioSys.playSE('invincible'); }
            createExplosion(player.x, player.y, '#0ff', 20);
        }
    });
    powerups = powerups.filter(p => p.life>0);

    missiles.forEach(m => {
        if(!m.target || !enemies.includes(m.target)) {
            let min=9999; enemies.forEach(e=>{const d=Math.hypot(e.x-m.x,e.y-m.y); if(d<min){min=d; m.target=e;}});
        }
        if(m.target) { const ta=Math.atan2(m.target.y-m.y, m.target.x-m.x); m.vx+=Math.cos(ta)*0.5; m.vy+=Math.sin(ta)*0.5; }
        const s=Math.hypot(m.vx,m.vy); if(s>0.001){m.vx=(m.vx/s)*m.speed; m.vy=(m.vy/s)*m.speed;} 
        m.x+=m.vx; m.y+=m.vy; m.life--;
        enemies.forEach(e=>{ if(Math.hypot(e.x-m.x,e.y-m.y)<30){e.hp-=10; m.life=0; if(e.hp<=0) destroyEnemy(e);} });
        particles.push({x:m.x, y:m.y, vx:(Math.random()-0.5), vy:(Math.random()-0.5), color:'#fd0', life:0.3});
    });
    missiles = missiles.filter(m => m.life>0);

    particles.forEach(p => { 
        p.x+=p.vx; p.y+=p.vy; 
        p.vx *= 0.92; p.vy *= 0.92; p.vy += 0.005; 
        p.life-=0.02; 
    });
    particles = particles.filter(p => p.life>0);
    
    rings.forEach(r => { r.r += 2; r.life -= 0.02; });
    rings = rings.filter(r => r.life > 0);

    if(player.invuln > 0) { player.invuln--; ui.shieldBar.style.backgroundColor = (Math.floor(frame/4)%2===0)?'#ff0':'#0ff'; }
    else ui.shieldBar.style.backgroundColor = '#0ff';
}

function updateScorePopups() {
    scorePopups.forEach(s => { s.y += s.vy; s.life--; s.alpha = s.life / 30; });
    scorePopups = scorePopups.filter(s => s.life > 0);
}

function destroyEnemy(e) {
    createExplosion(e.x, e.y, e.color, 40); 
    if(e.type === 'dragon') {
        rings.push({x:e.x, y:e.y, r:10, color:'#f00', life:1});
        rings.push({x:e.x, y:e.y, r:5, color:'#fff', life:1});
        AudioSys.playSE('dragon_explode');
    } else {
        AudioSys.playSE('explode');
    }
    
    killCount++;
    const pts = e.type === 'dragon' ? 1000 : 100;
    score+=pts; ui.score.innerText=score.toString().padStart(6,'0');
    scorePopups.push({x:e.x, y:e.y, text:pts, life:40, alpha:1, vy:-1});
    distortGrid(e.x, e.y, 40, 80);
    if(e.noDrop || e.drop === 'none') return;
    if(e.drop==='invincible') powerups.push({x:e.x, y:e.y, type:'invincible', life:1000});
    else if(e.drop==='level' || Math.random()<0.05) powerups.push({x:e.x, y:e.y, type:'level', life:1000});
    else crystals.push({x:e.x, y:e.y, life:1000});
}

function damage(v) {
    player.shield-=v; player.invuln=60;
    ui.shieldBar.style.width=Math.max(0,player.shield)+"%";
    AudioSys.playSE('damage'); distortGrid(player.x, player.y, 50, 100);
    if(player.shield<=0) {
        gameState='GAMEOVER'; ui.overlay.style.display='flex';
        ui.overlay.innerHTML = `<h1>GAME OVER</h1><p>SCORE: ${score}</p><div class="menu-btn" onclick="location.reload()">RETRY</div>`;
        ui.controls.style.display='none';
        AudioSys.stopBGM();
    }
}

function draw() {
    ctx.save();
    ctx.beginPath(); ctx.rect(gameRect.x, gameRect.y, gameRect.w, gameRect.h); ctx.clip();

    ctx.strokeStyle='rgba(0, 255, 255, 0.2)'; ctx.lineWidth=1; ctx.shadowBlur=5; ctx.shadowColor='#0ff'; ctx.beginPath(); 
    const startCol = Math.floor(gameRect.x / GRID_SPACING);
    const endCol = Math.ceil((gameRect.x + gameRect.w) / GRID_SPACING);
    const startRow = Math.floor(gameRect.y / GRID_SPACING);
    const endRow = Math.ceil((gameRect.y + gameRect.h) / GRID_SPACING);

    for(let i=startCol; i<=endCol; i++) {
        if(!gridPoints[i]) continue;
        for(let j=startRow; j<=endRow; j++) {
            const p=gridPoints[i][j];
            if(!p) continue;
            if(i>startCol && gridPoints[i-1] && gridPoints[i-1][j]) { ctx.moveTo(gridPoints[i-1][j].x, gridPoints[i-1][j].y); ctx.lineTo(p.x, p.y); }
            if(j>startRow && gridPoints[i][j-1]) { ctx.moveTo(gridPoints[i][j-1].x, gridPoints[i][j-1].y); ctx.lineTo(p.x, p.y); }
        }
    }
    ctx.stroke(); ctx.shadowBlur=0; 

    ctx.strokeStyle='#0ff'; ctx.lineWidth=3; ctx.strokeRect(gameRect.x+2, gameRect.y+2, gameRect.w-4, gameRect.h-4);

    wormholes.forEach(w => { if(w.active || w.life > -60){ 
        // Fade logic fixed
        let scale = 1;
        if (w.life > 300) scale = (400-w.life)/100; // In (Faster)
        else if (w.life <= 0) scale = Math.max(0, (60+w.life)/60); // Out (Fade)

        ctx.save(); ctx.translate(w.x, w.y); ctx.scale(scale, scale);
        ctx.shadowBlur=20; ctx.shadowColor='#fff'; 
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0, 0, 15+Math.sin(frame*0.2)*5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.beginPath(); ctx.arc(0, 0, 30+Math.sin(frame*0.1)*10, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
    }});
    
    enemies.forEach(e => {
        if(e.type==='dragon') drawDragonEnemy(ctx, e);
        else if(e.type==='triangle') drawTriangleEnemy(ctx, e);
        else drawRhombusEnemy(ctx, e);
    });

    ctx.fillStyle='#aaf'; enemyBullets.forEach(eb => { ctx.beginPath(); ctx.arc(eb.x, eb.y, 4*G_SCALE, 0, Math.PI*2); ctx.fill(); });

    if(gameState==='PLAYING') {
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.scale(G_SCALE, G_SCALE);
        ctx.strokeStyle = player.invuln > 0 ? '#ff0' : '#0f8'; ctx.lineWidth=2;
        ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
        ctx.beginPath(); 
        ctx.moveTo(20,0); ctx.lineTo(-10,10); ctx.lineTo(-5,0); ctx.lineTo(-10,-10); ctx.closePath(); 
        ctx.moveTo(-5,0); ctx.lineTo(-15, 15); ctx.moveTo(-5,0); ctx.lineTo(-15,-15); 
        ctx.stroke();
        ctx.restore(); ctx.shadowBlur=0;

        player.satellites.forEach(s => { ctx.fillStyle='#0f0'; ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI*2); ctx.fill(); });
    }

    ctx.fillStyle='#0f8'; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 2, 0, Math.PI*2); ctx.fill(); });
    ctx.fillStyle='#0f0'; crystals.forEach(c => { 
        ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(frame*0.1); 
        ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(4,0); ctx.lineTo(0,6); ctx.lineTo(-4,0); ctx.fill(); ctx.restore(); 
    });
    powerups.forEach(p => {
        ctx.strokeStyle = p.type==='level' ? '#0f0' : '#fd0'; ctx.lineWidth=2;
        ctx.strokeRect(p.x-8, p.y-8, 16, 16);
        ctx.fillStyle = ctx.strokeStyle; ctx.font='bold 12px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(p.type==='level'?'L':'S', p.x, p.y);
    });
    ctx.fillStyle='#fd0'; missiles.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, 4*G_SCALE, 0, Math.PI*2); ctx.fill(); });
    particles.forEach(p => { ctx.fillStyle=p.color; ctx.globalAlpha=p.life; ctx.beginPath(); ctx.arc(p.x, p.y, 2*G_SCALE, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0; });
    
    rings.forEach(r => {
        ctx.strokeStyle = r.color; ctx.lineWidth = 3; ctx.globalAlpha = r.life;
        ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 1.0;
    });

    drawScorePopups();
    ctx.restore();
}

function drawTriangleEnemy(ctx, e) {
    ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
    ctx.strokeStyle = e.color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.closePath();
    ctx.stroke(); ctx.restore();
}

function drawRhombusEnemy(ctx, e) {
    ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.rot); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE);
    ctx.strokeStyle = e.color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,0); ctx.lineTo(0,12); ctx.lineTo(-8,0); ctx.closePath();
    ctx.stroke(); ctx.restore();
}

function drawDragonEnemy(ctx, e) {
    ctx.save(); ctx.scale(e.scale * G_SCALE, e.scale * G_SCALE); ctx.strokeStyle = e.color; ctx.lineWidth = 2;
    e.segments.forEach((s, i) => {
        ctx.save(); ctx.translate(s.x / (e.scale*G_SCALE), s.y / (e.scale*G_SCALE)); ctx.rotate(s.angle);
        ctx.beginPath(); ctx.arc(0, 0, (12 - i*0.5) * 0.8, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); const wingSize = (15 - i*0.5); ctx.moveTo(0, 0); ctx.lineTo(-5, wingSize); ctx.moveTo(0, 0); ctx.lineTo(-5, -wingSize); ctx.stroke();
        ctx.restore();
    });
    ctx.save(); ctx.translate(e.x / (e.scale*G_SCALE), e.y / (e.scale*G_SCALE)); ctx.rotate(e.angle);
    ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(5, 12); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.lineTo(5, -12); ctx.closePath(); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(12, 7, 4, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(12, -7, 4, 0, Math.PI * 2); ctx.fill();
    ctx.restore(); ctx.restore();
}

function drawScorePopups() {
    ctx.fillStyle = '#fff'; ctx.font = '16px Orbitron'; ctx.textAlign = 'center';
    scorePopups.forEach(s => {
        ctx.globalAlpha = s.alpha;
        ctx.fillText(s.text, s.x, s.y);
    });
    ctx.globalAlpha = 1.0;
}

function updateGrid() {
    for(let i=0; i<gridPoints.length; i++) for(let j=0; j<gridPoints[i].length; j++) {
        const p=gridPoints[i][j];
        if(!p) continue;
        const dx=p.x-p.ox, dy=p.y-p.oy;
        const f = -0.05 * Math.hypot(dx,dy); const ang = Math.atan2(dy, dx);
        p.vx += Math.cos(ang)*f; p.vy += Math.sin(ang)*f; p.vx *= 0.9; p.vy *= 0.9;
        p.x += p.vx; p.y += p.vy;
    }
}
function distortGrid(x, y, force, radius) {
    const cx=Math.floor(x/GRID_SPACING), cy=Math.floor(y/GRID_SPACING), r=Math.ceil(radius/GRID_SPACING);
    for(let i=Math.max(0,cx-r); i<Math.min(gridPoints.length,cx+r); i++) for(let j=Math.max(0,cy-r); j<Math.min(gridPoints[0].length,cy+r); j++) {
        const p=gridPoints[i][j], d=Math.hypot(p.x-x, p.y-y);
        if(d<radius) { const f=force*(1-d/radius), a=Math.atan2(p.y-y, p.x-x); p.vx+=Math.cos(a)*f; p.vy+=Math.sin(a)*f; }
    }
}
function createExplosion(x, y, c, n) { 
    for(let i=0; i<n; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
            x, y, 
            vx: Math.cos(angle)*speed, 
            vy: Math.sin(angle)*speed, 
            color:c, life:1.0
        });
    }
}

function launchSatellites() {
    if(player.satellites.length===0) return;
    AudioSys.playSE('launch');
    player.satellites.forEach(s => {
        missiles.push({x:s.x, y:s.y, vx:Math.cos(s.angle)*10*SPEED_SCALE, vy:Math.sin(s.angle)*10*SPEED_SCALE, target:null, life:200, speed:12*SPEED_SCALE});
    });
    player.satellites=[]; 
    distortGrid(player.x, player.y, 300, 400);
}

// OST & Menu
function openOST() {
    AudioSys.resume(); gameState='OST';
    ui.overlay.style.display='none'; ui.ost.style.display='flex';
    const list=document.getElementById('track-list'); list.innerHTML='';
    [{n:'Title Theme',k:'title'},{n:'Stage 1',k:'stage',i:0},{n:'Stage 2',k:'stage',i:1},{n:'Stage 3',k:'stage',i:2},{n:'Stage 4',k:'stage',i:3},{n:'Clear Theme',k:'clear'}].forEach(t=>{
        const d=document.createElement('div'); d.className='track-item'; d.innerText=t.n;
        d.onclick=()=>{ AudioSys.playBGM(t.k,t.i); document.querySelectorAll('.track-item').forEach(e=>e.classList.remove('playing')); d.classList.add('playing'); };
        list.appendChild(d);
    });
}
function closeOST() { gameState='TITLE'; ui.ost.style.display='none'; ui.overlay.style.display='flex'; AudioSys.playBGM('title'); }

// Inputs
function handleTouch(e) {
    e.preventDefault();
    if(gameState !== 'PLAYING') return;
    input.move.active=false; input.aim.active=false;
    
    // Tap to Bomb Check (Top Area)
    const bRect = ui.prog.getBoundingClientRect(); // Use progress bar as mid line ref if needed, or window height
    
    const lR=ui.stickL.getBoundingClientRect(), rR=ui.stickR.getBoundingClientRect();
    const lC={x:lR.left+lR.width/2, y:lR.top+lR.height/2}, rC={x:rR.left+rR.width/2, y:rR.top+rR.height/2};

    for(let i=0; i<e.touches.length; i++) {
        const t=e.touches[i];
        
        // Bomb Area (Top 60%)
        if(t.clientY < height * 0.6) {
            launchSatellites();
            continue;
        }

        const dL=Math.hypot(t.clientX-lC.x, t.clientY-lC.y), dR=Math.hypot(t.clientX-rC.x, t.clientY-rC.y);
        
        if(dL<100) {
            input.move.active=true; const a=Math.atan2(t.clientY-lC.y, t.clientX-lC.x), d=Math.min(dL,40);
            input.move.x=Math.cos(a)*(d/40); input.move.y=Math.sin(a)*(d/40);
            ui.knobL.style.transform=`translate(${input.move.x*40}px,${input.move.y*40}px)`;
        } else if(dR<100) {
            input.aim.active=true; const a=Math.atan2(t.clientY-rC.y, t.clientX-rC.x), d=Math.min(dR,40);
            input.aim.x=Math.cos(a)*(d/40); input.aim.y=Math.sin(a)*(d/40);
            ui.knobR.style.transform=`translate(${input.aim.x*40}px,${input.aim.y*40}px)`;
        }
    }
    if(!input.move.active) { input.move.x=0; input.move.y=0; ui.knobL.style.transform='translate(0,0)'; }
    if(!input.aim.active) { input.aim.x=0; input.aim.y=0; ui.knobR.style.transform='translate(0,0)'; }
}

ui.controls.addEventListener('touchstart', handleTouch, {passive:false});
ui.controls.addEventListener('touchmove', handleTouch, {passive:false});
ui.controls.addEventListener('touchend', handleTouch, {passive:false});

document.getElementById('btn-start').onclick = startGame;
document.getElementById('btn-ost').onclick = openOST;
document.getElementById('btn-back').onclick = closeOST;

window.addEventListener('keydown', e => { 
    if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    input.keys[e.code]=true; 
    if(gameState==='TITLE'&&e.code==='Space') startGame(); 
    if(gameState==='PLAYING'&&e.code==='KeyZ') launchSatellites();
});
window.addEventListener('keyup', e => input.keys[e.code]=false);

document.body.addEventListener('click', ()=>{ AudioSys.resume(); if(gameState==='TITLE' && !AudioSys.currentSrc) AudioSys.playBGM('title'); }, {once:true});

function init() {
    resize();
    AudioSys.init();
    AudioSys.playBGM('title');
}

init();
loop();
</script>
</body>
</html>
